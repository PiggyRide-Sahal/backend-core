
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Route
 * 
 */
export type Route = $Result.DefaultSelection<Prisma.$RoutePayload>
/**
 * Model RouteStop
 * 
 */
export type RouteStop = $Result.DefaultSelection<Prisma.$RouteStopPayload>
/**
 * Model RouteDriver
 * 
 */
export type RouteDriver = $Result.DefaultSelection<Prisma.$RouteDriverPayload>
/**
 * Model Trip
 * 
 */
export type Trip = $Result.DefaultSelection<Prisma.$TripPayload>
/**
 * Model Ride
 * 
 */
export type Ride = $Result.DefaultSelection<Prisma.$RidePayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model Teen
 * 
 */
export type Teen = $Result.DefaultSelection<Prisma.$TeenPayload>
/**
 * Model RideRequest
 * 
 */
export type RideRequest = $Result.DefaultSelection<Prisma.$RideRequestPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model DriverVerification
 * 
 */
export type DriverVerification = $Result.DefaultSelection<Prisma.$DriverVerificationPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TeenBuddy
 * 
 */
export type TeenBuddy = $Result.DefaultSelection<Prisma.$TeenBuddyPayload>
/**
 * Model TeenRewards
 * 
 */
export type TeenRewards = $Result.DefaultSelection<Prisma.$TeenRewardsPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model TempTrackingLink
 * 
 */
export type TempTrackingLink = $Result.DefaultSelection<Prisma.$TempTrackingLinkPayload>
/**
 * Model RouteFeatures
 * 
 */
export type RouteFeatures = $Result.DefaultSelection<Prisma.$RouteFeaturesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  PARENT: 'PARENT',
  DRIVER: 'DRIVER',
  TEEN: 'TEEN',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const LocationType: {
  SCHOOL: 'SCHOOL',
  BUSINESS: 'BUSINESS',
  RESIDENTIAL: 'RESIDENTIAL',
  BUS_STOP: 'BUS_STOP',
  LANDMARK: 'LANDMARK',
  OTHER: 'OTHER'
};

export type LocationType = (typeof LocationType)[keyof typeof LocationType]


export const RouteType: {
  ADMIN_CREATED: 'ADMIN_CREATED',
  DRIVER_CREATED: 'DRIVER_CREATED',
  PARENT_CREATED: 'PARENT_CREATED',
  TEEN_REQUESTED: 'TEEN_REQUESTED'
};

export type RouteType = (typeof RouteType)[keyof typeof RouteType]


export const RouteStatus: {
  PENDING_TEEN: 'PENDING_TEEN',
  PENDING_PARENT: 'PENDING_PARENT',
  PENDING_DRIVER: 'PENDING_DRIVER',
  PENDING_ADMIN: 'PENDING_ADMIN',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type RouteStatus = (typeof RouteStatus)[keyof typeof RouteStatus]


export const RouteFrequency: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type RouteFrequency = (typeof RouteFrequency)[keyof typeof RouteFrequency]


export const PricingType: {
  FIXED: 'FIXED',
  PER_KM: 'PER_KM',
  ZONE_BASED: 'ZONE_BASED'
};

export type PricingType = (typeof PricingType)[keyof typeof PricingType]


export const TripStatus: {
  SCHEDULED: 'SCHEDULED',
  DRIVER_ASSIGNED: 'DRIVER_ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type TripStatus = (typeof TripStatus)[keyof typeof TripStatus]


export const RideStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  PICKUP_PENDING: 'PICKUP_PENDING',
  PICKED_UP: 'PICKED_UP',
  DROP_PENDING: 'DROP_PENDING',
  DROPPED_OFF: 'DROPPED_OFF',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type RideStatus = (typeof RideStatus)[keyof typeof RideStatus]


export const TransactionType: {
  TOPUP: 'TOPUP',
  RIDE_PAYMENT: 'RIDE_PAYMENT',
  REFUND: 'REFUND',
  REWARD: 'REWARD'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const BuddyStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  BLOCKED: 'BLOCKED'
};

export type BuddyStatus = (typeof BuddyStatus)[keyof typeof BuddyStatus]


export const InviteStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  EXPIRED: 'EXPIRED',
  REJECTED: 'REJECTED'
};

export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus]


export const InviteType: {
  PARENT_TO_TEEN: 'PARENT_TO_TEEN',
  TEEN_TO_PARENT: 'TEEN_TO_PARENT'
};

export type InviteType = (typeof InviteType)[keyof typeof InviteType]


export const DocumentType: {
  DRIVING_LICENSE: 'DRIVING_LICENSE',
  AADHAR_CARD: 'AADHAR_CARD',
  VEHICLE_RC: 'VEHICLE_RC',
  INSURANCE: 'INSURANCE',
  POLICE_VERIFICATION: 'POLICE_VERIFICATION'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const VerificationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const RequestType: {
  NEW_ROUTE: 'NEW_ROUTE',
  JOIN_EXISTING: 'JOIN_EXISTING',
  TEMPORARY: 'TEMPORARY',
  RECURRING: 'RECURRING'
};

export type RequestType = (typeof RequestType)[keyof typeof RequestType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type LocationType = $Enums.LocationType

export const LocationType: typeof $Enums.LocationType

export type RouteType = $Enums.RouteType

export const RouteType: typeof $Enums.RouteType

export type RouteStatus = $Enums.RouteStatus

export const RouteStatus: typeof $Enums.RouteStatus

export type RouteFrequency = $Enums.RouteFrequency

export const RouteFrequency: typeof $Enums.RouteFrequency

export type PricingType = $Enums.PricingType

export const PricingType: typeof $Enums.PricingType

export type TripStatus = $Enums.TripStatus

export const TripStatus: typeof $Enums.TripStatus

export type RideStatus = $Enums.RideStatus

export const RideStatus: typeof $Enums.RideStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type BuddyStatus = $Enums.BuddyStatus

export const BuddyStatus: typeof $Enums.BuddyStatus

export type InviteStatus = $Enums.InviteStatus

export const InviteStatus: typeof $Enums.InviteStatus

export type InviteType = $Enums.InviteType

export const InviteType: typeof $Enums.InviteType

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type RequestType = $Enums.RequestType

export const RequestType: typeof $Enums.RequestType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.route`: Exposes CRUD operations for the **Route** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routes
    * const routes = await prisma.route.findMany()
    * ```
    */
  get route(): Prisma.RouteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routeStop`: Exposes CRUD operations for the **RouteStop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteStops
    * const routeStops = await prisma.routeStop.findMany()
    * ```
    */
  get routeStop(): Prisma.RouteStopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routeDriver`: Exposes CRUD operations for the **RouteDriver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteDrivers
    * const routeDrivers = await prisma.routeDriver.findMany()
    * ```
    */
  get routeDriver(): Prisma.RouteDriverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trip`: Exposes CRUD operations for the **Trip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trips
    * const trips = await prisma.trip.findMany()
    * ```
    */
  get trip(): Prisma.TripDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ride`: Exposes CRUD operations for the **Ride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rides
    * const rides = await prisma.ride.findMany()
    * ```
    */
  get ride(): Prisma.RideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teen`: Exposes CRUD operations for the **Teen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teens
    * const teens = await prisma.teen.findMany()
    * ```
    */
  get teen(): Prisma.TeenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rideRequest`: Exposes CRUD operations for the **RideRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RideRequests
    * const rideRequests = await prisma.rideRequest.findMany()
    * ```
    */
  get rideRequest(): Prisma.RideRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driverVerification`: Exposes CRUD operations for the **DriverVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DriverVerifications
    * const driverVerifications = await prisma.driverVerification.findMany()
    * ```
    */
  get driverVerification(): Prisma.DriverVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teenBuddy`: Exposes CRUD operations for the **TeenBuddy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeenBuddies
    * const teenBuddies = await prisma.teenBuddy.findMany()
    * ```
    */
  get teenBuddy(): Prisma.TeenBuddyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teenRewards`: Exposes CRUD operations for the **TeenRewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeenRewards
    * const teenRewards = await prisma.teenRewards.findMany()
    * ```
    */
  get teenRewards(): Prisma.TeenRewardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tempTrackingLink`: Exposes CRUD operations for the **TempTrackingLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TempTrackingLinks
    * const tempTrackingLinks = await prisma.tempTrackingLink.findMany()
    * ```
    */
  get tempTrackingLink(): Prisma.TempTrackingLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routeFeatures`: Exposes CRUD operations for the **RouteFeatures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteFeatures
    * const routeFeatures = await prisma.routeFeatures.findMany()
    * ```
    */
  get routeFeatures(): Prisma.RouteFeaturesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Location: 'Location',
    Route: 'Route',
    RouteStop: 'RouteStop',
    RouteDriver: 'RouteDriver',
    Trip: 'Trip',
    Ride: 'Ride',
    Parent: 'Parent',
    Driver: 'Driver',
    Teen: 'Teen',
    RideRequest: 'RideRequest',
    Vehicle: 'Vehicle',
    DriverVerification: 'DriverVerification',
    Document: 'Document',
    Wallet: 'Wallet',
    Transaction: 'Transaction',
    TeenBuddy: 'TeenBuddy',
    TeenRewards: 'TeenRewards',
    Achievement: 'Achievement',
    Admin: 'Admin',
    TempTrackingLink: 'TempTrackingLink',
    RouteFeatures: 'RouteFeatures'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "location" | "route" | "routeStop" | "routeDriver" | "trip" | "ride" | "parent" | "driver" | "teen" | "rideRequest" | "vehicle" | "driverVerification" | "document" | "wallet" | "transaction" | "teenBuddy" | "teenRewards" | "achievement" | "admin" | "tempTrackingLink" | "routeFeatures"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Route: {
        payload: Prisma.$RoutePayload<ExtArgs>
        fields: Prisma.RouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findFirst: {
            args: Prisma.RouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findMany: {
            args: Prisma.RouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          create: {
            args: Prisma.RouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          createMany: {
            args: Prisma.RouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          delete: {
            args: Prisma.RouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          update: {
            args: Prisma.RouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          deleteMany: {
            args: Prisma.RouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          upsert: {
            args: Prisma.RouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          aggregate: {
            args: Prisma.RouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoute>
          }
          groupBy: {
            args: Prisma.RouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteCountArgs<ExtArgs>
            result: $Utils.Optional<RouteCountAggregateOutputType> | number
          }
        }
      }
      RouteStop: {
        payload: Prisma.$RouteStopPayload<ExtArgs>
        fields: Prisma.RouteStopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteStopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteStopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          findFirst: {
            args: Prisma.RouteStopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteStopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          findMany: {
            args: Prisma.RouteStopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>[]
          }
          create: {
            args: Prisma.RouteStopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          createMany: {
            args: Prisma.RouteStopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteStopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>[]
          }
          delete: {
            args: Prisma.RouteStopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          update: {
            args: Prisma.RouteStopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          deleteMany: {
            args: Prisma.RouteStopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteStopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteStopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>[]
          }
          upsert: {
            args: Prisma.RouteStopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          aggregate: {
            args: Prisma.RouteStopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteStop>
          }
          groupBy: {
            args: Prisma.RouteStopGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteStopGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteStopCountArgs<ExtArgs>
            result: $Utils.Optional<RouteStopCountAggregateOutputType> | number
          }
        }
      }
      RouteDriver: {
        payload: Prisma.$RouteDriverPayload<ExtArgs>
        fields: Prisma.RouteDriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteDriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteDriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>
          }
          findFirst: {
            args: Prisma.RouteDriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteDriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>
          }
          findMany: {
            args: Prisma.RouteDriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>[]
          }
          create: {
            args: Prisma.RouteDriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>
          }
          createMany: {
            args: Prisma.RouteDriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteDriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>[]
          }
          delete: {
            args: Prisma.RouteDriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>
          }
          update: {
            args: Prisma.RouteDriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>
          }
          deleteMany: {
            args: Prisma.RouteDriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteDriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteDriverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>[]
          }
          upsert: {
            args: Prisma.RouteDriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteDriverPayload>
          }
          aggregate: {
            args: Prisma.RouteDriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteDriver>
          }
          groupBy: {
            args: Prisma.RouteDriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteDriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteDriverCountArgs<ExtArgs>
            result: $Utils.Optional<RouteDriverCountAggregateOutputType> | number
          }
        }
      }
      Trip: {
        payload: Prisma.$TripPayload<ExtArgs>
        fields: Prisma.TripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findFirst: {
            args: Prisma.TripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          findMany: {
            args: Prisma.TripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          create: {
            args: Prisma.TripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          createMany: {
            args: Prisma.TripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          delete: {
            args: Prisma.TripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          update: {
            args: Prisma.TripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          deleteMany: {
            args: Prisma.TripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>[]
          }
          upsert: {
            args: Prisma.TripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripPayload>
          }
          aggregate: {
            args: Prisma.TripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrip>
          }
          groupBy: {
            args: Prisma.TripGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripCountArgs<ExtArgs>
            result: $Utils.Optional<TripCountAggregateOutputType> | number
          }
        }
      }
      Ride: {
        payload: Prisma.$RidePayload<ExtArgs>
        fields: Prisma.RideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          findFirst: {
            args: Prisma.RideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          findMany: {
            args: Prisma.RideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>[]
          }
          create: {
            args: Prisma.RideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          createMany: {
            args: Prisma.RideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>[]
          }
          delete: {
            args: Prisma.RideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          update: {
            args: Prisma.RideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          deleteMany: {
            args: Prisma.RideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>[]
          }
          upsert: {
            args: Prisma.RideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidePayload>
          }
          aggregate: {
            args: Prisma.RideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRide>
          }
          groupBy: {
            args: Prisma.RideGroupByArgs<ExtArgs>
            result: $Utils.Optional<RideGroupByOutputType>[]
          }
          count: {
            args: Prisma.RideCountArgs<ExtArgs>
            result: $Utils.Optional<RideCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      Teen: {
        payload: Prisma.$TeenPayload<ExtArgs>
        fields: Prisma.TeenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>
          }
          findFirst: {
            args: Prisma.TeenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>
          }
          findMany: {
            args: Prisma.TeenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>[]
          }
          create: {
            args: Prisma.TeenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>
          }
          createMany: {
            args: Prisma.TeenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>[]
          }
          delete: {
            args: Prisma.TeenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>
          }
          update: {
            args: Prisma.TeenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>
          }
          deleteMany: {
            args: Prisma.TeenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>[]
          }
          upsert: {
            args: Prisma.TeenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenPayload>
          }
          aggregate: {
            args: Prisma.TeenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeen>
          }
          groupBy: {
            args: Prisma.TeenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeenCountArgs<ExtArgs>
            result: $Utils.Optional<TeenCountAggregateOutputType> | number
          }
        }
      }
      RideRequest: {
        payload: Prisma.$RideRequestPayload<ExtArgs>
        fields: Prisma.RideRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RideRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RideRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>
          }
          findFirst: {
            args: Prisma.RideRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RideRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>
          }
          findMany: {
            args: Prisma.RideRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>[]
          }
          create: {
            args: Prisma.RideRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>
          }
          createMany: {
            args: Prisma.RideRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RideRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>[]
          }
          delete: {
            args: Prisma.RideRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>
          }
          update: {
            args: Prisma.RideRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>
          }
          deleteMany: {
            args: Prisma.RideRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RideRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RideRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>[]
          }
          upsert: {
            args: Prisma.RideRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RideRequestPayload>
          }
          aggregate: {
            args: Prisma.RideRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRideRequest>
          }
          groupBy: {
            args: Prisma.RideRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<RideRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.RideRequestCountArgs<ExtArgs>
            result: $Utils.Optional<RideRequestCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      DriverVerification: {
        payload: Prisma.$DriverVerificationPayload<ExtArgs>
        fields: Prisma.DriverVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>
          }
          findFirst: {
            args: Prisma.DriverVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>
          }
          findMany: {
            args: Prisma.DriverVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>[]
          }
          create: {
            args: Prisma.DriverVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>
          }
          createMany: {
            args: Prisma.DriverVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>[]
          }
          delete: {
            args: Prisma.DriverVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>
          }
          update: {
            args: Prisma.DriverVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>
          }
          deleteMany: {
            args: Prisma.DriverVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>[]
          }
          upsert: {
            args: Prisma.DriverVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverVerificationPayload>
          }
          aggregate: {
            args: Prisma.DriverVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriverVerification>
          }
          groupBy: {
            args: Prisma.DriverVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<DriverVerificationCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TeenBuddy: {
        payload: Prisma.$TeenBuddyPayload<ExtArgs>
        fields: Prisma.TeenBuddyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeenBuddyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeenBuddyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>
          }
          findFirst: {
            args: Prisma.TeenBuddyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeenBuddyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>
          }
          findMany: {
            args: Prisma.TeenBuddyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>[]
          }
          create: {
            args: Prisma.TeenBuddyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>
          }
          createMany: {
            args: Prisma.TeenBuddyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeenBuddyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>[]
          }
          delete: {
            args: Prisma.TeenBuddyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>
          }
          update: {
            args: Prisma.TeenBuddyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>
          }
          deleteMany: {
            args: Prisma.TeenBuddyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeenBuddyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeenBuddyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>[]
          }
          upsert: {
            args: Prisma.TeenBuddyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenBuddyPayload>
          }
          aggregate: {
            args: Prisma.TeenBuddyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeenBuddy>
          }
          groupBy: {
            args: Prisma.TeenBuddyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeenBuddyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeenBuddyCountArgs<ExtArgs>
            result: $Utils.Optional<TeenBuddyCountAggregateOutputType> | number
          }
        }
      }
      TeenRewards: {
        payload: Prisma.$TeenRewardsPayload<ExtArgs>
        fields: Prisma.TeenRewardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeenRewardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeenRewardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>
          }
          findFirst: {
            args: Prisma.TeenRewardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeenRewardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>
          }
          findMany: {
            args: Prisma.TeenRewardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>[]
          }
          create: {
            args: Prisma.TeenRewardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>
          }
          createMany: {
            args: Prisma.TeenRewardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeenRewardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>[]
          }
          delete: {
            args: Prisma.TeenRewardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>
          }
          update: {
            args: Prisma.TeenRewardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>
          }
          deleteMany: {
            args: Prisma.TeenRewardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeenRewardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeenRewardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>[]
          }
          upsert: {
            args: Prisma.TeenRewardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeenRewardsPayload>
          }
          aggregate: {
            args: Prisma.TeenRewardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeenRewards>
          }
          groupBy: {
            args: Prisma.TeenRewardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeenRewardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeenRewardsCountArgs<ExtArgs>
            result: $Utils.Optional<TeenRewardsCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      TempTrackingLink: {
        payload: Prisma.$TempTrackingLinkPayload<ExtArgs>
        fields: Prisma.TempTrackingLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TempTrackingLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TempTrackingLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>
          }
          findFirst: {
            args: Prisma.TempTrackingLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TempTrackingLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>
          }
          findMany: {
            args: Prisma.TempTrackingLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>[]
          }
          create: {
            args: Prisma.TempTrackingLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>
          }
          createMany: {
            args: Prisma.TempTrackingLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TempTrackingLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>[]
          }
          delete: {
            args: Prisma.TempTrackingLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>
          }
          update: {
            args: Prisma.TempTrackingLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>
          }
          deleteMany: {
            args: Prisma.TempTrackingLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TempTrackingLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TempTrackingLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>[]
          }
          upsert: {
            args: Prisma.TempTrackingLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TempTrackingLinkPayload>
          }
          aggregate: {
            args: Prisma.TempTrackingLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTempTrackingLink>
          }
          groupBy: {
            args: Prisma.TempTrackingLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<TempTrackingLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.TempTrackingLinkCountArgs<ExtArgs>
            result: $Utils.Optional<TempTrackingLinkCountAggregateOutputType> | number
          }
        }
      }
      RouteFeatures: {
        payload: Prisma.$RouteFeaturesPayload<ExtArgs>
        fields: Prisma.RouteFeaturesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteFeaturesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFeaturesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>
          }
          findFirst: {
            args: Prisma.RouteFeaturesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFeaturesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>
          }
          findMany: {
            args: Prisma.RouteFeaturesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>[]
          }
          create: {
            args: Prisma.RouteFeaturesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>
          }
          createMany: {
            args: Prisma.RouteFeaturesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteFeaturesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>[]
          }
          delete: {
            args: Prisma.RouteFeaturesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>
          }
          update: {
            args: Prisma.RouteFeaturesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>
          }
          deleteMany: {
            args: Prisma.RouteFeaturesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteFeaturesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RouteFeaturesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>[]
          }
          upsert: {
            args: Prisma.RouteFeaturesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFeaturesPayload>
          }
          aggregate: {
            args: Prisma.RouteFeaturesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteFeatures>
          }
          groupBy: {
            args: Prisma.RouteFeaturesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteFeaturesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteFeaturesCountArgs<ExtArgs>
            result: $Utils.Optional<RouteFeaturesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    location?: LocationOmit
    route?: RouteOmit
    routeStop?: RouteStopOmit
    routeDriver?: RouteDriverOmit
    trip?: TripOmit
    ride?: RideOmit
    parent?: ParentOmit
    driver?: DriverOmit
    teen?: TeenOmit
    rideRequest?: RideRequestOmit
    vehicle?: VehicleOmit
    driverVerification?: DriverVerificationOmit
    document?: DocumentOmit
    wallet?: WalletOmit
    transaction?: TransactionOmit
    teenBuddy?: TeenBuddyOmit
    teenRewards?: TeenRewardsOmit
    achievement?: AchievementOmit
    admin?: AdminOmit
    tempTrackingLink?: TempTrackingLinkOmit
    routeFeatures?: RouteFeaturesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    routeStops: number
    teens: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routeStops?: boolean | LocationCountOutputTypeCountRouteStopsArgs
    teens?: boolean | LocationCountOutputTypeCountTeensArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountRouteStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountTeensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeenWhereInput
  }


  /**
   * Count Type RouteCountOutputType
   */

  export type RouteCountOutputType = {
    requests: number
    drivers: number
    stops: number
    trips: number
  }

  export type RouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requests?: boolean | RouteCountOutputTypeCountRequestsArgs
    drivers?: boolean | RouteCountOutputTypeCountDriversArgs
    stops?: boolean | RouteCountOutputTypeCountStopsArgs
    trips?: boolean | RouteCountOutputTypeCountTripsArgs
  }

  // Custom InputTypes
  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCountOutputType
     */
    select?: RouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideRequestWhereInput
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteDriverWhereInput
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }


  /**
   * Count Type RouteStopCountOutputType
   */

  export type RouteStopCountOutputType = {
    dropRides: number
    pickupRides: number
    dropRequests: number
    pickupRequests: number
  }

  export type RouteStopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dropRides?: boolean | RouteStopCountOutputTypeCountDropRidesArgs
    pickupRides?: boolean | RouteStopCountOutputTypeCountPickupRidesArgs
    dropRequests?: boolean | RouteStopCountOutputTypeCountDropRequestsArgs
    pickupRequests?: boolean | RouteStopCountOutputTypeCountPickupRequestsArgs
  }

  // Custom InputTypes
  /**
   * RouteStopCountOutputType without action
   */
  export type RouteStopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStopCountOutputType
     */
    select?: RouteStopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteStopCountOutputType without action
   */
  export type RouteStopCountOutputTypeCountDropRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
  }

  /**
   * RouteStopCountOutputType without action
   */
  export type RouteStopCountOutputTypeCountPickupRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
  }

  /**
   * RouteStopCountOutputType without action
   */
  export type RouteStopCountOutputTypeCountDropRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideRequestWhereInput
  }

  /**
   * RouteStopCountOutputType without action
   */
  export type RouteStopCountOutputTypeCountPickupRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideRequestWhereInput
  }


  /**
   * Count Type TripCountOutputType
   */

  export type TripCountOutputType = {
    rides: number
  }

  export type TripCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rides?: boolean | TripCountOutputTypeCountRidesArgs
  }

  // Custom InputTypes
  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripCountOutputType
     */
    select?: TripCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripCountOutputType without action
   */
  export type TripCountOutputTypeCountRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
  }


  /**
   * Count Type RideCountOutputType
   */

  export type RideCountOutputType = {
    transactions: number
  }

  export type RideCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | RideCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideCountOutputType
     */
    select?: RideCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RideCountOutputType without action
   */
  export type RideCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    rideRequests: number
    teens: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rideRequests?: boolean | ParentCountOutputTypeCountRideRequestsArgs
    teens?: boolean | ParentCountOutputTypeCountTeensArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountRideRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideRequestWhereInput
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountTeensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeenWhereInput
  }


  /**
   * Count Type DriverCountOutputType
   */

  export type DriverCountOutputType = {
    routeAssignments: number
    trips: number
  }

  export type DriverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routeAssignments?: boolean | DriverCountOutputTypeCountRouteAssignmentsArgs
    trips?: boolean | DriverCountOutputTypeCountTripsArgs
  }

  // Custom InputTypes
  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountRouteAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteDriverWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountTripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
  }


  /**
   * Count Type TeenCountOutputType
   */

  export type TeenCountOutputType = {
    rides: number
    rideRequests: number
    buddyOf: number
    buddies: number
  }

  export type TeenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rides?: boolean | TeenCountOutputTypeCountRidesArgs
    rideRequests?: boolean | TeenCountOutputTypeCountRideRequestsArgs
    buddyOf?: boolean | TeenCountOutputTypeCountBuddyOfArgs
    buddies?: boolean | TeenCountOutputTypeCountBuddiesArgs
  }

  // Custom InputTypes
  /**
   * TeenCountOutputType without action
   */
  export type TeenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenCountOutputType
     */
    select?: TeenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeenCountOutputType without action
   */
  export type TeenCountOutputTypeCountRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
  }

  /**
   * TeenCountOutputType without action
   */
  export type TeenCountOutputTypeCountRideRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideRequestWhereInput
  }

  /**
   * TeenCountOutputType without action
   */
  export type TeenCountOutputTypeCountBuddyOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeenBuddyWhereInput
  }

  /**
   * TeenCountOutputType without action
   */
  export type TeenCountOutputTypeCountBuddiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeenBuddyWhereInput
  }


  /**
   * Count Type DriverVerificationCountOutputType
   */

  export type DriverVerificationCountOutputType = {
    documents: number
  }

  export type DriverVerificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | DriverVerificationCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DriverVerificationCountOutputType without action
   */
  export type DriverVerificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerificationCountOutputType
     */
    select?: DriverVerificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverVerificationCountOutputType without action
   */
  export type DriverVerificationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    transactions: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type TeenRewardsCountOutputType
   */

  export type TeenRewardsCountOutputType = {
    achievements: number
  }

  export type TeenRewardsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievements?: boolean | TeenRewardsCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * TeenRewardsCountOutputType without action
   */
  export type TeenRewardsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewardsCountOutputType
     */
    select?: TeenRewardsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeenRewardsCountOutputType without action
   */
  export type TeenRewardsCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    fcmToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    fcmToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    phone: number
    role: number
    isActive: number
    fcmToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    isActive?: true
    fcmToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    isActive?: true
    fcmToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    role?: true
    isActive?: true
    fcmToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive: boolean
    fcmToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    fcmToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | User$adminArgs<ExtArgs>
    driver?: boolean | User$driverArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    teen?: boolean | User$teenArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    fcmToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    fcmToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    isActive?: boolean
    fcmToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "phone" | "role" | "isActive" | "fcmToken" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | User$adminArgs<ExtArgs>
    driver?: boolean | User$driverArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    teen?: boolean | User$teenArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      driver: Prisma.$DriverPayload<ExtArgs> | null
      parent: Prisma.$ParentPayload<ExtArgs> | null
      teen: Prisma.$TeenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      phone: string
      role: $Enums.UserRole
      isActive: boolean
      fcmToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    driver<T extends User$driverArgs<ExtArgs> = {}>(args?: Subset<T, User$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends User$parentArgs<ExtArgs> = {}>(args?: Subset<T, User$parentArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teen<T extends User$teenArgs<ExtArgs> = {}>(args?: Subset<T, User$teenArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly fcmToken: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.driver
   */
  export type User$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * User.parent
   */
  export type User$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * User.teen
   */
  export type User$teenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    where?: TeenWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    latitude: number | null
    longitude: number | null
    type: $Enums.LocationType | null
    isVerified: boolean | null
    contactNumber: string | null
    createdBy: string | null
    verifiedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    latitude: number | null
    longitude: number | null
    type: $Enums.LocationType | null
    isVerified: boolean | null
    contactNumber: string | null
    createdBy: string | null
    verifiedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    address: number
    latitude: number
    longitude: number
    type: number
    isVerified: number
    contactNumber: number
    operatingHours: number
    createdBy: number
    verifiedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    type?: true
    isVerified?: true
    contactNumber?: true
    createdBy?: true
    verifiedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    type?: true
    isVerified?: true
    contactNumber?: true
    createdBy?: true
    verifiedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    type?: true
    isVerified?: true
    contactNumber?: true
    operatingHours?: true
    createdBy?: true
    verifiedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    address: string
    latitude: number
    longitude: number
    type: $Enums.LocationType
    isVerified: boolean
    contactNumber: string | null
    operatingHours: JsonValue | null
    createdBy: string | null
    verifiedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    type?: boolean
    isVerified?: boolean
    contactNumber?: boolean
    operatingHours?: boolean
    createdBy?: boolean
    verifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    routeStops?: boolean | Location$routeStopsArgs<ExtArgs>
    teens?: boolean | Location$teensArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    type?: boolean
    isVerified?: boolean
    contactNumber?: boolean
    operatingHours?: boolean
    createdBy?: boolean
    verifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    type?: boolean
    isVerified?: boolean
    contactNumber?: boolean
    operatingHours?: boolean
    createdBy?: boolean
    verifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    type?: boolean
    isVerified?: boolean
    contactNumber?: boolean
    operatingHours?: boolean
    createdBy?: boolean
    verifiedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "latitude" | "longitude" | "type" | "isVerified" | "contactNumber" | "operatingHours" | "createdBy" | "verifiedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routeStops?: boolean | Location$routeStopsArgs<ExtArgs>
    teens?: boolean | Location$teensArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      routeStops: Prisma.$RouteStopPayload<ExtArgs>[]
      teens: Prisma.$TeenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      latitude: number
      longitude: number
      type: $Enums.LocationType
      isVerified: boolean
      contactNumber: string | null
      operatingHours: Prisma.JsonValue | null
      createdBy: string | null
      verifiedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routeStops<T extends Location$routeStopsArgs<ExtArgs> = {}>(args?: Subset<T, Location$routeStopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teens<T extends Location$teensArgs<ExtArgs> = {}>(args?: Subset<T, Location$teensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly address: FieldRef<"Location", 'String'>
    readonly latitude: FieldRef<"Location", 'Float'>
    readonly longitude: FieldRef<"Location", 'Float'>
    readonly type: FieldRef<"Location", 'LocationType'>
    readonly isVerified: FieldRef<"Location", 'Boolean'>
    readonly contactNumber: FieldRef<"Location", 'String'>
    readonly operatingHours: FieldRef<"Location", 'Json'>
    readonly createdBy: FieldRef<"Location", 'String'>
    readonly verifiedBy: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.routeStops
   */
  export type Location$routeStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    cursor?: RouteStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * Location.teens
   */
  export type Location$teensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    where?: TeenWhereInput
    orderBy?: TeenOrderByWithRelationInput | TeenOrderByWithRelationInput[]
    cursor?: TeenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeenScalarFieldEnum | TeenScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Route
   */

  export type AggregateRoute = {
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  export type RouteAvgAggregateOutputType = {
    daysOfWeek: number | null
    baseFare: number | null
    perKmRate: number | null
    roundTripDiscount: number | null
    totalSeats: number | null
    availableSeats: number | null
    farePerSeat: number | null
    minOccupancyRatio: number | null
    maxOccupancyRatio: number | null
  }

  export type RouteSumAggregateOutputType = {
    daysOfWeek: number[]
    baseFare: number | null
    perKmRate: number | null
    roundTripDiscount: number | null
    totalSeats: number | null
    availableSeats: number | null
    farePerSeat: number | null
    minOccupancyRatio: number | null
    maxOccupancyRatio: number | null
  }

  export type RouteMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    routeType: $Enums.RouteType | null
    frequency: $Enums.RouteFrequency | null
    startDate: Date | null
    endDate: Date | null
    isRecurring: boolean | null
    baseFare: number | null
    pricingType: $Enums.PricingType | null
    perKmRate: number | null
    roundTripDiscount: number | null
    totalSeats: number | null
    availableSeats: number | null
    farePerSeat: number | null
    status: $Enums.RouteStatus | null
    isActive: boolean | null
    isListedPublicly: boolean | null
    allowDriverBidding: boolean | null
    autoApproveRequests: boolean | null
    minOccupancyRatio: number | null
    maxOccupancyRatio: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    routeType: $Enums.RouteType | null
    frequency: $Enums.RouteFrequency | null
    startDate: Date | null
    endDate: Date | null
    isRecurring: boolean | null
    baseFare: number | null
    pricingType: $Enums.PricingType | null
    perKmRate: number | null
    roundTripDiscount: number | null
    totalSeats: number | null
    availableSeats: number | null
    farePerSeat: number | null
    status: $Enums.RouteStatus | null
    isActive: boolean | null
    isListedPublicly: boolean | null
    allowDriverBidding: boolean | null
    autoApproveRequests: boolean | null
    minOccupancyRatio: number | null
    maxOccupancyRatio: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteCountAggregateOutputType = {
    id: number
    name: number
    description: number
    routeType: number
    frequency: number
    daysOfWeek: number
    startDate: number
    endDate: number
    isRecurring: number
    baseFare: number
    pricingType: number
    perKmRate: number
    roundTripDiscount: number
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status: number
    isActive: number
    isListedPublicly: number
    allowDriverBidding: number
    autoApproveRequests: number
    minOccupancyRatio: number
    maxOccupancyRatio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RouteAvgAggregateInputType = {
    daysOfWeek?: true
    baseFare?: true
    perKmRate?: true
    roundTripDiscount?: true
    totalSeats?: true
    availableSeats?: true
    farePerSeat?: true
    minOccupancyRatio?: true
    maxOccupancyRatio?: true
  }

  export type RouteSumAggregateInputType = {
    daysOfWeek?: true
    baseFare?: true
    perKmRate?: true
    roundTripDiscount?: true
    totalSeats?: true
    availableSeats?: true
    farePerSeat?: true
    minOccupancyRatio?: true
    maxOccupancyRatio?: true
  }

  export type RouteMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    routeType?: true
    frequency?: true
    startDate?: true
    endDate?: true
    isRecurring?: true
    baseFare?: true
    pricingType?: true
    perKmRate?: true
    roundTripDiscount?: true
    totalSeats?: true
    availableSeats?: true
    farePerSeat?: true
    status?: true
    isActive?: true
    isListedPublicly?: true
    allowDriverBidding?: true
    autoApproveRequests?: true
    minOccupancyRatio?: true
    maxOccupancyRatio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    routeType?: true
    frequency?: true
    startDate?: true
    endDate?: true
    isRecurring?: true
    baseFare?: true
    pricingType?: true
    perKmRate?: true
    roundTripDiscount?: true
    totalSeats?: true
    availableSeats?: true
    farePerSeat?: true
    status?: true
    isActive?: true
    isListedPublicly?: true
    allowDriverBidding?: true
    autoApproveRequests?: true
    minOccupancyRatio?: true
    maxOccupancyRatio?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    routeType?: true
    frequency?: true
    daysOfWeek?: true
    startDate?: true
    endDate?: true
    isRecurring?: true
    baseFare?: true
    pricingType?: true
    perKmRate?: true
    roundTripDiscount?: true
    totalSeats?: true
    availableSeats?: true
    farePerSeat?: true
    status?: true
    isActive?: true
    isListedPublicly?: true
    allowDriverBidding?: true
    autoApproveRequests?: true
    minOccupancyRatio?: true
    maxOccupancyRatio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Route to aggregate.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routes
    **/
    _count?: true | RouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteMaxAggregateInputType
  }

  export type GetRouteAggregateType<T extends RouteAggregateArgs> = {
        [P in keyof T & keyof AggregateRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoute[P]>
      : GetScalarType<T[P], AggregateRoute[P]>
  }




  export type RouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithAggregationInput | RouteOrderByWithAggregationInput[]
    by: RouteScalarFieldEnum[] | RouteScalarFieldEnum
    having?: RouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteCountAggregateInputType | true
    _avg?: RouteAvgAggregateInputType
    _sum?: RouteSumAggregateInputType
    _min?: RouteMinAggregateInputType
    _max?: RouteMaxAggregateInputType
  }

  export type RouteGroupByOutputType = {
    id: string
    name: string
    description: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek: number[]
    startDate: Date
    endDate: Date | null
    isRecurring: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate: number | null
    roundTripDiscount: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status: $Enums.RouteStatus
    isActive: boolean
    isListedPublicly: boolean
    allowDriverBidding: boolean
    autoApproveRequests: boolean
    minOccupancyRatio: number
    maxOccupancyRatio: number
    createdAt: Date
    updatedAt: Date
    _count: RouteCountAggregateOutputType | null
    _avg: RouteAvgAggregateOutputType | null
    _sum: RouteSumAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  type GetRouteGroupByPayload<T extends RouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteGroupByOutputType[P]>
            : GetScalarType<T[P], RouteGroupByOutputType[P]>
        }
      >
    >


  export type RouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    routeType?: boolean
    frequency?: boolean
    daysOfWeek?: boolean
    startDate?: boolean
    endDate?: boolean
    isRecurring?: boolean
    baseFare?: boolean
    pricingType?: boolean
    perKmRate?: boolean
    roundTripDiscount?: boolean
    totalSeats?: boolean
    availableSeats?: boolean
    farePerSeat?: boolean
    status?: boolean
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: boolean
    maxOccupancyRatio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    features?: boolean | Route$featuresArgs<ExtArgs>
    requests?: boolean | Route$requestsArgs<ExtArgs>
    drivers?: boolean | Route$driversArgs<ExtArgs>
    stops?: boolean | Route$stopsArgs<ExtArgs>
    trips?: boolean | Route$tripsArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["route"]>

  export type RouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    routeType?: boolean
    frequency?: boolean
    daysOfWeek?: boolean
    startDate?: boolean
    endDate?: boolean
    isRecurring?: boolean
    baseFare?: boolean
    pricingType?: boolean
    perKmRate?: boolean
    roundTripDiscount?: boolean
    totalSeats?: boolean
    availableSeats?: boolean
    farePerSeat?: boolean
    status?: boolean
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: boolean
    maxOccupancyRatio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["route"]>

  export type RouteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    routeType?: boolean
    frequency?: boolean
    daysOfWeek?: boolean
    startDate?: boolean
    endDate?: boolean
    isRecurring?: boolean
    baseFare?: boolean
    pricingType?: boolean
    perKmRate?: boolean
    roundTripDiscount?: boolean
    totalSeats?: boolean
    availableSeats?: boolean
    farePerSeat?: boolean
    status?: boolean
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: boolean
    maxOccupancyRatio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["route"]>

  export type RouteSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    routeType?: boolean
    frequency?: boolean
    daysOfWeek?: boolean
    startDate?: boolean
    endDate?: boolean
    isRecurring?: boolean
    baseFare?: boolean
    pricingType?: boolean
    perKmRate?: boolean
    roundTripDiscount?: boolean
    totalSeats?: boolean
    availableSeats?: boolean
    farePerSeat?: boolean
    status?: boolean
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: boolean
    maxOccupancyRatio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RouteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "routeType" | "frequency" | "daysOfWeek" | "startDate" | "endDate" | "isRecurring" | "baseFare" | "pricingType" | "perKmRate" | "roundTripDiscount" | "totalSeats" | "availableSeats" | "farePerSeat" | "status" | "isActive" | "isListedPublicly" | "allowDriverBidding" | "autoApproveRequests" | "minOccupancyRatio" | "maxOccupancyRatio" | "createdAt" | "updatedAt", ExtArgs["result"]["route"]>
  export type RouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | Route$featuresArgs<ExtArgs>
    requests?: boolean | Route$requestsArgs<ExtArgs>
    drivers?: boolean | Route$driversArgs<ExtArgs>
    stops?: boolean | Route$stopsArgs<ExtArgs>
    trips?: boolean | Route$tripsArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RouteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Route"
    objects: {
      features: Prisma.$RouteFeaturesPayload<ExtArgs> | null
      requests: Prisma.$RideRequestPayload<ExtArgs>[]
      drivers: Prisma.$RouteDriverPayload<ExtArgs>[]
      stops: Prisma.$RouteStopPayload<ExtArgs>[]
      trips: Prisma.$TripPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      routeType: $Enums.RouteType
      frequency: $Enums.RouteFrequency
      daysOfWeek: number[]
      startDate: Date
      endDate: Date | null
      isRecurring: boolean
      baseFare: number
      pricingType: $Enums.PricingType
      perKmRate: number | null
      roundTripDiscount: number | null
      totalSeats: number
      availableSeats: number
      farePerSeat: number
      status: $Enums.RouteStatus
      isActive: boolean
      isListedPublicly: boolean
      allowDriverBidding: boolean
      autoApproveRequests: boolean
      minOccupancyRatio: number
      maxOccupancyRatio: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["route"]>
    composites: {}
  }

  type RouteGetPayload<S extends boolean | null | undefined | RouteDefaultArgs> = $Result.GetResult<Prisma.$RoutePayload, S>

  type RouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteCountAggregateInputType | true
    }

  export interface RouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Route'], meta: { name: 'Route' } }
    /**
     * Find zero or one Route that matches the filter.
     * @param {RouteFindUniqueArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteFindUniqueArgs>(args: SelectSubset<T, RouteFindUniqueArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Route that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteFindUniqueOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteFindFirstArgs>(args?: SelectSubset<T, RouteFindFirstArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Routes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routes
     * const routes = await prisma.route.findMany()
     * 
     * // Get first 10 Routes
     * const routes = await prisma.route.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeWithIdOnly = await prisma.route.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteFindManyArgs>(args?: SelectSubset<T, RouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Route.
     * @param {RouteCreateArgs} args - Arguments to create a Route.
     * @example
     * // Create one Route
     * const Route = await prisma.route.create({
     *   data: {
     *     // ... data to create a Route
     *   }
     * })
     * 
     */
    create<T extends RouteCreateArgs>(args: SelectSubset<T, RouteCreateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Routes.
     * @param {RouteCreateManyArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteCreateManyArgs>(args?: SelectSubset<T, RouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Routes and returns the data saved in the database.
     * @param {RouteCreateManyAndReturnArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Routes and only return the `id`
     * const routeWithIdOnly = await prisma.route.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Route.
     * @param {RouteDeleteArgs} args - Arguments to delete one Route.
     * @example
     * // Delete one Route
     * const Route = await prisma.route.delete({
     *   where: {
     *     // ... filter to delete one Route
     *   }
     * })
     * 
     */
    delete<T extends RouteDeleteArgs>(args: SelectSubset<T, RouteDeleteArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Route.
     * @param {RouteUpdateArgs} args - Arguments to update one Route.
     * @example
     * // Update one Route
     * const route = await prisma.route.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteUpdateArgs>(args: SelectSubset<T, RouteUpdateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Routes.
     * @param {RouteDeleteManyArgs} args - Arguments to filter Routes to delete.
     * @example
     * // Delete a few Routes
     * const { count } = await prisma.route.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteDeleteManyArgs>(args?: SelectSubset<T, RouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteUpdateManyArgs>(args: SelectSubset<T, RouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes and returns the data updated in the database.
     * @param {RouteUpdateManyAndReturnArgs} args - Arguments to update many Routes.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Routes and only return the `id`
     * const routeWithIdOnly = await prisma.route.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Route.
     * @param {RouteUpsertArgs} args - Arguments to update or create a Route.
     * @example
     * // Update or create a Route
     * const route = await prisma.route.upsert({
     *   create: {
     *     // ... data to create a Route
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Route we want to update
     *   }
     * })
     */
    upsert<T extends RouteUpsertArgs>(args: SelectSubset<T, RouteUpsertArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCountArgs} args - Arguments to filter Routes to count.
     * @example
     * // Count the number of Routes
     * const count = await prisma.route.count({
     *   where: {
     *     // ... the filter for the Routes we want to count
     *   }
     * })
    **/
    count<T extends RouteCountArgs>(
      args?: Subset<T, RouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteAggregateArgs>(args: Subset<T, RouteAggregateArgs>): Prisma.PrismaPromise<GetRouteAggregateType<T>>

    /**
     * Group by Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteGroupByArgs['orderBy'] }
        : { orderBy?: RouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Route model
   */
  readonly fields: RouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Route.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends Route$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Route$featuresArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requests<T extends Route$requestsArgs<ExtArgs> = {}>(args?: Subset<T, Route$requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    drivers<T extends Route$driversArgs<ExtArgs> = {}>(args?: Subset<T, Route$driversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stops<T extends Route$stopsArgs<ExtArgs> = {}>(args?: Subset<T, Route$stopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trips<T extends Route$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Route$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Route model
   */
  interface RouteFieldRefs {
    readonly id: FieldRef<"Route", 'String'>
    readonly name: FieldRef<"Route", 'String'>
    readonly description: FieldRef<"Route", 'String'>
    readonly routeType: FieldRef<"Route", 'RouteType'>
    readonly frequency: FieldRef<"Route", 'RouteFrequency'>
    readonly daysOfWeek: FieldRef<"Route", 'Int[]'>
    readonly startDate: FieldRef<"Route", 'DateTime'>
    readonly endDate: FieldRef<"Route", 'DateTime'>
    readonly isRecurring: FieldRef<"Route", 'Boolean'>
    readonly baseFare: FieldRef<"Route", 'Float'>
    readonly pricingType: FieldRef<"Route", 'PricingType'>
    readonly perKmRate: FieldRef<"Route", 'Float'>
    readonly roundTripDiscount: FieldRef<"Route", 'Float'>
    readonly totalSeats: FieldRef<"Route", 'Int'>
    readonly availableSeats: FieldRef<"Route", 'Int'>
    readonly farePerSeat: FieldRef<"Route", 'Float'>
    readonly status: FieldRef<"Route", 'RouteStatus'>
    readonly isActive: FieldRef<"Route", 'Boolean'>
    readonly isListedPublicly: FieldRef<"Route", 'Boolean'>
    readonly allowDriverBidding: FieldRef<"Route", 'Boolean'>
    readonly autoApproveRequests: FieldRef<"Route", 'Boolean'>
    readonly minOccupancyRatio: FieldRef<"Route", 'Float'>
    readonly maxOccupancyRatio: FieldRef<"Route", 'Float'>
    readonly createdAt: FieldRef<"Route", 'DateTime'>
    readonly updatedAt: FieldRef<"Route", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Route findUnique
   */
  export type RouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findUniqueOrThrow
   */
  export type RouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findFirst
   */
  export type RouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findFirstOrThrow
   */
  export type RouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findMany
   */
  export type RouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Routes to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route create
   */
  export type RouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to create a Route.
     */
    data: XOR<RouteCreateInput, RouteUncheckedCreateInput>
  }

  /**
   * Route createMany
   */
  export type RouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route createManyAndReturn
   */
  export type RouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route update
   */
  export type RouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to update a Route.
     */
    data: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
    /**
     * Choose, which Route to update.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route updateMany
   */
  export type RouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
  }

  /**
   * Route updateManyAndReturn
   */
  export type RouteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
  }

  /**
   * Route upsert
   */
  export type RouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The filter to search for the Route to update in case it exists.
     */
    where: RouteWhereUniqueInput
    /**
     * In case the Route found by the `where` argument doesn't exist, create a new Route with this data.
     */
    create: XOR<RouteCreateInput, RouteUncheckedCreateInput>
    /**
     * In case the Route was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
  }

  /**
   * Route delete
   */
  export type RouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter which Route to delete.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route deleteMany
   */
  export type RouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routes to delete
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to delete.
     */
    limit?: number
  }

  /**
   * Route.features
   */
  export type Route$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    where?: RouteFeaturesWhereInput
  }

  /**
   * Route.requests
   */
  export type Route$requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    where?: RideRequestWhereInput
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    cursor?: RideRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideRequestScalarFieldEnum | RideRequestScalarFieldEnum[]
  }

  /**
   * Route.drivers
   */
  export type Route$driversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    where?: RouteDriverWhereInput
    orderBy?: RouteDriverOrderByWithRelationInput | RouteDriverOrderByWithRelationInput[]
    cursor?: RouteDriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteDriverScalarFieldEnum | RouteDriverScalarFieldEnum[]
  }

  /**
   * Route.stops
   */
  export type Route$stopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    cursor?: RouteStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * Route.trips
   */
  export type Route$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Route without action
   */
  export type RouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
  }


  /**
   * Model RouteStop
   */

  export type AggregateRouteStop = {
    _count: RouteStopCountAggregateOutputType | null
    _avg: RouteStopAvgAggregateOutputType | null
    _sum: RouteStopSumAggregateOutputType | null
    _min: RouteStopMinAggregateOutputType | null
    _max: RouteStopMaxAggregateOutputType | null
  }

  export type RouteStopAvgAggregateOutputType = {
    sequence: number | null
  }

  export type RouteStopSumAggregateOutputType = {
    sequence: number | null
  }

  export type RouteStopMinAggregateOutputType = {
    id: string | null
    routeId: string | null
    locationId: string | null
    sequence: number | null
    arrivalTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteStopMaxAggregateOutputType = {
    id: string | null
    routeId: string | null
    locationId: string | null
    sequence: number | null
    arrivalTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteStopCountAggregateOutputType = {
    id: number
    routeId: number
    locationId: number
    sequence: number
    arrivalTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RouteStopAvgAggregateInputType = {
    sequence?: true
  }

  export type RouteStopSumAggregateInputType = {
    sequence?: true
  }

  export type RouteStopMinAggregateInputType = {
    id?: true
    routeId?: true
    locationId?: true
    sequence?: true
    arrivalTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteStopMaxAggregateInputType = {
    id?: true
    routeId?: true
    locationId?: true
    sequence?: true
    arrivalTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteStopCountAggregateInputType = {
    id?: true
    routeId?: true
    locationId?: true
    sequence?: true
    arrivalTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RouteStopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteStop to aggregate.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteStops
    **/
    _count?: true | RouteStopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteStopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteStopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteStopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteStopMaxAggregateInputType
  }

  export type GetRouteStopAggregateType<T extends RouteStopAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteStop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteStop[P]>
      : GetScalarType<T[P], AggregateRouteStop[P]>
  }




  export type RouteStopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithAggregationInput | RouteStopOrderByWithAggregationInput[]
    by: RouteStopScalarFieldEnum[] | RouteStopScalarFieldEnum
    having?: RouteStopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteStopCountAggregateInputType | true
    _avg?: RouteStopAvgAggregateInputType
    _sum?: RouteStopSumAggregateInputType
    _min?: RouteStopMinAggregateInputType
    _max?: RouteStopMaxAggregateInputType
  }

  export type RouteStopGroupByOutputType = {
    id: string
    routeId: string
    locationId: string
    sequence: number
    arrivalTime: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RouteStopCountAggregateOutputType | null
    _avg: RouteStopAvgAggregateOutputType | null
    _sum: RouteStopSumAggregateOutputType | null
    _min: RouteStopMinAggregateOutputType | null
    _max: RouteStopMaxAggregateOutputType | null
  }

  type GetRouteStopGroupByPayload<T extends RouteStopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteStopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteStopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteStopGroupByOutputType[P]>
            : GetScalarType<T[P], RouteStopGroupByOutputType[P]>
        }
      >
    >


  export type RouteStopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    locationId?: boolean
    sequence?: boolean
    arrivalTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropRides?: boolean | RouteStop$dropRidesArgs<ExtArgs>
    pickupRides?: boolean | RouteStop$pickupRidesArgs<ExtArgs>
    dropRequests?: boolean | RouteStop$dropRequestsArgs<ExtArgs>
    pickupRequests?: boolean | RouteStop$pickupRequestsArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    _count?: boolean | RouteStopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeStop"]>

  export type RouteStopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    locationId?: boolean
    sequence?: boolean
    arrivalTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeStop"]>

  export type RouteStopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    locationId?: boolean
    sequence?: boolean
    arrivalTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeStop"]>

  export type RouteStopSelectScalar = {
    id?: boolean
    routeId?: boolean
    locationId?: boolean
    sequence?: boolean
    arrivalTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RouteStopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "routeId" | "locationId" | "sequence" | "arrivalTime" | "createdAt" | "updatedAt", ExtArgs["result"]["routeStop"]>
  export type RouteStopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dropRides?: boolean | RouteStop$dropRidesArgs<ExtArgs>
    pickupRides?: boolean | RouteStop$pickupRidesArgs<ExtArgs>
    dropRequests?: boolean | RouteStop$dropRequestsArgs<ExtArgs>
    pickupRequests?: boolean | RouteStop$pickupRequestsArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    _count?: boolean | RouteStopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RouteStopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }
  export type RouteStopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }

  export type $RouteStopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteStop"
    objects: {
      dropRides: Prisma.$RidePayload<ExtArgs>[]
      pickupRides: Prisma.$RidePayload<ExtArgs>[]
      dropRequests: Prisma.$RideRequestPayload<ExtArgs>[]
      pickupRequests: Prisma.$RideRequestPayload<ExtArgs>[]
      location: Prisma.$LocationPayload<ExtArgs>
      route: Prisma.$RoutePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routeId: string
      locationId: string
      sequence: number
      arrivalTime: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routeStop"]>
    composites: {}
  }

  type RouteStopGetPayload<S extends boolean | null | undefined | RouteStopDefaultArgs> = $Result.GetResult<Prisma.$RouteStopPayload, S>

  type RouteStopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteStopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteStopCountAggregateInputType | true
    }

  export interface RouteStopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteStop'], meta: { name: 'RouteStop' } }
    /**
     * Find zero or one RouteStop that matches the filter.
     * @param {RouteStopFindUniqueArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteStopFindUniqueArgs>(args: SelectSubset<T, RouteStopFindUniqueArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RouteStop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteStopFindUniqueOrThrowArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteStopFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteStopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteStop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindFirstArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteStopFindFirstArgs>(args?: SelectSubset<T, RouteStopFindFirstArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteStop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindFirstOrThrowArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteStopFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteStopFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RouteStops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteStops
     * const routeStops = await prisma.routeStop.findMany()
     * 
     * // Get first 10 RouteStops
     * const routeStops = await prisma.routeStop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeStopWithIdOnly = await prisma.routeStop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteStopFindManyArgs>(args?: SelectSubset<T, RouteStopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RouteStop.
     * @param {RouteStopCreateArgs} args - Arguments to create a RouteStop.
     * @example
     * // Create one RouteStop
     * const RouteStop = await prisma.routeStop.create({
     *   data: {
     *     // ... data to create a RouteStop
     *   }
     * })
     * 
     */
    create<T extends RouteStopCreateArgs>(args: SelectSubset<T, RouteStopCreateArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RouteStops.
     * @param {RouteStopCreateManyArgs} args - Arguments to create many RouteStops.
     * @example
     * // Create many RouteStops
     * const routeStop = await prisma.routeStop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteStopCreateManyArgs>(args?: SelectSubset<T, RouteStopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteStops and returns the data saved in the database.
     * @param {RouteStopCreateManyAndReturnArgs} args - Arguments to create many RouteStops.
     * @example
     * // Create many RouteStops
     * const routeStop = await prisma.routeStop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteStops and only return the `id`
     * const routeStopWithIdOnly = await prisma.routeStop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteStopCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteStopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RouteStop.
     * @param {RouteStopDeleteArgs} args - Arguments to delete one RouteStop.
     * @example
     * // Delete one RouteStop
     * const RouteStop = await prisma.routeStop.delete({
     *   where: {
     *     // ... filter to delete one RouteStop
     *   }
     * })
     * 
     */
    delete<T extends RouteStopDeleteArgs>(args: SelectSubset<T, RouteStopDeleteArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RouteStop.
     * @param {RouteStopUpdateArgs} args - Arguments to update one RouteStop.
     * @example
     * // Update one RouteStop
     * const routeStop = await prisma.routeStop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteStopUpdateArgs>(args: SelectSubset<T, RouteStopUpdateArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RouteStops.
     * @param {RouteStopDeleteManyArgs} args - Arguments to filter RouteStops to delete.
     * @example
     * // Delete a few RouteStops
     * const { count } = await prisma.routeStop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteStopDeleteManyArgs>(args?: SelectSubset<T, RouteStopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteStops
     * const routeStop = await prisma.routeStop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteStopUpdateManyArgs>(args: SelectSubset<T, RouteStopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteStops and returns the data updated in the database.
     * @param {RouteStopUpdateManyAndReturnArgs} args - Arguments to update many RouteStops.
     * @example
     * // Update many RouteStops
     * const routeStop = await prisma.routeStop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RouteStops and only return the `id`
     * const routeStopWithIdOnly = await prisma.routeStop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteStopUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteStopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RouteStop.
     * @param {RouteStopUpsertArgs} args - Arguments to update or create a RouteStop.
     * @example
     * // Update or create a RouteStop
     * const routeStop = await prisma.routeStop.upsert({
     *   create: {
     *     // ... data to create a RouteStop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteStop we want to update
     *   }
     * })
     */
    upsert<T extends RouteStopUpsertArgs>(args: SelectSubset<T, RouteStopUpsertArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RouteStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopCountArgs} args - Arguments to filter RouteStops to count.
     * @example
     * // Count the number of RouteStops
     * const count = await prisma.routeStop.count({
     *   where: {
     *     // ... the filter for the RouteStops we want to count
     *   }
     * })
    **/
    count<T extends RouteStopCountArgs>(
      args?: Subset<T, RouteStopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteStopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteStopAggregateArgs>(args: Subset<T, RouteStopAggregateArgs>): Prisma.PrismaPromise<GetRouteStopAggregateType<T>>

    /**
     * Group by RouteStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteStopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteStopGroupByArgs['orderBy'] }
        : { orderBy?: RouteStopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteStopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteStopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteStop model
   */
  readonly fields: RouteStopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteStop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteStopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dropRides<T extends RouteStop$dropRidesArgs<ExtArgs> = {}>(args?: Subset<T, RouteStop$dropRidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pickupRides<T extends RouteStop$pickupRidesArgs<ExtArgs> = {}>(args?: Subset<T, RouteStop$pickupRidesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dropRequests<T extends RouteStop$dropRequestsArgs<ExtArgs> = {}>(args?: Subset<T, RouteStop$dropRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pickupRequests<T extends RouteStop$pickupRequestsArgs<ExtArgs> = {}>(args?: Subset<T, RouteStop$pickupRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteStop model
   */
  interface RouteStopFieldRefs {
    readonly id: FieldRef<"RouteStop", 'String'>
    readonly routeId: FieldRef<"RouteStop", 'String'>
    readonly locationId: FieldRef<"RouteStop", 'String'>
    readonly sequence: FieldRef<"RouteStop", 'Int'>
    readonly arrivalTime: FieldRef<"RouteStop", 'DateTime'>
    readonly createdAt: FieldRef<"RouteStop", 'DateTime'>
    readonly updatedAt: FieldRef<"RouteStop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteStop findUnique
   */
  export type RouteStopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop findUniqueOrThrow
   */
  export type RouteStopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop findFirst
   */
  export type RouteStopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteStops.
     */
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop findFirstOrThrow
   */
  export type RouteStopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteStops.
     */
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop findMany
   */
  export type RouteStopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStops to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop create
   */
  export type RouteStopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteStop.
     */
    data: XOR<RouteStopCreateInput, RouteStopUncheckedCreateInput>
  }

  /**
   * RouteStop createMany
   */
  export type RouteStopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteStops.
     */
    data: RouteStopCreateManyInput | RouteStopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteStop createManyAndReturn
   */
  export type RouteStopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * The data used to create many RouteStops.
     */
    data: RouteStopCreateManyInput | RouteStopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteStop update
   */
  export type RouteStopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteStop.
     */
    data: XOR<RouteStopUpdateInput, RouteStopUncheckedUpdateInput>
    /**
     * Choose, which RouteStop to update.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop updateMany
   */
  export type RouteStopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteStops.
     */
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyInput>
    /**
     * Filter which RouteStops to update
     */
    where?: RouteStopWhereInput
    /**
     * Limit how many RouteStops to update.
     */
    limit?: number
  }

  /**
   * RouteStop updateManyAndReturn
   */
  export type RouteStopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * The data used to update RouteStops.
     */
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyInput>
    /**
     * Filter which RouteStops to update
     */
    where?: RouteStopWhereInput
    /**
     * Limit how many RouteStops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteStop upsert
   */
  export type RouteStopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteStop to update in case it exists.
     */
    where: RouteStopWhereUniqueInput
    /**
     * In case the RouteStop found by the `where` argument doesn't exist, create a new RouteStop with this data.
     */
    create: XOR<RouteStopCreateInput, RouteStopUncheckedCreateInput>
    /**
     * In case the RouteStop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteStopUpdateInput, RouteStopUncheckedUpdateInput>
  }

  /**
   * RouteStop delete
   */
  export type RouteStopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter which RouteStop to delete.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop deleteMany
   */
  export type RouteStopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteStops to delete
     */
    where?: RouteStopWhereInput
    /**
     * Limit how many RouteStops to delete.
     */
    limit?: number
  }

  /**
   * RouteStop.dropRides
   */
  export type RouteStop$dropRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    cursor?: RideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * RouteStop.pickupRides
   */
  export type RouteStop$pickupRidesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    cursor?: RideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * RouteStop.dropRequests
   */
  export type RouteStop$dropRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    where?: RideRequestWhereInput
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    cursor?: RideRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideRequestScalarFieldEnum | RideRequestScalarFieldEnum[]
  }

  /**
   * RouteStop.pickupRequests
   */
  export type RouteStop$pickupRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    where?: RideRequestWhereInput
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    cursor?: RideRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideRequestScalarFieldEnum | RideRequestScalarFieldEnum[]
  }

  /**
   * RouteStop without action
   */
  export type RouteStopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteStop
     */
    omit?: RouteStopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
  }


  /**
   * Model RouteDriver
   */

  export type AggregateRouteDriver = {
    _count: RouteDriverCountAggregateOutputType | null
    _min: RouteDriverMinAggregateOutputType | null
    _max: RouteDriverMaxAggregateOutputType | null
  }

  export type RouteDriverMinAggregateOutputType = {
    id: string | null
    routeId: string | null
    driverId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteDriverMaxAggregateOutputType = {
    id: string | null
    routeId: string | null
    driverId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteDriverCountAggregateOutputType = {
    id: number
    routeId: number
    driverId: number
    startDate: number
    endDate: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RouteDriverMinAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteDriverMaxAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteDriverCountAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RouteDriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteDriver to aggregate.
     */
    where?: RouteDriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteDrivers to fetch.
     */
    orderBy?: RouteDriverOrderByWithRelationInput | RouteDriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteDriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteDrivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteDrivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteDrivers
    **/
    _count?: true | RouteDriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteDriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteDriverMaxAggregateInputType
  }

  export type GetRouteDriverAggregateType<T extends RouteDriverAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteDriver[P]>
      : GetScalarType<T[P], AggregateRouteDriver[P]>
  }




  export type RouteDriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteDriverWhereInput
    orderBy?: RouteDriverOrderByWithAggregationInput | RouteDriverOrderByWithAggregationInput[]
    by: RouteDriverScalarFieldEnum[] | RouteDriverScalarFieldEnum
    having?: RouteDriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteDriverCountAggregateInputType | true
    _min?: RouteDriverMinAggregateInputType
    _max?: RouteDriverMaxAggregateInputType
  }

  export type RouteDriverGroupByOutputType = {
    id: string
    routeId: string
    driverId: string
    startDate: Date
    endDate: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RouteDriverCountAggregateOutputType | null
    _min: RouteDriverMinAggregateOutputType | null
    _max: RouteDriverMaxAggregateOutputType | null
  }

  type GetRouteDriverGroupByPayload<T extends RouteDriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteDriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteDriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteDriverGroupByOutputType[P]>
            : GetScalarType<T[P], RouteDriverGroupByOutputType[P]>
        }
      >
    >


  export type RouteDriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeDriver"]>

  export type RouteDriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeDriver"]>

  export type RouteDriverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeDriver"]>

  export type RouteDriverSelectScalar = {
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RouteDriverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "routeId" | "driverId" | "startDate" | "endDate" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["routeDriver"]>
  export type RouteDriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }
  export type RouteDriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }
  export type RouteDriverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }

  export type $RouteDriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteDriver"
    objects: {
      driver: Prisma.$DriverPayload<ExtArgs>
      route: Prisma.$RoutePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routeId: string
      driverId: string
      startDate: Date
      endDate: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routeDriver"]>
    composites: {}
  }

  type RouteDriverGetPayload<S extends boolean | null | undefined | RouteDriverDefaultArgs> = $Result.GetResult<Prisma.$RouteDriverPayload, S>

  type RouteDriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteDriverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteDriverCountAggregateInputType | true
    }

  export interface RouteDriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteDriver'], meta: { name: 'RouteDriver' } }
    /**
     * Find zero or one RouteDriver that matches the filter.
     * @param {RouteDriverFindUniqueArgs} args - Arguments to find a RouteDriver
     * @example
     * // Get one RouteDriver
     * const routeDriver = await prisma.routeDriver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteDriverFindUniqueArgs>(args: SelectSubset<T, RouteDriverFindUniqueArgs<ExtArgs>>): Prisma__RouteDriverClient<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RouteDriver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteDriverFindUniqueOrThrowArgs} args - Arguments to find a RouteDriver
     * @example
     * // Get one RouteDriver
     * const routeDriver = await prisma.routeDriver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteDriverFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteDriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteDriverClient<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteDriver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteDriverFindFirstArgs} args - Arguments to find a RouteDriver
     * @example
     * // Get one RouteDriver
     * const routeDriver = await prisma.routeDriver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteDriverFindFirstArgs>(args?: SelectSubset<T, RouteDriverFindFirstArgs<ExtArgs>>): Prisma__RouteDriverClient<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteDriver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteDriverFindFirstOrThrowArgs} args - Arguments to find a RouteDriver
     * @example
     * // Get one RouteDriver
     * const routeDriver = await prisma.routeDriver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteDriverFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteDriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteDriverClient<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RouteDrivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteDriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteDrivers
     * const routeDrivers = await prisma.routeDriver.findMany()
     * 
     * // Get first 10 RouteDrivers
     * const routeDrivers = await prisma.routeDriver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeDriverWithIdOnly = await prisma.routeDriver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteDriverFindManyArgs>(args?: SelectSubset<T, RouteDriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RouteDriver.
     * @param {RouteDriverCreateArgs} args - Arguments to create a RouteDriver.
     * @example
     * // Create one RouteDriver
     * const RouteDriver = await prisma.routeDriver.create({
     *   data: {
     *     // ... data to create a RouteDriver
     *   }
     * })
     * 
     */
    create<T extends RouteDriverCreateArgs>(args: SelectSubset<T, RouteDriverCreateArgs<ExtArgs>>): Prisma__RouteDriverClient<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RouteDrivers.
     * @param {RouteDriverCreateManyArgs} args - Arguments to create many RouteDrivers.
     * @example
     * // Create many RouteDrivers
     * const routeDriver = await prisma.routeDriver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteDriverCreateManyArgs>(args?: SelectSubset<T, RouteDriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteDrivers and returns the data saved in the database.
     * @param {RouteDriverCreateManyAndReturnArgs} args - Arguments to create many RouteDrivers.
     * @example
     * // Create many RouteDrivers
     * const routeDriver = await prisma.routeDriver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteDrivers and only return the `id`
     * const routeDriverWithIdOnly = await prisma.routeDriver.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteDriverCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteDriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RouteDriver.
     * @param {RouteDriverDeleteArgs} args - Arguments to delete one RouteDriver.
     * @example
     * // Delete one RouteDriver
     * const RouteDriver = await prisma.routeDriver.delete({
     *   where: {
     *     // ... filter to delete one RouteDriver
     *   }
     * })
     * 
     */
    delete<T extends RouteDriverDeleteArgs>(args: SelectSubset<T, RouteDriverDeleteArgs<ExtArgs>>): Prisma__RouteDriverClient<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RouteDriver.
     * @param {RouteDriverUpdateArgs} args - Arguments to update one RouteDriver.
     * @example
     * // Update one RouteDriver
     * const routeDriver = await prisma.routeDriver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteDriverUpdateArgs>(args: SelectSubset<T, RouteDriverUpdateArgs<ExtArgs>>): Prisma__RouteDriverClient<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RouteDrivers.
     * @param {RouteDriverDeleteManyArgs} args - Arguments to filter RouteDrivers to delete.
     * @example
     * // Delete a few RouteDrivers
     * const { count } = await prisma.routeDriver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteDriverDeleteManyArgs>(args?: SelectSubset<T, RouteDriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteDrivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteDriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteDrivers
     * const routeDriver = await prisma.routeDriver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteDriverUpdateManyArgs>(args: SelectSubset<T, RouteDriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteDrivers and returns the data updated in the database.
     * @param {RouteDriverUpdateManyAndReturnArgs} args - Arguments to update many RouteDrivers.
     * @example
     * // Update many RouteDrivers
     * const routeDriver = await prisma.routeDriver.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RouteDrivers and only return the `id`
     * const routeDriverWithIdOnly = await prisma.routeDriver.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteDriverUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteDriverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RouteDriver.
     * @param {RouteDriverUpsertArgs} args - Arguments to update or create a RouteDriver.
     * @example
     * // Update or create a RouteDriver
     * const routeDriver = await prisma.routeDriver.upsert({
     *   create: {
     *     // ... data to create a RouteDriver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteDriver we want to update
     *   }
     * })
     */
    upsert<T extends RouteDriverUpsertArgs>(args: SelectSubset<T, RouteDriverUpsertArgs<ExtArgs>>): Prisma__RouteDriverClient<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RouteDrivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteDriverCountArgs} args - Arguments to filter RouteDrivers to count.
     * @example
     * // Count the number of RouteDrivers
     * const count = await prisma.routeDriver.count({
     *   where: {
     *     // ... the filter for the RouteDrivers we want to count
     *   }
     * })
    **/
    count<T extends RouteDriverCountArgs>(
      args?: Subset<T, RouteDriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteDriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteDriver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteDriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteDriverAggregateArgs>(args: Subset<T, RouteDriverAggregateArgs>): Prisma.PrismaPromise<GetRouteDriverAggregateType<T>>

    /**
     * Group by RouteDriver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteDriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteDriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteDriverGroupByArgs['orderBy'] }
        : { orderBy?: RouteDriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteDriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteDriver model
   */
  readonly fields: RouteDriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteDriver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteDriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteDriver model
   */
  interface RouteDriverFieldRefs {
    readonly id: FieldRef<"RouteDriver", 'String'>
    readonly routeId: FieldRef<"RouteDriver", 'String'>
    readonly driverId: FieldRef<"RouteDriver", 'String'>
    readonly startDate: FieldRef<"RouteDriver", 'DateTime'>
    readonly endDate: FieldRef<"RouteDriver", 'DateTime'>
    readonly isActive: FieldRef<"RouteDriver", 'Boolean'>
    readonly createdAt: FieldRef<"RouteDriver", 'DateTime'>
    readonly updatedAt: FieldRef<"RouteDriver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteDriver findUnique
   */
  export type RouteDriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * Filter, which RouteDriver to fetch.
     */
    where: RouteDriverWhereUniqueInput
  }

  /**
   * RouteDriver findUniqueOrThrow
   */
  export type RouteDriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * Filter, which RouteDriver to fetch.
     */
    where: RouteDriverWhereUniqueInput
  }

  /**
   * RouteDriver findFirst
   */
  export type RouteDriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * Filter, which RouteDriver to fetch.
     */
    where?: RouteDriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteDrivers to fetch.
     */
    orderBy?: RouteDriverOrderByWithRelationInput | RouteDriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteDrivers.
     */
    cursor?: RouteDriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteDrivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteDrivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteDrivers.
     */
    distinct?: RouteDriverScalarFieldEnum | RouteDriverScalarFieldEnum[]
  }

  /**
   * RouteDriver findFirstOrThrow
   */
  export type RouteDriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * Filter, which RouteDriver to fetch.
     */
    where?: RouteDriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteDrivers to fetch.
     */
    orderBy?: RouteDriverOrderByWithRelationInput | RouteDriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteDrivers.
     */
    cursor?: RouteDriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteDrivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteDrivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteDrivers.
     */
    distinct?: RouteDriverScalarFieldEnum | RouteDriverScalarFieldEnum[]
  }

  /**
   * RouteDriver findMany
   */
  export type RouteDriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * Filter, which RouteDrivers to fetch.
     */
    where?: RouteDriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteDrivers to fetch.
     */
    orderBy?: RouteDriverOrderByWithRelationInput | RouteDriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteDrivers.
     */
    cursor?: RouteDriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteDrivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteDrivers.
     */
    skip?: number
    distinct?: RouteDriverScalarFieldEnum | RouteDriverScalarFieldEnum[]
  }

  /**
   * RouteDriver create
   */
  export type RouteDriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteDriver.
     */
    data: XOR<RouteDriverCreateInput, RouteDriverUncheckedCreateInput>
  }

  /**
   * RouteDriver createMany
   */
  export type RouteDriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteDrivers.
     */
    data: RouteDriverCreateManyInput | RouteDriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteDriver createManyAndReturn
   */
  export type RouteDriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * The data used to create many RouteDrivers.
     */
    data: RouteDriverCreateManyInput | RouteDriverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteDriver update
   */
  export type RouteDriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteDriver.
     */
    data: XOR<RouteDriverUpdateInput, RouteDriverUncheckedUpdateInput>
    /**
     * Choose, which RouteDriver to update.
     */
    where: RouteDriverWhereUniqueInput
  }

  /**
   * RouteDriver updateMany
   */
  export type RouteDriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteDrivers.
     */
    data: XOR<RouteDriverUpdateManyMutationInput, RouteDriverUncheckedUpdateManyInput>
    /**
     * Filter which RouteDrivers to update
     */
    where?: RouteDriverWhereInput
    /**
     * Limit how many RouteDrivers to update.
     */
    limit?: number
  }

  /**
   * RouteDriver updateManyAndReturn
   */
  export type RouteDriverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * The data used to update RouteDrivers.
     */
    data: XOR<RouteDriverUpdateManyMutationInput, RouteDriverUncheckedUpdateManyInput>
    /**
     * Filter which RouteDrivers to update
     */
    where?: RouteDriverWhereInput
    /**
     * Limit how many RouteDrivers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteDriver upsert
   */
  export type RouteDriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteDriver to update in case it exists.
     */
    where: RouteDriverWhereUniqueInput
    /**
     * In case the RouteDriver found by the `where` argument doesn't exist, create a new RouteDriver with this data.
     */
    create: XOR<RouteDriverCreateInput, RouteDriverUncheckedCreateInput>
    /**
     * In case the RouteDriver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteDriverUpdateInput, RouteDriverUncheckedUpdateInput>
  }

  /**
   * RouteDriver delete
   */
  export type RouteDriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    /**
     * Filter which RouteDriver to delete.
     */
    where: RouteDriverWhereUniqueInput
  }

  /**
   * RouteDriver deleteMany
   */
  export type RouteDriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteDrivers to delete
     */
    where?: RouteDriverWhereInput
    /**
     * Limit how many RouteDrivers to delete.
     */
    limit?: number
  }

  /**
   * RouteDriver without action
   */
  export type RouteDriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
  }


  /**
   * Model Trip
   */

  export type AggregateTrip = {
    _count: TripCountAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  export type TripMinAggregateOutputType = {
    id: string | null
    routeId: string | null
    driverId: string | null
    date: Date | null
    status: $Enums.TripStatus | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripMaxAggregateOutputType = {
    id: string | null
    routeId: string | null
    driverId: string | null
    date: Date | null
    status: $Enums.TripStatus | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripCountAggregateOutputType = {
    id: number
    routeId: number
    driverId: number
    date: number
    status: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TripMinAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    date?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripMaxAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    date?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripCountAggregateInputType = {
    id?: true
    routeId?: true
    driverId?: true
    date?: true
    status?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trip to aggregate.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trips
    **/
    _count?: true | TripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripMaxAggregateInputType
  }

  export type GetTripAggregateType<T extends TripAggregateArgs> = {
        [P in keyof T & keyof AggregateTrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrip[P]>
      : GetScalarType<T[P], AggregateTrip[P]>
  }




  export type TripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripWhereInput
    orderBy?: TripOrderByWithAggregationInput | TripOrderByWithAggregationInput[]
    by: TripScalarFieldEnum[] | TripScalarFieldEnum
    having?: TripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripCountAggregateInputType | true
    _min?: TripMinAggregateInputType
    _max?: TripMaxAggregateInputType
  }

  export type TripGroupByOutputType = {
    id: string
    routeId: string
    driverId: string
    date: Date
    status: $Enums.TripStatus
    startTime: Date | null
    endTime: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TripCountAggregateOutputType | null
    _min: TripMinAggregateOutputType | null
    _max: TripMaxAggregateOutputType | null
  }

  type GetTripGroupByPayload<T extends TripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripGroupByOutputType[P]>
            : GetScalarType<T[P], TripGroupByOutputType[P]>
        }
      >
    >


  export type TripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    date?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rides?: boolean | Trip$ridesArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    date?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    date?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trip"]>

  export type TripSelectScalar = {
    id?: boolean
    routeId?: boolean
    driverId?: boolean
    date?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TripOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "routeId" | "driverId" | "date" | "status" | "startTime" | "endTime" | "createdAt" | "updatedAt", ExtArgs["result"]["trip"]>
  export type TripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rides?: boolean | Trip$ridesArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    _count?: boolean | TripCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }
  export type TripIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }

  export type $TripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trip"
    objects: {
      rides: Prisma.$RidePayload<ExtArgs>[]
      driver: Prisma.$DriverPayload<ExtArgs>
      route: Prisma.$RoutePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routeId: string
      driverId: string
      date: Date
      status: $Enums.TripStatus
      startTime: Date | null
      endTime: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trip"]>
    composites: {}
  }

  type TripGetPayload<S extends boolean | null | undefined | TripDefaultArgs> = $Result.GetResult<Prisma.$TripPayload, S>

  type TripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripCountAggregateInputType | true
    }

  export interface TripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trip'], meta: { name: 'Trip' } }
    /**
     * Find zero or one Trip that matches the filter.
     * @param {TripFindUniqueArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripFindUniqueArgs>(args: SelectSubset<T, TripFindUniqueArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripFindUniqueOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripFindUniqueOrThrowArgs>(args: SelectSubset<T, TripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripFindFirstArgs>(args?: SelectSubset<T, TripFindFirstArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindFirstOrThrowArgs} args - Arguments to find a Trip
     * @example
     * // Get one Trip
     * const trip = await prisma.trip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripFindFirstOrThrowArgs>(args?: SelectSubset<T, TripFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trips
     * const trips = await prisma.trip.findMany()
     * 
     * // Get first 10 Trips
     * const trips = await prisma.trip.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripWithIdOnly = await prisma.trip.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripFindManyArgs>(args?: SelectSubset<T, TripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trip.
     * @param {TripCreateArgs} args - Arguments to create a Trip.
     * @example
     * // Create one Trip
     * const Trip = await prisma.trip.create({
     *   data: {
     *     // ... data to create a Trip
     *   }
     * })
     * 
     */
    create<T extends TripCreateArgs>(args: SelectSubset<T, TripCreateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trips.
     * @param {TripCreateManyArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripCreateManyArgs>(args?: SelectSubset<T, TripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trips and returns the data saved in the database.
     * @param {TripCreateManyAndReturnArgs} args - Arguments to create many Trips.
     * @example
     * // Create many Trips
     * const trip = await prisma.trip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripCreateManyAndReturnArgs>(args?: SelectSubset<T, TripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trip.
     * @param {TripDeleteArgs} args - Arguments to delete one Trip.
     * @example
     * // Delete one Trip
     * const Trip = await prisma.trip.delete({
     *   where: {
     *     // ... filter to delete one Trip
     *   }
     * })
     * 
     */
    delete<T extends TripDeleteArgs>(args: SelectSubset<T, TripDeleteArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trip.
     * @param {TripUpdateArgs} args - Arguments to update one Trip.
     * @example
     * // Update one Trip
     * const trip = await prisma.trip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripUpdateArgs>(args: SelectSubset<T, TripUpdateArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trips.
     * @param {TripDeleteManyArgs} args - Arguments to filter Trips to delete.
     * @example
     * // Delete a few Trips
     * const { count } = await prisma.trip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripDeleteManyArgs>(args?: SelectSubset<T, TripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripUpdateManyArgs>(args: SelectSubset<T, TripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trips and returns the data updated in the database.
     * @param {TripUpdateManyAndReturnArgs} args - Arguments to update many Trips.
     * @example
     * // Update many Trips
     * const trip = await prisma.trip.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trips and only return the `id`
     * const tripWithIdOnly = await prisma.trip.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripUpdateManyAndReturnArgs>(args: SelectSubset<T, TripUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trip.
     * @param {TripUpsertArgs} args - Arguments to update or create a Trip.
     * @example
     * // Update or create a Trip
     * const trip = await prisma.trip.upsert({
     *   create: {
     *     // ... data to create a Trip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trip we want to update
     *   }
     * })
     */
    upsert<T extends TripUpsertArgs>(args: SelectSubset<T, TripUpsertArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripCountArgs} args - Arguments to filter Trips to count.
     * @example
     * // Count the number of Trips
     * const count = await prisma.trip.count({
     *   where: {
     *     // ... the filter for the Trips we want to count
     *   }
     * })
    **/
    count<T extends TripCountArgs>(
      args?: Subset<T, TripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripAggregateArgs>(args: Subset<T, TripAggregateArgs>): Prisma.PrismaPromise<GetTripAggregateType<T>>

    /**
     * Group by Trip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripGroupByArgs['orderBy'] }
        : { orderBy?: TripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trip model
   */
  readonly fields: TripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rides<T extends Trip$ridesArgs<ExtArgs> = {}>(args?: Subset<T, Trip$ridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trip model
   */
  interface TripFieldRefs {
    readonly id: FieldRef<"Trip", 'String'>
    readonly routeId: FieldRef<"Trip", 'String'>
    readonly driverId: FieldRef<"Trip", 'String'>
    readonly date: FieldRef<"Trip", 'DateTime'>
    readonly status: FieldRef<"Trip", 'TripStatus'>
    readonly startTime: FieldRef<"Trip", 'DateTime'>
    readonly endTime: FieldRef<"Trip", 'DateTime'>
    readonly createdAt: FieldRef<"Trip", 'DateTime'>
    readonly updatedAt: FieldRef<"Trip", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Trip findUnique
   */
  export type TripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findUniqueOrThrow
   */
  export type TripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip findFirst
   */
  export type TripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findFirstOrThrow
   */
  export type TripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trip to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trips.
     */
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip findMany
   */
  export type TripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter, which Trips to fetch.
     */
    where?: TripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trips to fetch.
     */
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trips.
     */
    cursor?: TripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trips.
     */
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Trip create
   */
  export type TripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to create a Trip.
     */
    data: XOR<TripCreateInput, TripUncheckedCreateInput>
  }

  /**
   * Trip createMany
   */
  export type TripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trip createManyAndReturn
   */
  export type TripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * The data used to create many Trips.
     */
    data: TripCreateManyInput | TripCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip update
   */
  export type TripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The data needed to update a Trip.
     */
    data: XOR<TripUpdateInput, TripUncheckedUpdateInput>
    /**
     * Choose, which Trip to update.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip updateMany
   */
  export type TripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to update.
     */
    limit?: number
  }

  /**
   * Trip updateManyAndReturn
   */
  export type TripUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * The data used to update Trips.
     */
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyInput>
    /**
     * Filter which Trips to update
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Trip upsert
   */
  export type TripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * The filter to search for the Trip to update in case it exists.
     */
    where: TripWhereUniqueInput
    /**
     * In case the Trip found by the `where` argument doesn't exist, create a new Trip with this data.
     */
    create: XOR<TripCreateInput, TripUncheckedCreateInput>
    /**
     * In case the Trip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripUpdateInput, TripUncheckedUpdateInput>
  }

  /**
   * Trip delete
   */
  export type TripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    /**
     * Filter which Trip to delete.
     */
    where: TripWhereUniqueInput
  }

  /**
   * Trip deleteMany
   */
  export type TripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trips to delete
     */
    where?: TripWhereInput
    /**
     * Limit how many Trips to delete.
     */
    limit?: number
  }

  /**
   * Trip.rides
   */
  export type Trip$ridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    cursor?: RideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Trip without action
   */
  export type TripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
  }


  /**
   * Model Ride
   */

  export type AggregateRide = {
    _count: RideCountAggregateOutputType | null
    _min: RideMinAggregateOutputType | null
    _max: RideMaxAggregateOutputType | null
  }

  export type RideMinAggregateOutputType = {
    id: string | null
    tripId: string | null
    teenId: string | null
    pickupStopId: string | null
    dropStopId: string | null
    status: $Enums.RideStatus | null
    scheduledPickupTime: Date | null
    actualPickupTime: Date | null
    scheduledDropTime: Date | null
    actualDropTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RideMaxAggregateOutputType = {
    id: string | null
    tripId: string | null
    teenId: string | null
    pickupStopId: string | null
    dropStopId: string | null
    status: $Enums.RideStatus | null
    scheduledPickupTime: Date | null
    actualPickupTime: Date | null
    scheduledDropTime: Date | null
    actualDropTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RideCountAggregateOutputType = {
    id: number
    tripId: number
    teenId: number
    pickupStopId: number
    dropStopId: number
    status: number
    scheduledPickupTime: number
    actualPickupTime: number
    scheduledDropTime: number
    actualDropTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RideMinAggregateInputType = {
    id?: true
    tripId?: true
    teenId?: true
    pickupStopId?: true
    dropStopId?: true
    status?: true
    scheduledPickupTime?: true
    actualPickupTime?: true
    scheduledDropTime?: true
    actualDropTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RideMaxAggregateInputType = {
    id?: true
    tripId?: true
    teenId?: true
    pickupStopId?: true
    dropStopId?: true
    status?: true
    scheduledPickupTime?: true
    actualPickupTime?: true
    scheduledDropTime?: true
    actualDropTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RideCountAggregateInputType = {
    id?: true
    tripId?: true
    teenId?: true
    pickupStopId?: true
    dropStopId?: true
    status?: true
    scheduledPickupTime?: true
    actualPickupTime?: true
    scheduledDropTime?: true
    actualDropTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ride to aggregate.
     */
    where?: RideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rides to fetch.
     */
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rides
    **/
    _count?: true | RideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RideMaxAggregateInputType
  }

  export type GetRideAggregateType<T extends RideAggregateArgs> = {
        [P in keyof T & keyof AggregateRide]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRide[P]>
      : GetScalarType<T[P], AggregateRide[P]>
  }




  export type RideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideWhereInput
    orderBy?: RideOrderByWithAggregationInput | RideOrderByWithAggregationInput[]
    by: RideScalarFieldEnum[] | RideScalarFieldEnum
    having?: RideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RideCountAggregateInputType | true
    _min?: RideMinAggregateInputType
    _max?: RideMaxAggregateInputType
  }

  export type RideGroupByOutputType = {
    id: string
    tripId: string
    teenId: string
    pickupStopId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date
    actualPickupTime: Date | null
    scheduledDropTime: Date
    actualDropTime: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RideCountAggregateOutputType | null
    _min: RideMinAggregateOutputType | null
    _max: RideMaxAggregateOutputType | null
  }

  type GetRideGroupByPayload<T extends RideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RideGroupByOutputType[P]>
            : GetScalarType<T[P], RideGroupByOutputType[P]>
        }
      >
    >


  export type RideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    teenId?: boolean
    pickupStopId?: boolean
    dropStopId?: boolean
    status?: boolean
    scheduledPickupTime?: boolean
    actualPickupTime?: boolean
    scheduledDropTime?: boolean
    actualDropTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
    transactions?: boolean | Ride$transactionsArgs<ExtArgs>
    _count?: boolean | RideCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ride"]>

  export type RideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    teenId?: boolean
    pickupStopId?: boolean
    dropStopId?: boolean
    status?: boolean
    scheduledPickupTime?: boolean
    actualPickupTime?: boolean
    scheduledDropTime?: boolean
    actualDropTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ride"]>

  export type RideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripId?: boolean
    teenId?: boolean
    pickupStopId?: boolean
    dropStopId?: boolean
    status?: boolean
    scheduledPickupTime?: boolean
    actualPickupTime?: boolean
    scheduledDropTime?: boolean
    actualDropTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ride"]>

  export type RideSelectScalar = {
    id?: boolean
    tripId?: boolean
    teenId?: boolean
    pickupStopId?: boolean
    dropStopId?: boolean
    status?: boolean
    scheduledPickupTime?: boolean
    actualPickupTime?: boolean
    scheduledDropTime?: boolean
    actualDropTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripId" | "teenId" | "pickupStopId" | "dropStopId" | "status" | "scheduledPickupTime" | "actualPickupTime" | "scheduledDropTime" | "actualDropTime" | "createdAt" | "updatedAt", ExtArgs["result"]["ride"]>
  export type RideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
    transactions?: boolean | Ride$transactionsArgs<ExtArgs>
    _count?: boolean | RideCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }
  export type RideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
    trip?: boolean | TripDefaultArgs<ExtArgs>
  }

  export type $RidePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ride"
    objects: {
      dropStop: Prisma.$RouteStopPayload<ExtArgs>
      pickupStop: Prisma.$RouteStopPayload<ExtArgs>
      teen: Prisma.$TeenPayload<ExtArgs>
      trip: Prisma.$TripPayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripId: string
      teenId: string
      pickupStopId: string
      dropStopId: string
      status: $Enums.RideStatus
      scheduledPickupTime: Date
      actualPickupTime: Date | null
      scheduledDropTime: Date
      actualDropTime: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ride"]>
    composites: {}
  }

  type RideGetPayload<S extends boolean | null | undefined | RideDefaultArgs> = $Result.GetResult<Prisma.$RidePayload, S>

  type RideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RideCountAggregateInputType | true
    }

  export interface RideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ride'], meta: { name: 'Ride' } }
    /**
     * Find zero or one Ride that matches the filter.
     * @param {RideFindUniqueArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RideFindUniqueArgs>(args: SelectSubset<T, RideFindUniqueArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ride that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RideFindUniqueOrThrowArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RideFindUniqueOrThrowArgs>(args: SelectSubset<T, RideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideFindFirstArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RideFindFirstArgs>(args?: SelectSubset<T, RideFindFirstArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideFindFirstOrThrowArgs} args - Arguments to find a Ride
     * @example
     * // Get one Ride
     * const ride = await prisma.ride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RideFindFirstOrThrowArgs>(args?: SelectSubset<T, RideFindFirstOrThrowArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rides
     * const rides = await prisma.ride.findMany()
     * 
     * // Get first 10 Rides
     * const rides = await prisma.ride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rideWithIdOnly = await prisma.ride.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RideFindManyArgs>(args?: SelectSubset<T, RideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ride.
     * @param {RideCreateArgs} args - Arguments to create a Ride.
     * @example
     * // Create one Ride
     * const Ride = await prisma.ride.create({
     *   data: {
     *     // ... data to create a Ride
     *   }
     * })
     * 
     */
    create<T extends RideCreateArgs>(args: SelectSubset<T, RideCreateArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rides.
     * @param {RideCreateManyArgs} args - Arguments to create many Rides.
     * @example
     * // Create many Rides
     * const ride = await prisma.ride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RideCreateManyArgs>(args?: SelectSubset<T, RideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rides and returns the data saved in the database.
     * @param {RideCreateManyAndReturnArgs} args - Arguments to create many Rides.
     * @example
     * // Create many Rides
     * const ride = await prisma.ride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rides and only return the `id`
     * const rideWithIdOnly = await prisma.ride.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RideCreateManyAndReturnArgs>(args?: SelectSubset<T, RideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ride.
     * @param {RideDeleteArgs} args - Arguments to delete one Ride.
     * @example
     * // Delete one Ride
     * const Ride = await prisma.ride.delete({
     *   where: {
     *     // ... filter to delete one Ride
     *   }
     * })
     * 
     */
    delete<T extends RideDeleteArgs>(args: SelectSubset<T, RideDeleteArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ride.
     * @param {RideUpdateArgs} args - Arguments to update one Ride.
     * @example
     * // Update one Ride
     * const ride = await prisma.ride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RideUpdateArgs>(args: SelectSubset<T, RideUpdateArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rides.
     * @param {RideDeleteManyArgs} args - Arguments to filter Rides to delete.
     * @example
     * // Delete a few Rides
     * const { count } = await prisma.ride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RideDeleteManyArgs>(args?: SelectSubset<T, RideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rides
     * const ride = await prisma.ride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RideUpdateManyArgs>(args: SelectSubset<T, RideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rides and returns the data updated in the database.
     * @param {RideUpdateManyAndReturnArgs} args - Arguments to update many Rides.
     * @example
     * // Update many Rides
     * const ride = await prisma.ride.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rides and only return the `id`
     * const rideWithIdOnly = await prisma.ride.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RideUpdateManyAndReturnArgs>(args: SelectSubset<T, RideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ride.
     * @param {RideUpsertArgs} args - Arguments to update or create a Ride.
     * @example
     * // Update or create a Ride
     * const ride = await prisma.ride.upsert({
     *   create: {
     *     // ... data to create a Ride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ride we want to update
     *   }
     * })
     */
    upsert<T extends RideUpsertArgs>(args: SelectSubset<T, RideUpsertArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideCountArgs} args - Arguments to filter Rides to count.
     * @example
     * // Count the number of Rides
     * const count = await prisma.ride.count({
     *   where: {
     *     // ... the filter for the Rides we want to count
     *   }
     * })
    **/
    count<T extends RideCountArgs>(
      args?: Subset<T, RideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RideAggregateArgs>(args: Subset<T, RideAggregateArgs>): Prisma.PrismaPromise<GetRideAggregateType<T>>

    /**
     * Group by Ride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RideGroupByArgs['orderBy'] }
        : { orderBy?: RideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ride model
   */
  readonly fields: RideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dropStop<T extends RouteStopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteStopDefaultArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pickupStop<T extends RouteStopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteStopDefaultArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teen<T extends TeenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeenDefaultArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trip<T extends TripDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripDefaultArgs<ExtArgs>>): Prisma__TripClient<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Ride$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Ride$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ride model
   */
  interface RideFieldRefs {
    readonly id: FieldRef<"Ride", 'String'>
    readonly tripId: FieldRef<"Ride", 'String'>
    readonly teenId: FieldRef<"Ride", 'String'>
    readonly pickupStopId: FieldRef<"Ride", 'String'>
    readonly dropStopId: FieldRef<"Ride", 'String'>
    readonly status: FieldRef<"Ride", 'RideStatus'>
    readonly scheduledPickupTime: FieldRef<"Ride", 'DateTime'>
    readonly actualPickupTime: FieldRef<"Ride", 'DateTime'>
    readonly scheduledDropTime: FieldRef<"Ride", 'DateTime'>
    readonly actualDropTime: FieldRef<"Ride", 'DateTime'>
    readonly createdAt: FieldRef<"Ride", 'DateTime'>
    readonly updatedAt: FieldRef<"Ride", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ride findUnique
   */
  export type RideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Ride to fetch.
     */
    where: RideWhereUniqueInput
  }

  /**
   * Ride findUniqueOrThrow
   */
  export type RideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Ride to fetch.
     */
    where: RideWhereUniqueInput
  }

  /**
   * Ride findFirst
   */
  export type RideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Ride to fetch.
     */
    where?: RideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rides to fetch.
     */
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rides.
     */
    cursor?: RideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rides.
     */
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Ride findFirstOrThrow
   */
  export type RideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Ride to fetch.
     */
    where?: RideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rides to fetch.
     */
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rides.
     */
    cursor?: RideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rides.
     */
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Ride findMany
   */
  export type RideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter, which Rides to fetch.
     */
    where?: RideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rides to fetch.
     */
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rides.
     */
    cursor?: RideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rides.
     */
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Ride create
   */
  export type RideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * The data needed to create a Ride.
     */
    data: XOR<RideCreateInput, RideUncheckedCreateInput>
  }

  /**
   * Ride createMany
   */
  export type RideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rides.
     */
    data: RideCreateManyInput | RideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ride createManyAndReturn
   */
  export type RideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * The data used to create many Rides.
     */
    data: RideCreateManyInput | RideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ride update
   */
  export type RideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * The data needed to update a Ride.
     */
    data: XOR<RideUpdateInput, RideUncheckedUpdateInput>
    /**
     * Choose, which Ride to update.
     */
    where: RideWhereUniqueInput
  }

  /**
   * Ride updateMany
   */
  export type RideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rides.
     */
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyInput>
    /**
     * Filter which Rides to update
     */
    where?: RideWhereInput
    /**
     * Limit how many Rides to update.
     */
    limit?: number
  }

  /**
   * Ride updateManyAndReturn
   */
  export type RideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * The data used to update Rides.
     */
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyInput>
    /**
     * Filter which Rides to update
     */
    where?: RideWhereInput
    /**
     * Limit how many Rides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ride upsert
   */
  export type RideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * The filter to search for the Ride to update in case it exists.
     */
    where: RideWhereUniqueInput
    /**
     * In case the Ride found by the `where` argument doesn't exist, create a new Ride with this data.
     */
    create: XOR<RideCreateInput, RideUncheckedCreateInput>
    /**
     * In case the Ride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RideUpdateInput, RideUncheckedUpdateInput>
  }

  /**
   * Ride delete
   */
  export type RideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    /**
     * Filter which Ride to delete.
     */
    where: RideWhereUniqueInput
  }

  /**
   * Ride deleteMany
   */
  export type RideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rides to delete
     */
    where?: RideWhereInput
    /**
     * Limit how many Rides to delete.
     */
    limit?: number
  }

  /**
   * Ride.transactions
   */
  export type Ride$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Ride without action
   */
  export type RideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    rideRequests?: boolean | Parent$rideRequestsArgs<ExtArgs>
    teens?: boolean | Parent$teensArgs<ExtArgs>
    wallet?: boolean | Parent$walletArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["parent"]>
  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    rideRequests?: boolean | Parent$rideRequestsArgs<ExtArgs>
    teens?: boolean | Parent$teensArgs<ExtArgs>
    wallet?: boolean | Parent$walletArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ParentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      rideRequests: Prisma.$RideRequestPayload<ExtArgs>[]
      teens: Prisma.$TeenPayload<ExtArgs>[]
      wallet: Prisma.$WalletPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents and returns the data updated in the database.
     * @param {ParentUpdateManyAndReturnArgs} args - Arguments to update many Parents.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParentUpdateManyAndReturnArgs>(args: SelectSubset<T, ParentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rideRequests<T extends Parent$rideRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Parent$rideRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teens<T extends Parent$teensArgs<ExtArgs> = {}>(args?: Subset<T, Parent$teensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallet<T extends Parent$walletArgs<ExtArgs> = {}>(args?: Subset<T, Parent$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly userId: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent createManyAndReturn
   */
  export type ParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parent updateManyAndReturn
   */
  export type ParentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parent.rideRequests
   */
  export type Parent$rideRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    where?: RideRequestWhereInput
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    cursor?: RideRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideRequestScalarFieldEnum | RideRequestScalarFieldEnum[]
  }

  /**
   * Parent.teens
   */
  export type Parent$teensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    where?: TeenWhereInput
    orderBy?: TeenOrderByWithRelationInput | TeenOrderByWithRelationInput[]
    cursor?: TeenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeenScalarFieldEnum | TeenScalarFieldEnum[]
  }

  /**
   * Parent.wallet
   */
  export type Parent$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    rating: number | null
  }

  export type DriverSumAggregateOutputType = {
    rating: number | null
  }

  export type DriverMinAggregateOutputType = {
    id: string | null
    userId: string | null
    licenseNumber: string | null
    aadharNumber: string | null
    verificationStatus: $Enums.VerificationStatus | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    licenseNumber: string | null
    aadharNumber: string | null
    verificationStatus: $Enums.VerificationStatus | null
    rating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    userId: number
    licenseNumber: number
    aadharNumber: number
    verificationStatus: number
    rating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    rating?: true
  }

  export type DriverSumAggregateInputType = {
    rating?: true
  }

  export type DriverMinAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    aadharNumber?: true
    verificationStatus?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    aadharNumber?: true
    verificationStatus?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    aadharNumber?: true
    verificationStatus?: true
    rating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    id: string
    userId: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus: $Enums.VerificationStatus | null
    rating: number
    createdAt: Date
    updatedAt: Date
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    aadharNumber?: boolean
    verificationStatus?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    verification?: boolean | Driver$verificationArgs<ExtArgs>
    routeAssignments?: boolean | Driver$routeAssignmentsArgs<ExtArgs>
    trips?: boolean | Driver$tripsArgs<ExtArgs>
    vehicle?: boolean | Driver$vehicleArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    aadharNumber?: boolean
    verificationStatus?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    aadharNumber?: boolean
    verificationStatus?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    aadharNumber?: boolean
    verificationStatus?: boolean
    rating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DriverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "licenseNumber" | "aadharNumber" | "verificationStatus" | "rating" | "createdAt" | "updatedAt", ExtArgs["result"]["driver"]>
  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    verification?: boolean | Driver$verificationArgs<ExtArgs>
    routeAssignments?: boolean | Driver$routeAssignmentsArgs<ExtArgs>
    trips?: boolean | Driver$tripsArgs<ExtArgs>
    vehicle?: boolean | Driver$vehicleArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DriverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      verification: Prisma.$DriverVerificationPayload<ExtArgs> | null
      routeAssignments: Prisma.$RouteDriverPayload<ExtArgs>[]
      trips: Prisma.$TripPayload<ExtArgs>[]
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      licenseNumber: string
      aadharNumber: string
      verificationStatus: $Enums.VerificationStatus | null
      rating: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers and returns the data updated in the database.
     * @param {DriverUpdateManyAndReturnArgs} args - Arguments to update many Drivers.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verification<T extends Driver$verificationArgs<ExtArgs> = {}>(args?: Subset<T, Driver$verificationArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    routeAssignments<T extends Driver$routeAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$routeAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteDriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trips<T extends Driver$tripsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$tripsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle<T extends Driver$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, Driver$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */
  interface DriverFieldRefs {
    readonly id: FieldRef<"Driver", 'String'>
    readonly userId: FieldRef<"Driver", 'String'>
    readonly licenseNumber: FieldRef<"Driver", 'String'>
    readonly aadharNumber: FieldRef<"Driver", 'String'>
    readonly verificationStatus: FieldRef<"Driver", 'VerificationStatus'>
    readonly rating: FieldRef<"Driver", 'Float'>
    readonly createdAt: FieldRef<"Driver", 'DateTime'>
    readonly updatedAt: FieldRef<"Driver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
  }

  /**
   * Driver updateManyAndReturn
   */
  export type DriverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to delete.
     */
    limit?: number
  }

  /**
   * Driver.verification
   */
  export type Driver$verificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    where?: DriverVerificationWhereInput
  }

  /**
   * Driver.routeAssignments
   */
  export type Driver$routeAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteDriver
     */
    select?: RouteDriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteDriver
     */
    omit?: RouteDriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteDriverInclude<ExtArgs> | null
    where?: RouteDriverWhereInput
    orderBy?: RouteDriverOrderByWithRelationInput | RouteDriverOrderByWithRelationInput[]
    cursor?: RouteDriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteDriverScalarFieldEnum | RouteDriverScalarFieldEnum[]
  }

  /**
   * Driver.trips
   */
  export type Driver$tripsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trip
     */
    select?: TripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trip
     */
    omit?: TripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripInclude<ExtArgs> | null
    where?: TripWhereInput
    orderBy?: TripOrderByWithRelationInput | TripOrderByWithRelationInput[]
    cursor?: TripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripScalarFieldEnum | TripScalarFieldEnum[]
  }

  /**
   * Driver.vehicle
   */
  export type Driver$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model Teen
   */

  export type AggregateTeen = {
    _count: TeenCountAggregateOutputType | null
    _avg: TeenAvgAggregateOutputType | null
    _sum: TeenSumAggregateOutputType | null
    _min: TeenMinAggregateOutputType | null
    _max: TeenMaxAggregateOutputType | null
  }

  export type TeenAvgAggregateOutputType = {
    age: number | null
  }

  export type TeenSumAggregateOutputType = {
    age: number | null
  }

  export type TeenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    parentId: string | null
    inviteCode: string | null
    inviteExpiry: Date | null
    inviteStatus: $Enums.InviteStatus | null
    inviteType: $Enums.InviteType | null
    name: string | null
    age: number | null
    grade: string | null
    avatar: string | null
    schoolId: string | null
    emergencyContact: string | null
    medicalInfo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    parentId: string | null
    inviteCode: string | null
    inviteExpiry: Date | null
    inviteStatus: $Enums.InviteStatus | null
    inviteType: $Enums.InviteType | null
    name: string | null
    age: number | null
    grade: string | null
    avatar: string | null
    schoolId: string | null
    emergencyContact: string | null
    medicalInfo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeenCountAggregateOutputType = {
    id: number
    userId: number
    parentId: number
    inviteCode: number
    inviteExpiry: number
    inviteStatus: number
    inviteType: number
    name: number
    age: number
    grade: number
    avatar: number
    schoolId: number
    emergencyContact: number
    medicalInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeenAvgAggregateInputType = {
    age?: true
  }

  export type TeenSumAggregateInputType = {
    age?: true
  }

  export type TeenMinAggregateInputType = {
    id?: true
    userId?: true
    parentId?: true
    inviteCode?: true
    inviteExpiry?: true
    inviteStatus?: true
    inviteType?: true
    name?: true
    age?: true
    grade?: true
    avatar?: true
    schoolId?: true
    emergencyContact?: true
    medicalInfo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeenMaxAggregateInputType = {
    id?: true
    userId?: true
    parentId?: true
    inviteCode?: true
    inviteExpiry?: true
    inviteStatus?: true
    inviteType?: true
    name?: true
    age?: true
    grade?: true
    avatar?: true
    schoolId?: true
    emergencyContact?: true
    medicalInfo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeenCountAggregateInputType = {
    id?: true
    userId?: true
    parentId?: true
    inviteCode?: true
    inviteExpiry?: true
    inviteStatus?: true
    inviteType?: true
    name?: true
    age?: true
    grade?: true
    avatar?: true
    schoolId?: true
    emergencyContact?: true
    medicalInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teen to aggregate.
     */
    where?: TeenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teens to fetch.
     */
    orderBy?: TeenOrderByWithRelationInput | TeenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teens
    **/
    _count?: true | TeenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeenMaxAggregateInputType
  }

  export type GetTeenAggregateType<T extends TeenAggregateArgs> = {
        [P in keyof T & keyof AggregateTeen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeen[P]>
      : GetScalarType<T[P], AggregateTeen[P]>
  }




  export type TeenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeenWhereInput
    orderBy?: TeenOrderByWithAggregationInput | TeenOrderByWithAggregationInput[]
    by: TeenScalarFieldEnum[] | TeenScalarFieldEnum
    having?: TeenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeenCountAggregateInputType | true
    _avg?: TeenAvgAggregateInputType
    _sum?: TeenSumAggregateInputType
    _min?: TeenMinAggregateInputType
    _max?: TeenMaxAggregateInputType
  }

  export type TeenGroupByOutputType = {
    id: string
    userId: string
    parentId: string
    inviteCode: string | null
    inviteExpiry: Date | null
    inviteStatus: $Enums.InviteStatus
    inviteType: $Enums.InviteType | null
    name: string
    age: number
    grade: string | null
    avatar: string | null
    schoolId: string | null
    emergencyContact: string | null
    medicalInfo: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeenCountAggregateOutputType | null
    _avg: TeenAvgAggregateOutputType | null
    _sum: TeenSumAggregateOutputType | null
    _min: TeenMinAggregateOutputType | null
    _max: TeenMaxAggregateOutputType | null
  }

  type GetTeenGroupByPayload<T extends TeenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeenGroupByOutputType[P]>
            : GetScalarType<T[P], TeenGroupByOutputType[P]>
        }
      >
    >


  export type TeenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    parentId?: boolean
    inviteCode?: boolean
    inviteExpiry?: boolean
    inviteStatus?: boolean
    inviteType?: boolean
    name?: boolean
    age?: boolean
    grade?: boolean
    avatar?: boolean
    schoolId?: boolean
    emergencyContact?: boolean
    medicalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rides?: boolean | Teen$ridesArgs<ExtArgs>
    rideRequests?: boolean | Teen$rideRequestsArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    school?: boolean | Teen$schoolArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    buddyOf?: boolean | Teen$buddyOfArgs<ExtArgs>
    buddies?: boolean | Teen$buddiesArgs<ExtArgs>
    rewards?: boolean | Teen$rewardsArgs<ExtArgs>
    _count?: boolean | TeenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teen"]>

  export type TeenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    parentId?: boolean
    inviteCode?: boolean
    inviteExpiry?: boolean
    inviteStatus?: boolean
    inviteType?: boolean
    name?: boolean
    age?: boolean
    grade?: boolean
    avatar?: boolean
    schoolId?: boolean
    emergencyContact?: boolean
    medicalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    school?: boolean | Teen$schoolArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teen"]>

  export type TeenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    parentId?: boolean
    inviteCode?: boolean
    inviteExpiry?: boolean
    inviteStatus?: boolean
    inviteType?: boolean
    name?: boolean
    age?: boolean
    grade?: boolean
    avatar?: boolean
    schoolId?: boolean
    emergencyContact?: boolean
    medicalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    school?: boolean | Teen$schoolArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teen"]>

  export type TeenSelectScalar = {
    id?: boolean
    userId?: boolean
    parentId?: boolean
    inviteCode?: boolean
    inviteExpiry?: boolean
    inviteStatus?: boolean
    inviteType?: boolean
    name?: boolean
    age?: boolean
    grade?: boolean
    avatar?: boolean
    schoolId?: boolean
    emergencyContact?: boolean
    medicalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "parentId" | "inviteCode" | "inviteExpiry" | "inviteStatus" | "inviteType" | "name" | "age" | "grade" | "avatar" | "schoolId" | "emergencyContact" | "medicalInfo" | "createdAt" | "updatedAt", ExtArgs["result"]["teen"]>
  export type TeenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rides?: boolean | Teen$ridesArgs<ExtArgs>
    rideRequests?: boolean | Teen$rideRequestsArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    school?: boolean | Teen$schoolArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    buddyOf?: boolean | Teen$buddyOfArgs<ExtArgs>
    buddies?: boolean | Teen$buddiesArgs<ExtArgs>
    rewards?: boolean | Teen$rewardsArgs<ExtArgs>
    _count?: boolean | TeenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    school?: boolean | Teen$schoolArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    school?: boolean | Teen$schoolArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teen"
    objects: {
      rides: Prisma.$RidePayload<ExtArgs>[]
      rideRequests: Prisma.$RideRequestPayload<ExtArgs>[]
      parent: Prisma.$ParentPayload<ExtArgs>
      school: Prisma.$LocationPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      buddyOf: Prisma.$TeenBuddyPayload<ExtArgs>[]
      buddies: Prisma.$TeenBuddyPayload<ExtArgs>[]
      rewards: Prisma.$TeenRewardsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      parentId: string
      inviteCode: string | null
      inviteExpiry: Date | null
      inviteStatus: $Enums.InviteStatus
      inviteType: $Enums.InviteType | null
      name: string
      age: number
      grade: string | null
      avatar: string | null
      schoolId: string | null
      emergencyContact: string | null
      medicalInfo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teen"]>
    composites: {}
  }

  type TeenGetPayload<S extends boolean | null | undefined | TeenDefaultArgs> = $Result.GetResult<Prisma.$TeenPayload, S>

  type TeenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeenCountAggregateInputType | true
    }

  export interface TeenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teen'], meta: { name: 'Teen' } }
    /**
     * Find zero or one Teen that matches the filter.
     * @param {TeenFindUniqueArgs} args - Arguments to find a Teen
     * @example
     * // Get one Teen
     * const teen = await prisma.teen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeenFindUniqueArgs>(args: SelectSubset<T, TeenFindUniqueArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeenFindUniqueOrThrowArgs} args - Arguments to find a Teen
     * @example
     * // Get one Teen
     * const teen = await prisma.teen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeenFindUniqueOrThrowArgs>(args: SelectSubset<T, TeenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenFindFirstArgs} args - Arguments to find a Teen
     * @example
     * // Get one Teen
     * const teen = await prisma.teen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeenFindFirstArgs>(args?: SelectSubset<T, TeenFindFirstArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenFindFirstOrThrowArgs} args - Arguments to find a Teen
     * @example
     * // Get one Teen
     * const teen = await prisma.teen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeenFindFirstOrThrowArgs>(args?: SelectSubset<T, TeenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teens
     * const teens = await prisma.teen.findMany()
     * 
     * // Get first 10 Teens
     * const teens = await prisma.teen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teenWithIdOnly = await prisma.teen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeenFindManyArgs>(args?: SelectSubset<T, TeenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teen.
     * @param {TeenCreateArgs} args - Arguments to create a Teen.
     * @example
     * // Create one Teen
     * const Teen = await prisma.teen.create({
     *   data: {
     *     // ... data to create a Teen
     *   }
     * })
     * 
     */
    create<T extends TeenCreateArgs>(args: SelectSubset<T, TeenCreateArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teens.
     * @param {TeenCreateManyArgs} args - Arguments to create many Teens.
     * @example
     * // Create many Teens
     * const teen = await prisma.teen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeenCreateManyArgs>(args?: SelectSubset<T, TeenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teens and returns the data saved in the database.
     * @param {TeenCreateManyAndReturnArgs} args - Arguments to create many Teens.
     * @example
     * // Create many Teens
     * const teen = await prisma.teen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teens and only return the `id`
     * const teenWithIdOnly = await prisma.teen.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeenCreateManyAndReturnArgs>(args?: SelectSubset<T, TeenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teen.
     * @param {TeenDeleteArgs} args - Arguments to delete one Teen.
     * @example
     * // Delete one Teen
     * const Teen = await prisma.teen.delete({
     *   where: {
     *     // ... filter to delete one Teen
     *   }
     * })
     * 
     */
    delete<T extends TeenDeleteArgs>(args: SelectSubset<T, TeenDeleteArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teen.
     * @param {TeenUpdateArgs} args - Arguments to update one Teen.
     * @example
     * // Update one Teen
     * const teen = await prisma.teen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeenUpdateArgs>(args: SelectSubset<T, TeenUpdateArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teens.
     * @param {TeenDeleteManyArgs} args - Arguments to filter Teens to delete.
     * @example
     * // Delete a few Teens
     * const { count } = await prisma.teen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeenDeleteManyArgs>(args?: SelectSubset<T, TeenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teens
     * const teen = await prisma.teen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeenUpdateManyArgs>(args: SelectSubset<T, TeenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teens and returns the data updated in the database.
     * @param {TeenUpdateManyAndReturnArgs} args - Arguments to update many Teens.
     * @example
     * // Update many Teens
     * const teen = await prisma.teen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teens and only return the `id`
     * const teenWithIdOnly = await prisma.teen.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeenUpdateManyAndReturnArgs>(args: SelectSubset<T, TeenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teen.
     * @param {TeenUpsertArgs} args - Arguments to update or create a Teen.
     * @example
     * // Update or create a Teen
     * const teen = await prisma.teen.upsert({
     *   create: {
     *     // ... data to create a Teen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teen we want to update
     *   }
     * })
     */
    upsert<T extends TeenUpsertArgs>(args: SelectSubset<T, TeenUpsertArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenCountArgs} args - Arguments to filter Teens to count.
     * @example
     * // Count the number of Teens
     * const count = await prisma.teen.count({
     *   where: {
     *     // ... the filter for the Teens we want to count
     *   }
     * })
    **/
    count<T extends TeenCountArgs>(
      args?: Subset<T, TeenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeenAggregateArgs>(args: Subset<T, TeenAggregateArgs>): Prisma.PrismaPromise<GetTeenAggregateType<T>>

    /**
     * Group by Teen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeenGroupByArgs['orderBy'] }
        : { orderBy?: TeenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teen model
   */
  readonly fields: TeenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rides<T extends Teen$ridesArgs<ExtArgs> = {}>(args?: Subset<T, Teen$ridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rideRequests<T extends Teen$rideRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Teen$rideRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    school<T extends Teen$schoolArgs<ExtArgs> = {}>(args?: Subset<T, Teen$schoolArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    buddyOf<T extends Teen$buddyOfArgs<ExtArgs> = {}>(args?: Subset<T, Teen$buddyOfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    buddies<T extends Teen$buddiesArgs<ExtArgs> = {}>(args?: Subset<T, Teen$buddiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewards<T extends Teen$rewardsArgs<ExtArgs> = {}>(args?: Subset<T, Teen$rewardsArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teen model
   */
  interface TeenFieldRefs {
    readonly id: FieldRef<"Teen", 'String'>
    readonly userId: FieldRef<"Teen", 'String'>
    readonly parentId: FieldRef<"Teen", 'String'>
    readonly inviteCode: FieldRef<"Teen", 'String'>
    readonly inviteExpiry: FieldRef<"Teen", 'DateTime'>
    readonly inviteStatus: FieldRef<"Teen", 'InviteStatus'>
    readonly inviteType: FieldRef<"Teen", 'InviteType'>
    readonly name: FieldRef<"Teen", 'String'>
    readonly age: FieldRef<"Teen", 'Int'>
    readonly grade: FieldRef<"Teen", 'String'>
    readonly avatar: FieldRef<"Teen", 'String'>
    readonly schoolId: FieldRef<"Teen", 'String'>
    readonly emergencyContact: FieldRef<"Teen", 'String'>
    readonly medicalInfo: FieldRef<"Teen", 'String'>
    readonly createdAt: FieldRef<"Teen", 'DateTime'>
    readonly updatedAt: FieldRef<"Teen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teen findUnique
   */
  export type TeenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * Filter, which Teen to fetch.
     */
    where: TeenWhereUniqueInput
  }

  /**
   * Teen findUniqueOrThrow
   */
  export type TeenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * Filter, which Teen to fetch.
     */
    where: TeenWhereUniqueInput
  }

  /**
   * Teen findFirst
   */
  export type TeenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * Filter, which Teen to fetch.
     */
    where?: TeenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teens to fetch.
     */
    orderBy?: TeenOrderByWithRelationInput | TeenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teens.
     */
    cursor?: TeenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teens.
     */
    distinct?: TeenScalarFieldEnum | TeenScalarFieldEnum[]
  }

  /**
   * Teen findFirstOrThrow
   */
  export type TeenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * Filter, which Teen to fetch.
     */
    where?: TeenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teens to fetch.
     */
    orderBy?: TeenOrderByWithRelationInput | TeenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teens.
     */
    cursor?: TeenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teens.
     */
    distinct?: TeenScalarFieldEnum | TeenScalarFieldEnum[]
  }

  /**
   * Teen findMany
   */
  export type TeenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * Filter, which Teens to fetch.
     */
    where?: TeenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teens to fetch.
     */
    orderBy?: TeenOrderByWithRelationInput | TeenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teens.
     */
    cursor?: TeenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teens.
     */
    skip?: number
    distinct?: TeenScalarFieldEnum | TeenScalarFieldEnum[]
  }

  /**
   * Teen create
   */
  export type TeenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * The data needed to create a Teen.
     */
    data: XOR<TeenCreateInput, TeenUncheckedCreateInput>
  }

  /**
   * Teen createMany
   */
  export type TeenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teens.
     */
    data: TeenCreateManyInput | TeenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teen createManyAndReturn
   */
  export type TeenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * The data used to create many Teens.
     */
    data: TeenCreateManyInput | TeenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teen update
   */
  export type TeenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * The data needed to update a Teen.
     */
    data: XOR<TeenUpdateInput, TeenUncheckedUpdateInput>
    /**
     * Choose, which Teen to update.
     */
    where: TeenWhereUniqueInput
  }

  /**
   * Teen updateMany
   */
  export type TeenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teens.
     */
    data: XOR<TeenUpdateManyMutationInput, TeenUncheckedUpdateManyInput>
    /**
     * Filter which Teens to update
     */
    where?: TeenWhereInput
    /**
     * Limit how many Teens to update.
     */
    limit?: number
  }

  /**
   * Teen updateManyAndReturn
   */
  export type TeenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * The data used to update Teens.
     */
    data: XOR<TeenUpdateManyMutationInput, TeenUncheckedUpdateManyInput>
    /**
     * Filter which Teens to update
     */
    where?: TeenWhereInput
    /**
     * Limit how many Teens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teen upsert
   */
  export type TeenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * The filter to search for the Teen to update in case it exists.
     */
    where: TeenWhereUniqueInput
    /**
     * In case the Teen found by the `where` argument doesn't exist, create a new Teen with this data.
     */
    create: XOR<TeenCreateInput, TeenUncheckedCreateInput>
    /**
     * In case the Teen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeenUpdateInput, TeenUncheckedUpdateInput>
  }

  /**
   * Teen delete
   */
  export type TeenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
    /**
     * Filter which Teen to delete.
     */
    where: TeenWhereUniqueInput
  }

  /**
   * Teen deleteMany
   */
  export type TeenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teens to delete
     */
    where?: TeenWhereInput
    /**
     * Limit how many Teens to delete.
     */
    limit?: number
  }

  /**
   * Teen.rides
   */
  export type Teen$ridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
    orderBy?: RideOrderByWithRelationInput | RideOrderByWithRelationInput[]
    cursor?: RideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideScalarFieldEnum | RideScalarFieldEnum[]
  }

  /**
   * Teen.rideRequests
   */
  export type Teen$rideRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    where?: RideRequestWhereInput
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    cursor?: RideRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RideRequestScalarFieldEnum | RideRequestScalarFieldEnum[]
  }

  /**
   * Teen.school
   */
  export type Teen$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
  }

  /**
   * Teen.buddyOf
   */
  export type Teen$buddyOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    where?: TeenBuddyWhereInput
    orderBy?: TeenBuddyOrderByWithRelationInput | TeenBuddyOrderByWithRelationInput[]
    cursor?: TeenBuddyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeenBuddyScalarFieldEnum | TeenBuddyScalarFieldEnum[]
  }

  /**
   * Teen.buddies
   */
  export type Teen$buddiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    where?: TeenBuddyWhereInput
    orderBy?: TeenBuddyOrderByWithRelationInput | TeenBuddyOrderByWithRelationInput[]
    cursor?: TeenBuddyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeenBuddyScalarFieldEnum | TeenBuddyScalarFieldEnum[]
  }

  /**
   * Teen.rewards
   */
  export type Teen$rewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    where?: TeenRewardsWhereInput
  }

  /**
   * Teen without action
   */
  export type TeenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teen
     */
    select?: TeenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teen
     */
    omit?: TeenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenInclude<ExtArgs> | null
  }


  /**
   * Model RideRequest
   */

  export type AggregateRideRequest = {
    _count: RideRequestCountAggregateOutputType | null
    _avg: RideRequestAvgAggregateOutputType | null
    _sum: RideRequestSumAggregateOutputType | null
    _min: RideRequestMinAggregateOutputType | null
    _max: RideRequestMaxAggregateOutputType | null
  }

  export type RideRequestAvgAggregateOutputType = {
    seatsRequired: number | null
  }

  export type RideRequestSumAggregateOutputType = {
    seatsRequired: number | null
  }

  export type RideRequestMinAggregateOutputType = {
    id: string | null
    parentId: string | null
    teenId: string | null
    routeId: string | null
    pickupStopId: string | null
    dropStopId: string | null
    requestType: $Enums.RequestType | null
    seatsRequired: number | null
    expectedPickupTime: Date | null
    expectedDropTime: Date | null
    status: $Enums.RouteStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RideRequestMaxAggregateOutputType = {
    id: string | null
    parentId: string | null
    teenId: string | null
    routeId: string | null
    pickupStopId: string | null
    dropStopId: string | null
    requestType: $Enums.RequestType | null
    seatsRequired: number | null
    expectedPickupTime: Date | null
    expectedDropTime: Date | null
    status: $Enums.RouteStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RideRequestCountAggregateOutputType = {
    id: number
    parentId: number
    teenId: number
    routeId: number
    pickupStopId: number
    dropStopId: number
    requestType: number
    seatsRequired: number
    expectedPickupTime: number
    expectedDropTime: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RideRequestAvgAggregateInputType = {
    seatsRequired?: true
  }

  export type RideRequestSumAggregateInputType = {
    seatsRequired?: true
  }

  export type RideRequestMinAggregateInputType = {
    id?: true
    parentId?: true
    teenId?: true
    routeId?: true
    pickupStopId?: true
    dropStopId?: true
    requestType?: true
    seatsRequired?: true
    expectedPickupTime?: true
    expectedDropTime?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RideRequestMaxAggregateInputType = {
    id?: true
    parentId?: true
    teenId?: true
    routeId?: true
    pickupStopId?: true
    dropStopId?: true
    requestType?: true
    seatsRequired?: true
    expectedPickupTime?: true
    expectedDropTime?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RideRequestCountAggregateInputType = {
    id?: true
    parentId?: true
    teenId?: true
    routeId?: true
    pickupStopId?: true
    dropStopId?: true
    requestType?: true
    seatsRequired?: true
    expectedPickupTime?: true
    expectedDropTime?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RideRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RideRequest to aggregate.
     */
    where?: RideRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideRequests to fetch.
     */
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RideRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RideRequests
    **/
    _count?: true | RideRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RideRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RideRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RideRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RideRequestMaxAggregateInputType
  }

  export type GetRideRequestAggregateType<T extends RideRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateRideRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRideRequest[P]>
      : GetScalarType<T[P], AggregateRideRequest[P]>
  }




  export type RideRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RideRequestWhereInput
    orderBy?: RideRequestOrderByWithAggregationInput | RideRequestOrderByWithAggregationInput[]
    by: RideRequestScalarFieldEnum[] | RideRequestScalarFieldEnum
    having?: RideRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RideRequestCountAggregateInputType | true
    _avg?: RideRequestAvgAggregateInputType
    _sum?: RideRequestSumAggregateInputType
    _min?: RideRequestMinAggregateInputType
    _max?: RideRequestMaxAggregateInputType
  }

  export type RideRequestGroupByOutputType = {
    id: string
    parentId: string
    teenId: string
    routeId: string
    pickupStopId: string
    dropStopId: string
    requestType: $Enums.RequestType
    seatsRequired: number
    expectedPickupTime: Date
    expectedDropTime: Date
    status: $Enums.RouteStatus
    createdAt: Date
    updatedAt: Date
    _count: RideRequestCountAggregateOutputType | null
    _avg: RideRequestAvgAggregateOutputType | null
    _sum: RideRequestSumAggregateOutputType | null
    _min: RideRequestMinAggregateOutputType | null
    _max: RideRequestMaxAggregateOutputType | null
  }

  type GetRideRequestGroupByPayload<T extends RideRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RideRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RideRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RideRequestGroupByOutputType[P]>
            : GetScalarType<T[P], RideRequestGroupByOutputType[P]>
        }
      >
    >


  export type RideRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    teenId?: boolean
    routeId?: boolean
    pickupStopId?: boolean
    dropStopId?: boolean
    requestType?: boolean
    seatsRequired?: boolean
    expectedPickupTime?: boolean
    expectedDropTime?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rideRequest"]>

  export type RideRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    teenId?: boolean
    routeId?: boolean
    pickupStopId?: boolean
    dropStopId?: boolean
    requestType?: boolean
    seatsRequired?: boolean
    expectedPickupTime?: boolean
    expectedDropTime?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rideRequest"]>

  export type RideRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    teenId?: boolean
    routeId?: boolean
    pickupStopId?: boolean
    dropStopId?: boolean
    requestType?: boolean
    seatsRequired?: boolean
    expectedPickupTime?: boolean
    expectedDropTime?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rideRequest"]>

  export type RideRequestSelectScalar = {
    id?: boolean
    parentId?: boolean
    teenId?: boolean
    routeId?: boolean
    pickupStopId?: boolean
    dropStopId?: boolean
    requestType?: boolean
    seatsRequired?: boolean
    expectedPickupTime?: boolean
    expectedDropTime?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RideRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parentId" | "teenId" | "routeId" | "pickupStopId" | "dropStopId" | "requestType" | "seatsRequired" | "expectedPickupTime" | "expectedDropTime" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["rideRequest"]>
  export type RideRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }
  export type RideRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }
  export type RideRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dropStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    pickupStop?: boolean | RouteStopDefaultArgs<ExtArgs>
    route?: boolean | RouteDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }

  export type $RideRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RideRequest"
    objects: {
      dropStop: Prisma.$RouteStopPayload<ExtArgs>
      parent: Prisma.$ParentPayload<ExtArgs>
      pickupStop: Prisma.$RouteStopPayload<ExtArgs>
      route: Prisma.$RoutePayload<ExtArgs>
      teen: Prisma.$TeenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parentId: string
      teenId: string
      routeId: string
      pickupStopId: string
      dropStopId: string
      requestType: $Enums.RequestType
      seatsRequired: number
      expectedPickupTime: Date
      expectedDropTime: Date
      status: $Enums.RouteStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rideRequest"]>
    composites: {}
  }

  type RideRequestGetPayload<S extends boolean | null | undefined | RideRequestDefaultArgs> = $Result.GetResult<Prisma.$RideRequestPayload, S>

  type RideRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RideRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RideRequestCountAggregateInputType | true
    }

  export interface RideRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RideRequest'], meta: { name: 'RideRequest' } }
    /**
     * Find zero or one RideRequest that matches the filter.
     * @param {RideRequestFindUniqueArgs} args - Arguments to find a RideRequest
     * @example
     * // Get one RideRequest
     * const rideRequest = await prisma.rideRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RideRequestFindUniqueArgs>(args: SelectSubset<T, RideRequestFindUniqueArgs<ExtArgs>>): Prisma__RideRequestClient<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RideRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RideRequestFindUniqueOrThrowArgs} args - Arguments to find a RideRequest
     * @example
     * // Get one RideRequest
     * const rideRequest = await prisma.rideRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RideRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, RideRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RideRequestClient<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RideRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideRequestFindFirstArgs} args - Arguments to find a RideRequest
     * @example
     * // Get one RideRequest
     * const rideRequest = await prisma.rideRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RideRequestFindFirstArgs>(args?: SelectSubset<T, RideRequestFindFirstArgs<ExtArgs>>): Prisma__RideRequestClient<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RideRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideRequestFindFirstOrThrowArgs} args - Arguments to find a RideRequest
     * @example
     * // Get one RideRequest
     * const rideRequest = await prisma.rideRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RideRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, RideRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__RideRequestClient<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RideRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RideRequests
     * const rideRequests = await prisma.rideRequest.findMany()
     * 
     * // Get first 10 RideRequests
     * const rideRequests = await prisma.rideRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rideRequestWithIdOnly = await prisma.rideRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RideRequestFindManyArgs>(args?: SelectSubset<T, RideRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RideRequest.
     * @param {RideRequestCreateArgs} args - Arguments to create a RideRequest.
     * @example
     * // Create one RideRequest
     * const RideRequest = await prisma.rideRequest.create({
     *   data: {
     *     // ... data to create a RideRequest
     *   }
     * })
     * 
     */
    create<T extends RideRequestCreateArgs>(args: SelectSubset<T, RideRequestCreateArgs<ExtArgs>>): Prisma__RideRequestClient<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RideRequests.
     * @param {RideRequestCreateManyArgs} args - Arguments to create many RideRequests.
     * @example
     * // Create many RideRequests
     * const rideRequest = await prisma.rideRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RideRequestCreateManyArgs>(args?: SelectSubset<T, RideRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RideRequests and returns the data saved in the database.
     * @param {RideRequestCreateManyAndReturnArgs} args - Arguments to create many RideRequests.
     * @example
     * // Create many RideRequests
     * const rideRequest = await prisma.rideRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RideRequests and only return the `id`
     * const rideRequestWithIdOnly = await prisma.rideRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RideRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, RideRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RideRequest.
     * @param {RideRequestDeleteArgs} args - Arguments to delete one RideRequest.
     * @example
     * // Delete one RideRequest
     * const RideRequest = await prisma.rideRequest.delete({
     *   where: {
     *     // ... filter to delete one RideRequest
     *   }
     * })
     * 
     */
    delete<T extends RideRequestDeleteArgs>(args: SelectSubset<T, RideRequestDeleteArgs<ExtArgs>>): Prisma__RideRequestClient<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RideRequest.
     * @param {RideRequestUpdateArgs} args - Arguments to update one RideRequest.
     * @example
     * // Update one RideRequest
     * const rideRequest = await prisma.rideRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RideRequestUpdateArgs>(args: SelectSubset<T, RideRequestUpdateArgs<ExtArgs>>): Prisma__RideRequestClient<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RideRequests.
     * @param {RideRequestDeleteManyArgs} args - Arguments to filter RideRequests to delete.
     * @example
     * // Delete a few RideRequests
     * const { count } = await prisma.rideRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RideRequestDeleteManyArgs>(args?: SelectSubset<T, RideRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RideRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RideRequests
     * const rideRequest = await prisma.rideRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RideRequestUpdateManyArgs>(args: SelectSubset<T, RideRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RideRequests and returns the data updated in the database.
     * @param {RideRequestUpdateManyAndReturnArgs} args - Arguments to update many RideRequests.
     * @example
     * // Update many RideRequests
     * const rideRequest = await prisma.rideRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RideRequests and only return the `id`
     * const rideRequestWithIdOnly = await prisma.rideRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RideRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, RideRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RideRequest.
     * @param {RideRequestUpsertArgs} args - Arguments to update or create a RideRequest.
     * @example
     * // Update or create a RideRequest
     * const rideRequest = await prisma.rideRequest.upsert({
     *   create: {
     *     // ... data to create a RideRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RideRequest we want to update
     *   }
     * })
     */
    upsert<T extends RideRequestUpsertArgs>(args: SelectSubset<T, RideRequestUpsertArgs<ExtArgs>>): Prisma__RideRequestClient<$Result.GetResult<Prisma.$RideRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RideRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideRequestCountArgs} args - Arguments to filter RideRequests to count.
     * @example
     * // Count the number of RideRequests
     * const count = await prisma.rideRequest.count({
     *   where: {
     *     // ... the filter for the RideRequests we want to count
     *   }
     * })
    **/
    count<T extends RideRequestCountArgs>(
      args?: Subset<T, RideRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RideRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RideRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RideRequestAggregateArgs>(args: Subset<T, RideRequestAggregateArgs>): Prisma.PrismaPromise<GetRideRequestAggregateType<T>>

    /**
     * Group by RideRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RideRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RideRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RideRequestGroupByArgs['orderBy'] }
        : { orderBy?: RideRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RideRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRideRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RideRequest model
   */
  readonly fields: RideRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RideRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RideRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dropStop<T extends RouteStopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteStopDefaultArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pickupStop<T extends RouteStopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteStopDefaultArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teen<T extends TeenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeenDefaultArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RideRequest model
   */
  interface RideRequestFieldRefs {
    readonly id: FieldRef<"RideRequest", 'String'>
    readonly parentId: FieldRef<"RideRequest", 'String'>
    readonly teenId: FieldRef<"RideRequest", 'String'>
    readonly routeId: FieldRef<"RideRequest", 'String'>
    readonly pickupStopId: FieldRef<"RideRequest", 'String'>
    readonly dropStopId: FieldRef<"RideRequest", 'String'>
    readonly requestType: FieldRef<"RideRequest", 'RequestType'>
    readonly seatsRequired: FieldRef<"RideRequest", 'Int'>
    readonly expectedPickupTime: FieldRef<"RideRequest", 'DateTime'>
    readonly expectedDropTime: FieldRef<"RideRequest", 'DateTime'>
    readonly status: FieldRef<"RideRequest", 'RouteStatus'>
    readonly createdAt: FieldRef<"RideRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"RideRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RideRequest findUnique
   */
  export type RideRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * Filter, which RideRequest to fetch.
     */
    where: RideRequestWhereUniqueInput
  }

  /**
   * RideRequest findUniqueOrThrow
   */
  export type RideRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * Filter, which RideRequest to fetch.
     */
    where: RideRequestWhereUniqueInput
  }

  /**
   * RideRequest findFirst
   */
  export type RideRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * Filter, which RideRequest to fetch.
     */
    where?: RideRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideRequests to fetch.
     */
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RideRequests.
     */
    cursor?: RideRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RideRequests.
     */
    distinct?: RideRequestScalarFieldEnum | RideRequestScalarFieldEnum[]
  }

  /**
   * RideRequest findFirstOrThrow
   */
  export type RideRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * Filter, which RideRequest to fetch.
     */
    where?: RideRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideRequests to fetch.
     */
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RideRequests.
     */
    cursor?: RideRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RideRequests.
     */
    distinct?: RideRequestScalarFieldEnum | RideRequestScalarFieldEnum[]
  }

  /**
   * RideRequest findMany
   */
  export type RideRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * Filter, which RideRequests to fetch.
     */
    where?: RideRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RideRequests to fetch.
     */
    orderBy?: RideRequestOrderByWithRelationInput | RideRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RideRequests.
     */
    cursor?: RideRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RideRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RideRequests.
     */
    skip?: number
    distinct?: RideRequestScalarFieldEnum | RideRequestScalarFieldEnum[]
  }

  /**
   * RideRequest create
   */
  export type RideRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a RideRequest.
     */
    data: XOR<RideRequestCreateInput, RideRequestUncheckedCreateInput>
  }

  /**
   * RideRequest createMany
   */
  export type RideRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RideRequests.
     */
    data: RideRequestCreateManyInput | RideRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RideRequest createManyAndReturn
   */
  export type RideRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * The data used to create many RideRequests.
     */
    data: RideRequestCreateManyInput | RideRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RideRequest update
   */
  export type RideRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a RideRequest.
     */
    data: XOR<RideRequestUpdateInput, RideRequestUncheckedUpdateInput>
    /**
     * Choose, which RideRequest to update.
     */
    where: RideRequestWhereUniqueInput
  }

  /**
   * RideRequest updateMany
   */
  export type RideRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RideRequests.
     */
    data: XOR<RideRequestUpdateManyMutationInput, RideRequestUncheckedUpdateManyInput>
    /**
     * Filter which RideRequests to update
     */
    where?: RideRequestWhereInput
    /**
     * Limit how many RideRequests to update.
     */
    limit?: number
  }

  /**
   * RideRequest updateManyAndReturn
   */
  export type RideRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * The data used to update RideRequests.
     */
    data: XOR<RideRequestUpdateManyMutationInput, RideRequestUncheckedUpdateManyInput>
    /**
     * Filter which RideRequests to update
     */
    where?: RideRequestWhereInput
    /**
     * Limit how many RideRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RideRequest upsert
   */
  export type RideRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the RideRequest to update in case it exists.
     */
    where: RideRequestWhereUniqueInput
    /**
     * In case the RideRequest found by the `where` argument doesn't exist, create a new RideRequest with this data.
     */
    create: XOR<RideRequestCreateInput, RideRequestUncheckedCreateInput>
    /**
     * In case the RideRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RideRequestUpdateInput, RideRequestUncheckedUpdateInput>
  }

  /**
   * RideRequest delete
   */
  export type RideRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
    /**
     * Filter which RideRequest to delete.
     */
    where: RideRequestWhereUniqueInput
  }

  /**
   * RideRequest deleteMany
   */
  export type RideRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RideRequests to delete
     */
    where?: RideRequestWhereInput
    /**
     * Limit how many RideRequests to delete.
     */
    limit?: number
  }

  /**
   * RideRequest without action
   */
  export type RideRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RideRequest
     */
    select?: RideRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RideRequest
     */
    omit?: RideRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideRequestInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    year: number | null
    capacity: number | null
  }

  export type VehicleSumAggregateOutputType = {
    year: number | null
    capacity: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    driverId: string | null
    make: string | null
    model: string | null
    year: number | null
    plateNumber: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    driverId: string | null
    make: string | null
    model: string | null
    year: number | null
    plateNumber: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    driverId: number
    make: number
    model: number
    year: number
    plateNumber: number
    capacity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    year?: true
    capacity?: true
  }

  export type VehicleSumAggregateInputType = {
    year?: true
    capacity?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    driverId?: true
    make?: true
    model?: true
    year?: true
    plateNumber?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    driverId?: true
    make?: true
    model?: true
    year?: true
    plateNumber?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    driverId?: true
    make?: true
    model?: true
    year?: true
    plateNumber?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    driverId: string
    make: string
    model: string
    year: number
    plateNumber: string
    capacity: number
    createdAt: Date
    updatedAt: Date
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    plateNumber?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    plateNumber?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    plateNumber?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    driverId?: boolean
    make?: boolean
    model?: boolean
    year?: boolean
    plateNumber?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "driverId" | "make" | "model" | "year" | "plateNumber" | "capacity" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      driver: Prisma.$DriverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      driverId: string
      make: string
      model: string
      year: number
      plateNumber: string
      capacity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly driverId: FieldRef<"Vehicle", 'String'>
    readonly make: FieldRef<"Vehicle", 'String'>
    readonly model: FieldRef<"Vehicle", 'String'>
    readonly year: FieldRef<"Vehicle", 'Int'>
    readonly plateNumber: FieldRef<"Vehicle", 'String'>
    readonly capacity: FieldRef<"Vehicle", 'Int'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model DriverVerification
   */

  export type AggregateDriverVerification = {
    _count: DriverVerificationCountAggregateOutputType | null
    _min: DriverVerificationMinAggregateOutputType | null
    _max: DriverVerificationMaxAggregateOutputType | null
  }

  export type DriverVerificationMinAggregateOutputType = {
    id: string | null
    driverId: string | null
    status: $Enums.VerificationStatus | null
    policeVerification: string | null
    backgroundCheck: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverVerificationMaxAggregateOutputType = {
    id: string | null
    driverId: string | null
    status: $Enums.VerificationStatus | null
    policeVerification: string | null
    backgroundCheck: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverVerificationCountAggregateOutputType = {
    id: number
    driverId: number
    status: number
    vehiclePhotos: number
    policeVerification: number
    backgroundCheck: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriverVerificationMinAggregateInputType = {
    id?: true
    driverId?: true
    status?: true
    policeVerification?: true
    backgroundCheck?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverVerificationMaxAggregateInputType = {
    id?: true
    driverId?: true
    status?: true
    policeVerification?: true
    backgroundCheck?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverVerificationCountAggregateInputType = {
    id?: true
    driverId?: true
    status?: true
    vehiclePhotos?: true
    policeVerification?: true
    backgroundCheck?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriverVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverVerification to aggregate.
     */
    where?: DriverVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVerifications to fetch.
     */
    orderBy?: DriverVerificationOrderByWithRelationInput | DriverVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DriverVerifications
    **/
    _count?: true | DriverVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverVerificationMaxAggregateInputType
  }

  export type GetDriverVerificationAggregateType<T extends DriverVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateDriverVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverVerification[P]>
      : GetScalarType<T[P], AggregateDriverVerification[P]>
  }




  export type DriverVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverVerificationWhereInput
    orderBy?: DriverVerificationOrderByWithAggregationInput | DriverVerificationOrderByWithAggregationInput[]
    by: DriverVerificationScalarFieldEnum[] | DriverVerificationScalarFieldEnum
    having?: DriverVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverVerificationCountAggregateInputType | true
    _min?: DriverVerificationMinAggregateInputType
    _max?: DriverVerificationMaxAggregateInputType
  }

  export type DriverVerificationGroupByOutputType = {
    id: string
    driverId: string
    status: $Enums.VerificationStatus
    vehiclePhotos: string[]
    policeVerification: string | null
    backgroundCheck: string | null
    createdAt: Date
    updatedAt: Date
    _count: DriverVerificationCountAggregateOutputType | null
    _min: DriverVerificationMinAggregateOutputType | null
    _max: DriverVerificationMaxAggregateOutputType | null
  }

  type GetDriverVerificationGroupByPayload<T extends DriverVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], DriverVerificationGroupByOutputType[P]>
        }
      >
    >


  export type DriverVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    status?: boolean
    vehiclePhotos?: boolean
    policeVerification?: boolean
    backgroundCheck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documents?: boolean | DriverVerification$documentsArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    _count?: boolean | DriverVerificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverVerification"]>

  export type DriverVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    status?: boolean
    vehiclePhotos?: boolean
    policeVerification?: boolean
    backgroundCheck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverVerification"]>

  export type DriverVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    status?: boolean
    vehiclePhotos?: boolean
    policeVerification?: boolean
    backgroundCheck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driverVerification"]>

  export type DriverVerificationSelectScalar = {
    id?: boolean
    driverId?: boolean
    status?: boolean
    vehiclePhotos?: boolean
    policeVerification?: boolean
    backgroundCheck?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DriverVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "driverId" | "status" | "vehiclePhotos" | "policeVerification" | "backgroundCheck" | "createdAt" | "updatedAt", ExtArgs["result"]["driverVerification"]>
  export type DriverVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | DriverVerification$documentsArgs<ExtArgs>
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    _count?: boolean | DriverVerificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }
  export type DriverVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
  }

  export type $DriverVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DriverVerification"
    objects: {
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      driver: Prisma.$DriverPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      driverId: string
      status: $Enums.VerificationStatus
      vehiclePhotos: string[]
      policeVerification: string | null
      backgroundCheck: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driverVerification"]>
    composites: {}
  }

  type DriverVerificationGetPayload<S extends boolean | null | undefined | DriverVerificationDefaultArgs> = $Result.GetResult<Prisma.$DriverVerificationPayload, S>

  type DriverVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverVerificationCountAggregateInputType | true
    }

  export interface DriverVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DriverVerification'], meta: { name: 'DriverVerification' } }
    /**
     * Find zero or one DriverVerification that matches the filter.
     * @param {DriverVerificationFindUniqueArgs} args - Arguments to find a DriverVerification
     * @example
     * // Get one DriverVerification
     * const driverVerification = await prisma.driverVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverVerificationFindUniqueArgs>(args: SelectSubset<T, DriverVerificationFindUniqueArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DriverVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverVerificationFindUniqueOrThrowArgs} args - Arguments to find a DriverVerification
     * @example
     * // Get one DriverVerification
     * const driverVerification = await prisma.driverVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVerificationFindFirstArgs} args - Arguments to find a DriverVerification
     * @example
     * // Get one DriverVerification
     * const driverVerification = await prisma.driverVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverVerificationFindFirstArgs>(args?: SelectSubset<T, DriverVerificationFindFirstArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DriverVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVerificationFindFirstOrThrowArgs} args - Arguments to find a DriverVerification
     * @example
     * // Get one DriverVerification
     * const driverVerification = await prisma.driverVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DriverVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverVerifications
     * const driverVerifications = await prisma.driverVerification.findMany()
     * 
     * // Get first 10 DriverVerifications
     * const driverVerifications = await prisma.driverVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverVerificationWithIdOnly = await prisma.driverVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverVerificationFindManyArgs>(args?: SelectSubset<T, DriverVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DriverVerification.
     * @param {DriverVerificationCreateArgs} args - Arguments to create a DriverVerification.
     * @example
     * // Create one DriverVerification
     * const DriverVerification = await prisma.driverVerification.create({
     *   data: {
     *     // ... data to create a DriverVerification
     *   }
     * })
     * 
     */
    create<T extends DriverVerificationCreateArgs>(args: SelectSubset<T, DriverVerificationCreateArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DriverVerifications.
     * @param {DriverVerificationCreateManyArgs} args - Arguments to create many DriverVerifications.
     * @example
     * // Create many DriverVerifications
     * const driverVerification = await prisma.driverVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverVerificationCreateManyArgs>(args?: SelectSubset<T, DriverVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DriverVerifications and returns the data saved in the database.
     * @param {DriverVerificationCreateManyAndReturnArgs} args - Arguments to create many DriverVerifications.
     * @example
     * // Create many DriverVerifications
     * const driverVerification = await prisma.driverVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DriverVerifications and only return the `id`
     * const driverVerificationWithIdOnly = await prisma.driverVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DriverVerification.
     * @param {DriverVerificationDeleteArgs} args - Arguments to delete one DriverVerification.
     * @example
     * // Delete one DriverVerification
     * const DriverVerification = await prisma.driverVerification.delete({
     *   where: {
     *     // ... filter to delete one DriverVerification
     *   }
     * })
     * 
     */
    delete<T extends DriverVerificationDeleteArgs>(args: SelectSubset<T, DriverVerificationDeleteArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DriverVerification.
     * @param {DriverVerificationUpdateArgs} args - Arguments to update one DriverVerification.
     * @example
     * // Update one DriverVerification
     * const driverVerification = await prisma.driverVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverVerificationUpdateArgs>(args: SelectSubset<T, DriverVerificationUpdateArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DriverVerifications.
     * @param {DriverVerificationDeleteManyArgs} args - Arguments to filter DriverVerifications to delete.
     * @example
     * // Delete a few DriverVerifications
     * const { count } = await prisma.driverVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverVerificationDeleteManyArgs>(args?: SelectSubset<T, DriverVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverVerifications
     * const driverVerification = await prisma.driverVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverVerificationUpdateManyArgs>(args: SelectSubset<T, DriverVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DriverVerifications and returns the data updated in the database.
     * @param {DriverVerificationUpdateManyAndReturnArgs} args - Arguments to update many DriverVerifications.
     * @example
     * // Update many DriverVerifications
     * const driverVerification = await prisma.driverVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DriverVerifications and only return the `id`
     * const driverVerificationWithIdOnly = await prisma.driverVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DriverVerification.
     * @param {DriverVerificationUpsertArgs} args - Arguments to update or create a DriverVerification.
     * @example
     * // Update or create a DriverVerification
     * const driverVerification = await prisma.driverVerification.upsert({
     *   create: {
     *     // ... data to create a DriverVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverVerification we want to update
     *   }
     * })
     */
    upsert<T extends DriverVerificationUpsertArgs>(args: SelectSubset<T, DriverVerificationUpsertArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DriverVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVerificationCountArgs} args - Arguments to filter DriverVerifications to count.
     * @example
     * // Count the number of DriverVerifications
     * const count = await prisma.driverVerification.count({
     *   where: {
     *     // ... the filter for the DriverVerifications we want to count
     *   }
     * })
    **/
    count<T extends DriverVerificationCountArgs>(
      args?: Subset<T, DriverVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DriverVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverVerificationAggregateArgs>(args: Subset<T, DriverVerificationAggregateArgs>): Prisma.PrismaPromise<GetDriverVerificationAggregateType<T>>

    /**
     * Group by DriverVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverVerificationGroupByArgs['orderBy'] }
        : { orderBy?: DriverVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DriverVerification model
   */
  readonly fields: DriverVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends DriverVerification$documentsArgs<ExtArgs> = {}>(args?: Subset<T, DriverVerification$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DriverVerification model
   */
  interface DriverVerificationFieldRefs {
    readonly id: FieldRef<"DriverVerification", 'String'>
    readonly driverId: FieldRef<"DriverVerification", 'String'>
    readonly status: FieldRef<"DriverVerification", 'VerificationStatus'>
    readonly vehiclePhotos: FieldRef<"DriverVerification", 'String[]'>
    readonly policeVerification: FieldRef<"DriverVerification", 'String'>
    readonly backgroundCheck: FieldRef<"DriverVerification", 'String'>
    readonly createdAt: FieldRef<"DriverVerification", 'DateTime'>
    readonly updatedAt: FieldRef<"DriverVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DriverVerification findUnique
   */
  export type DriverVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DriverVerification to fetch.
     */
    where: DriverVerificationWhereUniqueInput
  }

  /**
   * DriverVerification findUniqueOrThrow
   */
  export type DriverVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DriverVerification to fetch.
     */
    where: DriverVerificationWhereUniqueInput
  }

  /**
   * DriverVerification findFirst
   */
  export type DriverVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DriverVerification to fetch.
     */
    where?: DriverVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVerifications to fetch.
     */
    orderBy?: DriverVerificationOrderByWithRelationInput | DriverVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverVerifications.
     */
    cursor?: DriverVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverVerifications.
     */
    distinct?: DriverVerificationScalarFieldEnum | DriverVerificationScalarFieldEnum[]
  }

  /**
   * DriverVerification findFirstOrThrow
   */
  export type DriverVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DriverVerification to fetch.
     */
    where?: DriverVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVerifications to fetch.
     */
    orderBy?: DriverVerificationOrderByWithRelationInput | DriverVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DriverVerifications.
     */
    cursor?: DriverVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DriverVerifications.
     */
    distinct?: DriverVerificationScalarFieldEnum | DriverVerificationScalarFieldEnum[]
  }

  /**
   * DriverVerification findMany
   */
  export type DriverVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * Filter, which DriverVerifications to fetch.
     */
    where?: DriverVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DriverVerifications to fetch.
     */
    orderBy?: DriverVerificationOrderByWithRelationInput | DriverVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DriverVerifications.
     */
    cursor?: DriverVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DriverVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DriverVerifications.
     */
    skip?: number
    distinct?: DriverVerificationScalarFieldEnum | DriverVerificationScalarFieldEnum[]
  }

  /**
   * DriverVerification create
   */
  export type DriverVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a DriverVerification.
     */
    data: XOR<DriverVerificationCreateInput, DriverVerificationUncheckedCreateInput>
  }

  /**
   * DriverVerification createMany
   */
  export type DriverVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DriverVerifications.
     */
    data: DriverVerificationCreateManyInput | DriverVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DriverVerification createManyAndReturn
   */
  export type DriverVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many DriverVerifications.
     */
    data: DriverVerificationCreateManyInput | DriverVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverVerification update
   */
  export type DriverVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a DriverVerification.
     */
    data: XOR<DriverVerificationUpdateInput, DriverVerificationUncheckedUpdateInput>
    /**
     * Choose, which DriverVerification to update.
     */
    where: DriverVerificationWhereUniqueInput
  }

  /**
   * DriverVerification updateMany
   */
  export type DriverVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DriverVerifications.
     */
    data: XOR<DriverVerificationUpdateManyMutationInput, DriverVerificationUncheckedUpdateManyInput>
    /**
     * Filter which DriverVerifications to update
     */
    where?: DriverVerificationWhereInput
    /**
     * Limit how many DriverVerifications to update.
     */
    limit?: number
  }

  /**
   * DriverVerification updateManyAndReturn
   */
  export type DriverVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * The data used to update DriverVerifications.
     */
    data: XOR<DriverVerificationUpdateManyMutationInput, DriverVerificationUncheckedUpdateManyInput>
    /**
     * Filter which DriverVerifications to update
     */
    where?: DriverVerificationWhereInput
    /**
     * Limit how many DriverVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DriverVerification upsert
   */
  export type DriverVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the DriverVerification to update in case it exists.
     */
    where: DriverVerificationWhereUniqueInput
    /**
     * In case the DriverVerification found by the `where` argument doesn't exist, create a new DriverVerification with this data.
     */
    create: XOR<DriverVerificationCreateInput, DriverVerificationUncheckedCreateInput>
    /**
     * In case the DriverVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverVerificationUpdateInput, DriverVerificationUncheckedUpdateInput>
  }

  /**
   * DriverVerification delete
   */
  export type DriverVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
    /**
     * Filter which DriverVerification to delete.
     */
    where: DriverVerificationWhereUniqueInput
  }

  /**
   * DriverVerification deleteMany
   */
  export type DriverVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DriverVerifications to delete
     */
    where?: DriverVerificationWhereInput
    /**
     * Limit how many DriverVerifications to delete.
     */
    limit?: number
  }

  /**
   * DriverVerification.documents
   */
  export type DriverVerification$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * DriverVerification without action
   */
  export type DriverVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverVerification
     */
    select?: DriverVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DriverVerification
     */
    omit?: DriverVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverVerificationInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    number: string | null
    expiryDate: Date | null
    fileUrl: string | null
    verificationId: string | null
    status: $Enums.VerificationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    type: $Enums.DocumentType | null
    number: string | null
    expiryDate: Date | null
    fileUrl: string | null
    verificationId: string | null
    status: $Enums.VerificationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    type: number
    number: number
    expiryDate: number
    fileUrl: number
    verificationId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    type?: true
    number?: true
    expiryDate?: true
    fileUrl?: true
    verificationId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    type?: true
    number?: true
    expiryDate?: true
    fileUrl?: true
    verificationId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    type?: true
    number?: true
    expiryDate?: true
    fileUrl?: true
    verificationId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    type: $Enums.DocumentType
    number: string
    expiryDate: Date | null
    fileUrl: string
    verificationId: string
    status: $Enums.VerificationStatus
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    number?: boolean
    expiryDate?: boolean
    fileUrl?: boolean
    verificationId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verification?: boolean | DriverVerificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    number?: boolean
    expiryDate?: boolean
    fileUrl?: boolean
    verificationId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verification?: boolean | DriverVerificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    number?: boolean
    expiryDate?: boolean
    fileUrl?: boolean
    verificationId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verification?: boolean | DriverVerificationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    type?: boolean
    number?: boolean
    expiryDate?: boolean
    fileUrl?: boolean
    verificationId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "number" | "expiryDate" | "fileUrl" | "verificationId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verification?: boolean | DriverVerificationDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verification?: boolean | DriverVerificationDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    verification?: boolean | DriverVerificationDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      verification: Prisma.$DriverVerificationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.DocumentType
      number: string
      expiryDate: Date | null
      fileUrl: string
      verificationId: string
      status: $Enums.VerificationStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    verification<T extends DriverVerificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverVerificationDefaultArgs<ExtArgs>>): Prisma__DriverVerificationClient<$Result.GetResult<Prisma.$DriverVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly number: FieldRef<"Document", 'String'>
    readonly expiryDate: FieldRef<"Document", 'DateTime'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly verificationId: FieldRef<"Document", 'String'>
    readonly status: FieldRef<"Document", 'VerificationStatus'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: number | null
  }

  export type WalletSumAggregateOutputType = {
    balance: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    balance: number | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    balance: number | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    balance: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    balance?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    balance?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    balance?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    balance: number
    parentId: string
    createdAt: Date
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    balance?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    balance?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "balance" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["wallet"]>
  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }
  export type WalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      parent: Prisma.$ParentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      balance: number
      parentId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets and returns the data updated in the database.
     * @param {WalletUpdateManyAndReturnArgs} args - Arguments to update many Wallets.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Wallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'Float'>
    readonly parentId: FieldRef<"Wallet", 'String'>
    readonly createdAt: FieldRef<"Wallet", 'DateTime'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
  }

  /**
   * Wallet updateManyAndReturn
   */
  export type WalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
    /**
     * Limit how many Wallets to delete.
     */
    limit?: number
  }

  /**
   * Wallet.transactions
   */
  export type Wallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wallet
     */
    omit?: WalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: number | null
    type: $Enums.TransactionType | null
    status: $Enums.PaymentStatus | null
    description: string | null
    rideId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: number | null
    type: $Enums.TransactionType | null
    status: $Enums.PaymentStatus | null
    description: string | null
    rideId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    walletId: number
    amount: number
    type: number
    status: number
    description: number
    rideId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    status?: true
    description?: true
    rideId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    status?: true
    description?: true
    rideId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    status?: true
    description?: true
    rideId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    walletId: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description: string | null
    rideId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    rideId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ride?: boolean | Transaction$rideArgs<ExtArgs>
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    rideId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ride?: boolean | Transaction$rideArgs<ExtArgs>
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    rideId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ride?: boolean | Transaction$rideArgs<ExtArgs>
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    rideId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletId" | "amount" | "type" | "status" | "description" | "rideId" | "createdAt" | "updatedAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | Transaction$rideArgs<ExtArgs>
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | Transaction$rideArgs<ExtArgs>
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ride?: boolean | Transaction$rideArgs<ExtArgs>
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      ride: Prisma.$RidePayload<ExtArgs> | null
      wallet: Prisma.$WalletPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      amount: number
      type: $Enums.TransactionType
      status: $Enums.PaymentStatus
      description: string | null
      rideId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ride<T extends Transaction$rideArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$rideArgs<ExtArgs>>): Prisma__RideClient<$Result.GetResult<Prisma.$RidePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly walletId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly status: FieldRef<"Transaction", 'PaymentStatus'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly rideId: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.ride
   */
  export type Transaction$rideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ride
     */
    select?: RideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ride
     */
    omit?: RideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RideInclude<ExtArgs> | null
    where?: RideWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TeenBuddy
   */

  export type AggregateTeenBuddy = {
    _count: TeenBuddyCountAggregateOutputType | null
    _min: TeenBuddyMinAggregateOutputType | null
    _max: TeenBuddyMaxAggregateOutputType | null
  }

  export type TeenBuddyMinAggregateOutputType = {
    id: string | null
    teenId: string | null
    buddyId: string | null
    status: $Enums.BuddyStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeenBuddyMaxAggregateOutputType = {
    id: string | null
    teenId: string | null
    buddyId: string | null
    status: $Enums.BuddyStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeenBuddyCountAggregateOutputType = {
    id: number
    teenId: number
    buddyId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeenBuddyMinAggregateInputType = {
    id?: true
    teenId?: true
    buddyId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeenBuddyMaxAggregateInputType = {
    id?: true
    teenId?: true
    buddyId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeenBuddyCountAggregateInputType = {
    id?: true
    teenId?: true
    buddyId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeenBuddyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeenBuddy to aggregate.
     */
    where?: TeenBuddyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeenBuddies to fetch.
     */
    orderBy?: TeenBuddyOrderByWithRelationInput | TeenBuddyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeenBuddyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeenBuddies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeenBuddies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeenBuddies
    **/
    _count?: true | TeenBuddyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeenBuddyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeenBuddyMaxAggregateInputType
  }

  export type GetTeenBuddyAggregateType<T extends TeenBuddyAggregateArgs> = {
        [P in keyof T & keyof AggregateTeenBuddy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeenBuddy[P]>
      : GetScalarType<T[P], AggregateTeenBuddy[P]>
  }




  export type TeenBuddyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeenBuddyWhereInput
    orderBy?: TeenBuddyOrderByWithAggregationInput | TeenBuddyOrderByWithAggregationInput[]
    by: TeenBuddyScalarFieldEnum[] | TeenBuddyScalarFieldEnum
    having?: TeenBuddyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeenBuddyCountAggregateInputType | true
    _min?: TeenBuddyMinAggregateInputType
    _max?: TeenBuddyMaxAggregateInputType
  }

  export type TeenBuddyGroupByOutputType = {
    id: string
    teenId: string
    buddyId: string
    status: $Enums.BuddyStatus
    createdAt: Date
    updatedAt: Date
    _count: TeenBuddyCountAggregateOutputType | null
    _min: TeenBuddyMinAggregateOutputType | null
    _max: TeenBuddyMaxAggregateOutputType | null
  }

  type GetTeenBuddyGroupByPayload<T extends TeenBuddyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeenBuddyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeenBuddyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeenBuddyGroupByOutputType[P]>
            : GetScalarType<T[P], TeenBuddyGroupByOutputType[P]>
        }
      >
    >


  export type TeenBuddySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teenId?: boolean
    buddyId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buddy?: boolean | TeenDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teenBuddy"]>

  export type TeenBuddySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teenId?: boolean
    buddyId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buddy?: boolean | TeenDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teenBuddy"]>

  export type TeenBuddySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teenId?: boolean
    buddyId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    buddy?: boolean | TeenDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teenBuddy"]>

  export type TeenBuddySelectScalar = {
    id?: boolean
    teenId?: boolean
    buddyId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeenBuddyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teenId" | "buddyId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["teenBuddy"]>
  export type TeenBuddyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buddy?: boolean | TeenDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }
  export type TeenBuddyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buddy?: boolean | TeenDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }
  export type TeenBuddyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buddy?: boolean | TeenDefaultArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }

  export type $TeenBuddyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeenBuddy"
    objects: {
      buddy: Prisma.$TeenPayload<ExtArgs>
      teen: Prisma.$TeenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teenId: string
      buddyId: string
      status: $Enums.BuddyStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teenBuddy"]>
    composites: {}
  }

  type TeenBuddyGetPayload<S extends boolean | null | undefined | TeenBuddyDefaultArgs> = $Result.GetResult<Prisma.$TeenBuddyPayload, S>

  type TeenBuddyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeenBuddyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeenBuddyCountAggregateInputType | true
    }

  export interface TeenBuddyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeenBuddy'], meta: { name: 'TeenBuddy' } }
    /**
     * Find zero or one TeenBuddy that matches the filter.
     * @param {TeenBuddyFindUniqueArgs} args - Arguments to find a TeenBuddy
     * @example
     * // Get one TeenBuddy
     * const teenBuddy = await prisma.teenBuddy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeenBuddyFindUniqueArgs>(args: SelectSubset<T, TeenBuddyFindUniqueArgs<ExtArgs>>): Prisma__TeenBuddyClient<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeenBuddy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeenBuddyFindUniqueOrThrowArgs} args - Arguments to find a TeenBuddy
     * @example
     * // Get one TeenBuddy
     * const teenBuddy = await prisma.teenBuddy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeenBuddyFindUniqueOrThrowArgs>(args: SelectSubset<T, TeenBuddyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeenBuddyClient<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeenBuddy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenBuddyFindFirstArgs} args - Arguments to find a TeenBuddy
     * @example
     * // Get one TeenBuddy
     * const teenBuddy = await prisma.teenBuddy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeenBuddyFindFirstArgs>(args?: SelectSubset<T, TeenBuddyFindFirstArgs<ExtArgs>>): Prisma__TeenBuddyClient<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeenBuddy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenBuddyFindFirstOrThrowArgs} args - Arguments to find a TeenBuddy
     * @example
     * // Get one TeenBuddy
     * const teenBuddy = await prisma.teenBuddy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeenBuddyFindFirstOrThrowArgs>(args?: SelectSubset<T, TeenBuddyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeenBuddyClient<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeenBuddies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenBuddyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeenBuddies
     * const teenBuddies = await prisma.teenBuddy.findMany()
     * 
     * // Get first 10 TeenBuddies
     * const teenBuddies = await prisma.teenBuddy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teenBuddyWithIdOnly = await prisma.teenBuddy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeenBuddyFindManyArgs>(args?: SelectSubset<T, TeenBuddyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeenBuddy.
     * @param {TeenBuddyCreateArgs} args - Arguments to create a TeenBuddy.
     * @example
     * // Create one TeenBuddy
     * const TeenBuddy = await prisma.teenBuddy.create({
     *   data: {
     *     // ... data to create a TeenBuddy
     *   }
     * })
     * 
     */
    create<T extends TeenBuddyCreateArgs>(args: SelectSubset<T, TeenBuddyCreateArgs<ExtArgs>>): Prisma__TeenBuddyClient<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeenBuddies.
     * @param {TeenBuddyCreateManyArgs} args - Arguments to create many TeenBuddies.
     * @example
     * // Create many TeenBuddies
     * const teenBuddy = await prisma.teenBuddy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeenBuddyCreateManyArgs>(args?: SelectSubset<T, TeenBuddyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeenBuddies and returns the data saved in the database.
     * @param {TeenBuddyCreateManyAndReturnArgs} args - Arguments to create many TeenBuddies.
     * @example
     * // Create many TeenBuddies
     * const teenBuddy = await prisma.teenBuddy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeenBuddies and only return the `id`
     * const teenBuddyWithIdOnly = await prisma.teenBuddy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeenBuddyCreateManyAndReturnArgs>(args?: SelectSubset<T, TeenBuddyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeenBuddy.
     * @param {TeenBuddyDeleteArgs} args - Arguments to delete one TeenBuddy.
     * @example
     * // Delete one TeenBuddy
     * const TeenBuddy = await prisma.teenBuddy.delete({
     *   where: {
     *     // ... filter to delete one TeenBuddy
     *   }
     * })
     * 
     */
    delete<T extends TeenBuddyDeleteArgs>(args: SelectSubset<T, TeenBuddyDeleteArgs<ExtArgs>>): Prisma__TeenBuddyClient<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeenBuddy.
     * @param {TeenBuddyUpdateArgs} args - Arguments to update one TeenBuddy.
     * @example
     * // Update one TeenBuddy
     * const teenBuddy = await prisma.teenBuddy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeenBuddyUpdateArgs>(args: SelectSubset<T, TeenBuddyUpdateArgs<ExtArgs>>): Prisma__TeenBuddyClient<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeenBuddies.
     * @param {TeenBuddyDeleteManyArgs} args - Arguments to filter TeenBuddies to delete.
     * @example
     * // Delete a few TeenBuddies
     * const { count } = await prisma.teenBuddy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeenBuddyDeleteManyArgs>(args?: SelectSubset<T, TeenBuddyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeenBuddies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenBuddyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeenBuddies
     * const teenBuddy = await prisma.teenBuddy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeenBuddyUpdateManyArgs>(args: SelectSubset<T, TeenBuddyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeenBuddies and returns the data updated in the database.
     * @param {TeenBuddyUpdateManyAndReturnArgs} args - Arguments to update many TeenBuddies.
     * @example
     * // Update many TeenBuddies
     * const teenBuddy = await prisma.teenBuddy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeenBuddies and only return the `id`
     * const teenBuddyWithIdOnly = await prisma.teenBuddy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeenBuddyUpdateManyAndReturnArgs>(args: SelectSubset<T, TeenBuddyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeenBuddy.
     * @param {TeenBuddyUpsertArgs} args - Arguments to update or create a TeenBuddy.
     * @example
     * // Update or create a TeenBuddy
     * const teenBuddy = await prisma.teenBuddy.upsert({
     *   create: {
     *     // ... data to create a TeenBuddy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeenBuddy we want to update
     *   }
     * })
     */
    upsert<T extends TeenBuddyUpsertArgs>(args: SelectSubset<T, TeenBuddyUpsertArgs<ExtArgs>>): Prisma__TeenBuddyClient<$Result.GetResult<Prisma.$TeenBuddyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeenBuddies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenBuddyCountArgs} args - Arguments to filter TeenBuddies to count.
     * @example
     * // Count the number of TeenBuddies
     * const count = await prisma.teenBuddy.count({
     *   where: {
     *     // ... the filter for the TeenBuddies we want to count
     *   }
     * })
    **/
    count<T extends TeenBuddyCountArgs>(
      args?: Subset<T, TeenBuddyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeenBuddyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeenBuddy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenBuddyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeenBuddyAggregateArgs>(args: Subset<T, TeenBuddyAggregateArgs>): Prisma.PrismaPromise<GetTeenBuddyAggregateType<T>>

    /**
     * Group by TeenBuddy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenBuddyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeenBuddyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeenBuddyGroupByArgs['orderBy'] }
        : { orderBy?: TeenBuddyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeenBuddyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeenBuddyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeenBuddy model
   */
  readonly fields: TeenBuddyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeenBuddy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeenBuddyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    buddy<T extends TeenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeenDefaultArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teen<T extends TeenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeenDefaultArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeenBuddy model
   */
  interface TeenBuddyFieldRefs {
    readonly id: FieldRef<"TeenBuddy", 'String'>
    readonly teenId: FieldRef<"TeenBuddy", 'String'>
    readonly buddyId: FieldRef<"TeenBuddy", 'String'>
    readonly status: FieldRef<"TeenBuddy", 'BuddyStatus'>
    readonly createdAt: FieldRef<"TeenBuddy", 'DateTime'>
    readonly updatedAt: FieldRef<"TeenBuddy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeenBuddy findUnique
   */
  export type TeenBuddyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * Filter, which TeenBuddy to fetch.
     */
    where: TeenBuddyWhereUniqueInput
  }

  /**
   * TeenBuddy findUniqueOrThrow
   */
  export type TeenBuddyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * Filter, which TeenBuddy to fetch.
     */
    where: TeenBuddyWhereUniqueInput
  }

  /**
   * TeenBuddy findFirst
   */
  export type TeenBuddyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * Filter, which TeenBuddy to fetch.
     */
    where?: TeenBuddyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeenBuddies to fetch.
     */
    orderBy?: TeenBuddyOrderByWithRelationInput | TeenBuddyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeenBuddies.
     */
    cursor?: TeenBuddyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeenBuddies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeenBuddies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeenBuddies.
     */
    distinct?: TeenBuddyScalarFieldEnum | TeenBuddyScalarFieldEnum[]
  }

  /**
   * TeenBuddy findFirstOrThrow
   */
  export type TeenBuddyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * Filter, which TeenBuddy to fetch.
     */
    where?: TeenBuddyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeenBuddies to fetch.
     */
    orderBy?: TeenBuddyOrderByWithRelationInput | TeenBuddyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeenBuddies.
     */
    cursor?: TeenBuddyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeenBuddies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeenBuddies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeenBuddies.
     */
    distinct?: TeenBuddyScalarFieldEnum | TeenBuddyScalarFieldEnum[]
  }

  /**
   * TeenBuddy findMany
   */
  export type TeenBuddyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * Filter, which TeenBuddies to fetch.
     */
    where?: TeenBuddyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeenBuddies to fetch.
     */
    orderBy?: TeenBuddyOrderByWithRelationInput | TeenBuddyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeenBuddies.
     */
    cursor?: TeenBuddyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeenBuddies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeenBuddies.
     */
    skip?: number
    distinct?: TeenBuddyScalarFieldEnum | TeenBuddyScalarFieldEnum[]
  }

  /**
   * TeenBuddy create
   */
  export type TeenBuddyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * The data needed to create a TeenBuddy.
     */
    data: XOR<TeenBuddyCreateInput, TeenBuddyUncheckedCreateInput>
  }

  /**
   * TeenBuddy createMany
   */
  export type TeenBuddyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeenBuddies.
     */
    data: TeenBuddyCreateManyInput | TeenBuddyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeenBuddy createManyAndReturn
   */
  export type TeenBuddyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * The data used to create many TeenBuddies.
     */
    data: TeenBuddyCreateManyInput | TeenBuddyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeenBuddy update
   */
  export type TeenBuddyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * The data needed to update a TeenBuddy.
     */
    data: XOR<TeenBuddyUpdateInput, TeenBuddyUncheckedUpdateInput>
    /**
     * Choose, which TeenBuddy to update.
     */
    where: TeenBuddyWhereUniqueInput
  }

  /**
   * TeenBuddy updateMany
   */
  export type TeenBuddyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeenBuddies.
     */
    data: XOR<TeenBuddyUpdateManyMutationInput, TeenBuddyUncheckedUpdateManyInput>
    /**
     * Filter which TeenBuddies to update
     */
    where?: TeenBuddyWhereInput
    /**
     * Limit how many TeenBuddies to update.
     */
    limit?: number
  }

  /**
   * TeenBuddy updateManyAndReturn
   */
  export type TeenBuddyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * The data used to update TeenBuddies.
     */
    data: XOR<TeenBuddyUpdateManyMutationInput, TeenBuddyUncheckedUpdateManyInput>
    /**
     * Filter which TeenBuddies to update
     */
    where?: TeenBuddyWhereInput
    /**
     * Limit how many TeenBuddies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeenBuddy upsert
   */
  export type TeenBuddyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * The filter to search for the TeenBuddy to update in case it exists.
     */
    where: TeenBuddyWhereUniqueInput
    /**
     * In case the TeenBuddy found by the `where` argument doesn't exist, create a new TeenBuddy with this data.
     */
    create: XOR<TeenBuddyCreateInput, TeenBuddyUncheckedCreateInput>
    /**
     * In case the TeenBuddy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeenBuddyUpdateInput, TeenBuddyUncheckedUpdateInput>
  }

  /**
   * TeenBuddy delete
   */
  export type TeenBuddyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
    /**
     * Filter which TeenBuddy to delete.
     */
    where: TeenBuddyWhereUniqueInput
  }

  /**
   * TeenBuddy deleteMany
   */
  export type TeenBuddyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeenBuddies to delete
     */
    where?: TeenBuddyWhereInput
    /**
     * Limit how many TeenBuddies to delete.
     */
    limit?: number
  }

  /**
   * TeenBuddy without action
   */
  export type TeenBuddyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenBuddy
     */
    select?: TeenBuddySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenBuddy
     */
    omit?: TeenBuddyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenBuddyInclude<ExtArgs> | null
  }


  /**
   * Model TeenRewards
   */

  export type AggregateTeenRewards = {
    _count: TeenRewardsCountAggregateOutputType | null
    _avg: TeenRewardsAvgAggregateOutputType | null
    _sum: TeenRewardsSumAggregateOutputType | null
    _min: TeenRewardsMinAggregateOutputType | null
    _max: TeenRewardsMaxAggregateOutputType | null
  }

  export type TeenRewardsAvgAggregateOutputType = {
    points: number | null
    level: number | null
  }

  export type TeenRewardsSumAggregateOutputType = {
    points: number | null
    level: number | null
  }

  export type TeenRewardsMinAggregateOutputType = {
    id: string | null
    teenId: string | null
    points: number | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeenRewardsMaxAggregateOutputType = {
    id: string | null
    teenId: string | null
    points: number | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeenRewardsCountAggregateOutputType = {
    id: number
    teenId: number
    points: number
    level: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeenRewardsAvgAggregateInputType = {
    points?: true
    level?: true
  }

  export type TeenRewardsSumAggregateInputType = {
    points?: true
    level?: true
  }

  export type TeenRewardsMinAggregateInputType = {
    id?: true
    teenId?: true
    points?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeenRewardsMaxAggregateInputType = {
    id?: true
    teenId?: true
    points?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeenRewardsCountAggregateInputType = {
    id?: true
    teenId?: true
    points?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeenRewardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeenRewards to aggregate.
     */
    where?: TeenRewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeenRewards to fetch.
     */
    orderBy?: TeenRewardsOrderByWithRelationInput | TeenRewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeenRewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeenRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeenRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeenRewards
    **/
    _count?: true | TeenRewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeenRewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeenRewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeenRewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeenRewardsMaxAggregateInputType
  }

  export type GetTeenRewardsAggregateType<T extends TeenRewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateTeenRewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeenRewards[P]>
      : GetScalarType<T[P], AggregateTeenRewards[P]>
  }




  export type TeenRewardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeenRewardsWhereInput
    orderBy?: TeenRewardsOrderByWithAggregationInput | TeenRewardsOrderByWithAggregationInput[]
    by: TeenRewardsScalarFieldEnum[] | TeenRewardsScalarFieldEnum
    having?: TeenRewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeenRewardsCountAggregateInputType | true
    _avg?: TeenRewardsAvgAggregateInputType
    _sum?: TeenRewardsSumAggregateInputType
    _min?: TeenRewardsMinAggregateInputType
    _max?: TeenRewardsMaxAggregateInputType
  }

  export type TeenRewardsGroupByOutputType = {
    id: string
    teenId: string
    points: number
    level: number
    createdAt: Date
    updatedAt: Date
    _count: TeenRewardsCountAggregateOutputType | null
    _avg: TeenRewardsAvgAggregateOutputType | null
    _sum: TeenRewardsSumAggregateOutputType | null
    _min: TeenRewardsMinAggregateOutputType | null
    _max: TeenRewardsMaxAggregateOutputType | null
  }

  type GetTeenRewardsGroupByPayload<T extends TeenRewardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeenRewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeenRewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeenRewardsGroupByOutputType[P]>
            : GetScalarType<T[P], TeenRewardsGroupByOutputType[P]>
        }
      >
    >


  export type TeenRewardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teenId?: boolean
    points?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    achievements?: boolean | TeenRewards$achievementsArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
    _count?: boolean | TeenRewardsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teenRewards"]>

  export type TeenRewardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teenId?: boolean
    points?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teenRewards"]>

  export type TeenRewardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teenId?: boolean
    points?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teenRewards"]>

  export type TeenRewardsSelectScalar = {
    id?: boolean
    teenId?: boolean
    points?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeenRewardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teenId" | "points" | "level" | "createdAt" | "updatedAt", ExtArgs["result"]["teenRewards"]>
  export type TeenRewardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievements?: boolean | TeenRewards$achievementsArgs<ExtArgs>
    teen?: boolean | TeenDefaultArgs<ExtArgs>
    _count?: boolean | TeenRewardsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeenRewardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }
  export type TeenRewardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teen?: boolean | TeenDefaultArgs<ExtArgs>
  }

  export type $TeenRewardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeenRewards"
    objects: {
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      teen: Prisma.$TeenPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teenId: string
      points: number
      level: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teenRewards"]>
    composites: {}
  }

  type TeenRewardsGetPayload<S extends boolean | null | undefined | TeenRewardsDefaultArgs> = $Result.GetResult<Prisma.$TeenRewardsPayload, S>

  type TeenRewardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeenRewardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeenRewardsCountAggregateInputType | true
    }

  export interface TeenRewardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeenRewards'], meta: { name: 'TeenRewards' } }
    /**
     * Find zero or one TeenRewards that matches the filter.
     * @param {TeenRewardsFindUniqueArgs} args - Arguments to find a TeenRewards
     * @example
     * // Get one TeenRewards
     * const teenRewards = await prisma.teenRewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeenRewardsFindUniqueArgs>(args: SelectSubset<T, TeenRewardsFindUniqueArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeenRewards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeenRewardsFindUniqueOrThrowArgs} args - Arguments to find a TeenRewards
     * @example
     * // Get one TeenRewards
     * const teenRewards = await prisma.teenRewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeenRewardsFindUniqueOrThrowArgs>(args: SelectSubset<T, TeenRewardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeenRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenRewardsFindFirstArgs} args - Arguments to find a TeenRewards
     * @example
     * // Get one TeenRewards
     * const teenRewards = await prisma.teenRewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeenRewardsFindFirstArgs>(args?: SelectSubset<T, TeenRewardsFindFirstArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeenRewards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenRewardsFindFirstOrThrowArgs} args - Arguments to find a TeenRewards
     * @example
     * // Get one TeenRewards
     * const teenRewards = await prisma.teenRewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeenRewardsFindFirstOrThrowArgs>(args?: SelectSubset<T, TeenRewardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeenRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenRewardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeenRewards
     * const teenRewards = await prisma.teenRewards.findMany()
     * 
     * // Get first 10 TeenRewards
     * const teenRewards = await prisma.teenRewards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teenRewardsWithIdOnly = await prisma.teenRewards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeenRewardsFindManyArgs>(args?: SelectSubset<T, TeenRewardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeenRewards.
     * @param {TeenRewardsCreateArgs} args - Arguments to create a TeenRewards.
     * @example
     * // Create one TeenRewards
     * const TeenRewards = await prisma.teenRewards.create({
     *   data: {
     *     // ... data to create a TeenRewards
     *   }
     * })
     * 
     */
    create<T extends TeenRewardsCreateArgs>(args: SelectSubset<T, TeenRewardsCreateArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeenRewards.
     * @param {TeenRewardsCreateManyArgs} args - Arguments to create many TeenRewards.
     * @example
     * // Create many TeenRewards
     * const teenRewards = await prisma.teenRewards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeenRewardsCreateManyArgs>(args?: SelectSubset<T, TeenRewardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeenRewards and returns the data saved in the database.
     * @param {TeenRewardsCreateManyAndReturnArgs} args - Arguments to create many TeenRewards.
     * @example
     * // Create many TeenRewards
     * const teenRewards = await prisma.teenRewards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeenRewards and only return the `id`
     * const teenRewardsWithIdOnly = await prisma.teenRewards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeenRewardsCreateManyAndReturnArgs>(args?: SelectSubset<T, TeenRewardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeenRewards.
     * @param {TeenRewardsDeleteArgs} args - Arguments to delete one TeenRewards.
     * @example
     * // Delete one TeenRewards
     * const TeenRewards = await prisma.teenRewards.delete({
     *   where: {
     *     // ... filter to delete one TeenRewards
     *   }
     * })
     * 
     */
    delete<T extends TeenRewardsDeleteArgs>(args: SelectSubset<T, TeenRewardsDeleteArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeenRewards.
     * @param {TeenRewardsUpdateArgs} args - Arguments to update one TeenRewards.
     * @example
     * // Update one TeenRewards
     * const teenRewards = await prisma.teenRewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeenRewardsUpdateArgs>(args: SelectSubset<T, TeenRewardsUpdateArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeenRewards.
     * @param {TeenRewardsDeleteManyArgs} args - Arguments to filter TeenRewards to delete.
     * @example
     * // Delete a few TeenRewards
     * const { count } = await prisma.teenRewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeenRewardsDeleteManyArgs>(args?: SelectSubset<T, TeenRewardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeenRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenRewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeenRewards
     * const teenRewards = await prisma.teenRewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeenRewardsUpdateManyArgs>(args: SelectSubset<T, TeenRewardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeenRewards and returns the data updated in the database.
     * @param {TeenRewardsUpdateManyAndReturnArgs} args - Arguments to update many TeenRewards.
     * @example
     * // Update many TeenRewards
     * const teenRewards = await prisma.teenRewards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeenRewards and only return the `id`
     * const teenRewardsWithIdOnly = await prisma.teenRewards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeenRewardsUpdateManyAndReturnArgs>(args: SelectSubset<T, TeenRewardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeenRewards.
     * @param {TeenRewardsUpsertArgs} args - Arguments to update or create a TeenRewards.
     * @example
     * // Update or create a TeenRewards
     * const teenRewards = await prisma.teenRewards.upsert({
     *   create: {
     *     // ... data to create a TeenRewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeenRewards we want to update
     *   }
     * })
     */
    upsert<T extends TeenRewardsUpsertArgs>(args: SelectSubset<T, TeenRewardsUpsertArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeenRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenRewardsCountArgs} args - Arguments to filter TeenRewards to count.
     * @example
     * // Count the number of TeenRewards
     * const count = await prisma.teenRewards.count({
     *   where: {
     *     // ... the filter for the TeenRewards we want to count
     *   }
     * })
    **/
    count<T extends TeenRewardsCountArgs>(
      args?: Subset<T, TeenRewardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeenRewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeenRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenRewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeenRewardsAggregateArgs>(args: Subset<T, TeenRewardsAggregateArgs>): Prisma.PrismaPromise<GetTeenRewardsAggregateType<T>>

    /**
     * Group by TeenRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeenRewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeenRewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeenRewardsGroupByArgs['orderBy'] }
        : { orderBy?: TeenRewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeenRewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeenRewardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeenRewards model
   */
  readonly fields: TeenRewardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeenRewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeenRewardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    achievements<T extends TeenRewards$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, TeenRewards$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teen<T extends TeenDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeenDefaultArgs<ExtArgs>>): Prisma__TeenClient<$Result.GetResult<Prisma.$TeenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeenRewards model
   */
  interface TeenRewardsFieldRefs {
    readonly id: FieldRef<"TeenRewards", 'String'>
    readonly teenId: FieldRef<"TeenRewards", 'String'>
    readonly points: FieldRef<"TeenRewards", 'Int'>
    readonly level: FieldRef<"TeenRewards", 'Int'>
    readonly createdAt: FieldRef<"TeenRewards", 'DateTime'>
    readonly updatedAt: FieldRef<"TeenRewards", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeenRewards findUnique
   */
  export type TeenRewardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * Filter, which TeenRewards to fetch.
     */
    where: TeenRewardsWhereUniqueInput
  }

  /**
   * TeenRewards findUniqueOrThrow
   */
  export type TeenRewardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * Filter, which TeenRewards to fetch.
     */
    where: TeenRewardsWhereUniqueInput
  }

  /**
   * TeenRewards findFirst
   */
  export type TeenRewardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * Filter, which TeenRewards to fetch.
     */
    where?: TeenRewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeenRewards to fetch.
     */
    orderBy?: TeenRewardsOrderByWithRelationInput | TeenRewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeenRewards.
     */
    cursor?: TeenRewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeenRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeenRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeenRewards.
     */
    distinct?: TeenRewardsScalarFieldEnum | TeenRewardsScalarFieldEnum[]
  }

  /**
   * TeenRewards findFirstOrThrow
   */
  export type TeenRewardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * Filter, which TeenRewards to fetch.
     */
    where?: TeenRewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeenRewards to fetch.
     */
    orderBy?: TeenRewardsOrderByWithRelationInput | TeenRewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeenRewards.
     */
    cursor?: TeenRewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeenRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeenRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeenRewards.
     */
    distinct?: TeenRewardsScalarFieldEnum | TeenRewardsScalarFieldEnum[]
  }

  /**
   * TeenRewards findMany
   */
  export type TeenRewardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * Filter, which TeenRewards to fetch.
     */
    where?: TeenRewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeenRewards to fetch.
     */
    orderBy?: TeenRewardsOrderByWithRelationInput | TeenRewardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeenRewards.
     */
    cursor?: TeenRewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeenRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeenRewards.
     */
    skip?: number
    distinct?: TeenRewardsScalarFieldEnum | TeenRewardsScalarFieldEnum[]
  }

  /**
   * TeenRewards create
   */
  export type TeenRewardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * The data needed to create a TeenRewards.
     */
    data: XOR<TeenRewardsCreateInput, TeenRewardsUncheckedCreateInput>
  }

  /**
   * TeenRewards createMany
   */
  export type TeenRewardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeenRewards.
     */
    data: TeenRewardsCreateManyInput | TeenRewardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeenRewards createManyAndReturn
   */
  export type TeenRewardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * The data used to create many TeenRewards.
     */
    data: TeenRewardsCreateManyInput | TeenRewardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeenRewards update
   */
  export type TeenRewardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * The data needed to update a TeenRewards.
     */
    data: XOR<TeenRewardsUpdateInput, TeenRewardsUncheckedUpdateInput>
    /**
     * Choose, which TeenRewards to update.
     */
    where: TeenRewardsWhereUniqueInput
  }

  /**
   * TeenRewards updateMany
   */
  export type TeenRewardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeenRewards.
     */
    data: XOR<TeenRewardsUpdateManyMutationInput, TeenRewardsUncheckedUpdateManyInput>
    /**
     * Filter which TeenRewards to update
     */
    where?: TeenRewardsWhereInput
    /**
     * Limit how many TeenRewards to update.
     */
    limit?: number
  }

  /**
   * TeenRewards updateManyAndReturn
   */
  export type TeenRewardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * The data used to update TeenRewards.
     */
    data: XOR<TeenRewardsUpdateManyMutationInput, TeenRewardsUncheckedUpdateManyInput>
    /**
     * Filter which TeenRewards to update
     */
    where?: TeenRewardsWhereInput
    /**
     * Limit how many TeenRewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeenRewards upsert
   */
  export type TeenRewardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * The filter to search for the TeenRewards to update in case it exists.
     */
    where: TeenRewardsWhereUniqueInput
    /**
     * In case the TeenRewards found by the `where` argument doesn't exist, create a new TeenRewards with this data.
     */
    create: XOR<TeenRewardsCreateInput, TeenRewardsUncheckedCreateInput>
    /**
     * In case the TeenRewards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeenRewardsUpdateInput, TeenRewardsUncheckedUpdateInput>
  }

  /**
   * TeenRewards delete
   */
  export type TeenRewardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
    /**
     * Filter which TeenRewards to delete.
     */
    where: TeenRewardsWhereUniqueInput
  }

  /**
   * TeenRewards deleteMany
   */
  export type TeenRewardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeenRewards to delete
     */
    where?: TeenRewardsWhereInput
    /**
     * Limit how many TeenRewards to delete.
     */
    limit?: number
  }

  /**
   * TeenRewards.achievements
   */
  export type TeenRewards$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * TeenRewards without action
   */
  export type TeenRewardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeenRewards
     */
    select?: TeenRewardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeenRewards
     */
    omit?: TeenRewardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeenRewardsInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    points: number | null
    rewardId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    points: number | null
    rewardId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    points: number
    rewardId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    points?: true
    rewardId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    points?: true
    rewardId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    points?: true
    rewardId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string
    points: number
    rewardId: string
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    rewardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reward?: boolean | TeenRewardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    rewardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reward?: boolean | TeenRewardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    rewardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reward?: boolean | TeenRewardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    points?: boolean
    rewardId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "points" | "rewardId" | "createdAt" | "updatedAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reward?: boolean | TeenRewardsDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reward?: boolean | TeenRewardsDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reward?: boolean | TeenRewardsDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      reward: Prisma.$TeenRewardsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      points: number
      rewardId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reward<T extends TeenRewardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeenRewardsDefaultArgs<ExtArgs>>): Prisma__TeenRewardsClient<$Result.GetResult<Prisma.$TeenRewardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly rewardId: FieldRef<"Achievement", 'String'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    permissions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permissions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly permissions: FieldRef<"Admin", 'Json'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model TempTrackingLink
   */

  export type AggregateTempTrackingLink = {
    _count: TempTrackingLinkCountAggregateOutputType | null
    _min: TempTrackingLinkMinAggregateOutputType | null
    _max: TempTrackingLinkMaxAggregateOutputType | null
  }

  export type TempTrackingLinkMinAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    deviceId: string | null
    deviceName: string | null
    trackingLink: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TempTrackingLinkMaxAggregateOutputType = {
    id: string | null
    phoneNumber: string | null
    deviceId: string | null
    deviceName: string | null
    trackingLink: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TempTrackingLinkCountAggregateOutputType = {
    id: number
    phoneNumber: number
    deviceId: number
    deviceName: number
    trackingLink: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TempTrackingLinkMinAggregateInputType = {
    id?: true
    phoneNumber?: true
    deviceId?: true
    deviceName?: true
    trackingLink?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TempTrackingLinkMaxAggregateInputType = {
    id?: true
    phoneNumber?: true
    deviceId?: true
    deviceName?: true
    trackingLink?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TempTrackingLinkCountAggregateInputType = {
    id?: true
    phoneNumber?: true
    deviceId?: true
    deviceName?: true
    trackingLink?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TempTrackingLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TempTrackingLink to aggregate.
     */
    where?: TempTrackingLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempTrackingLinks to fetch.
     */
    orderBy?: TempTrackingLinkOrderByWithRelationInput | TempTrackingLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TempTrackingLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempTrackingLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempTrackingLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TempTrackingLinks
    **/
    _count?: true | TempTrackingLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TempTrackingLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TempTrackingLinkMaxAggregateInputType
  }

  export type GetTempTrackingLinkAggregateType<T extends TempTrackingLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateTempTrackingLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTempTrackingLink[P]>
      : GetScalarType<T[P], AggregateTempTrackingLink[P]>
  }




  export type TempTrackingLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TempTrackingLinkWhereInput
    orderBy?: TempTrackingLinkOrderByWithAggregationInput | TempTrackingLinkOrderByWithAggregationInput[]
    by: TempTrackingLinkScalarFieldEnum[] | TempTrackingLinkScalarFieldEnum
    having?: TempTrackingLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TempTrackingLinkCountAggregateInputType | true
    _min?: TempTrackingLinkMinAggregateInputType
    _max?: TempTrackingLinkMaxAggregateInputType
  }

  export type TempTrackingLinkGroupByOutputType = {
    id: string
    phoneNumber: string
    deviceId: string
    deviceName: string
    trackingLink: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: TempTrackingLinkCountAggregateOutputType | null
    _min: TempTrackingLinkMinAggregateOutputType | null
    _max: TempTrackingLinkMaxAggregateOutputType | null
  }

  type GetTempTrackingLinkGroupByPayload<T extends TempTrackingLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TempTrackingLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TempTrackingLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TempTrackingLinkGroupByOutputType[P]>
            : GetScalarType<T[P], TempTrackingLinkGroupByOutputType[P]>
        }
      >
    >


  export type TempTrackingLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    deviceId?: boolean
    deviceName?: boolean
    trackingLink?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tempTrackingLink"]>

  export type TempTrackingLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    deviceId?: boolean
    deviceName?: boolean
    trackingLink?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tempTrackingLink"]>

  export type TempTrackingLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phoneNumber?: boolean
    deviceId?: boolean
    deviceName?: boolean
    trackingLink?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tempTrackingLink"]>

  export type TempTrackingLinkSelectScalar = {
    id?: boolean
    phoneNumber?: boolean
    deviceId?: boolean
    deviceName?: boolean
    trackingLink?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TempTrackingLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "phoneNumber" | "deviceId" | "deviceName" | "trackingLink" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["tempTrackingLink"]>

  export type $TempTrackingLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TempTrackingLink"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phoneNumber: string
      deviceId: string
      deviceName: string
      trackingLink: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tempTrackingLink"]>
    composites: {}
  }

  type TempTrackingLinkGetPayload<S extends boolean | null | undefined | TempTrackingLinkDefaultArgs> = $Result.GetResult<Prisma.$TempTrackingLinkPayload, S>

  type TempTrackingLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TempTrackingLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TempTrackingLinkCountAggregateInputType | true
    }

  export interface TempTrackingLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TempTrackingLink'], meta: { name: 'TempTrackingLink' } }
    /**
     * Find zero or one TempTrackingLink that matches the filter.
     * @param {TempTrackingLinkFindUniqueArgs} args - Arguments to find a TempTrackingLink
     * @example
     * // Get one TempTrackingLink
     * const tempTrackingLink = await prisma.tempTrackingLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TempTrackingLinkFindUniqueArgs>(args: SelectSubset<T, TempTrackingLinkFindUniqueArgs<ExtArgs>>): Prisma__TempTrackingLinkClient<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TempTrackingLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TempTrackingLinkFindUniqueOrThrowArgs} args - Arguments to find a TempTrackingLink
     * @example
     * // Get one TempTrackingLink
     * const tempTrackingLink = await prisma.tempTrackingLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TempTrackingLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, TempTrackingLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TempTrackingLinkClient<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TempTrackingLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempTrackingLinkFindFirstArgs} args - Arguments to find a TempTrackingLink
     * @example
     * // Get one TempTrackingLink
     * const tempTrackingLink = await prisma.tempTrackingLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TempTrackingLinkFindFirstArgs>(args?: SelectSubset<T, TempTrackingLinkFindFirstArgs<ExtArgs>>): Prisma__TempTrackingLinkClient<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TempTrackingLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempTrackingLinkFindFirstOrThrowArgs} args - Arguments to find a TempTrackingLink
     * @example
     * // Get one TempTrackingLink
     * const tempTrackingLink = await prisma.tempTrackingLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TempTrackingLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, TempTrackingLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__TempTrackingLinkClient<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TempTrackingLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempTrackingLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TempTrackingLinks
     * const tempTrackingLinks = await prisma.tempTrackingLink.findMany()
     * 
     * // Get first 10 TempTrackingLinks
     * const tempTrackingLinks = await prisma.tempTrackingLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tempTrackingLinkWithIdOnly = await prisma.tempTrackingLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TempTrackingLinkFindManyArgs>(args?: SelectSubset<T, TempTrackingLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TempTrackingLink.
     * @param {TempTrackingLinkCreateArgs} args - Arguments to create a TempTrackingLink.
     * @example
     * // Create one TempTrackingLink
     * const TempTrackingLink = await prisma.tempTrackingLink.create({
     *   data: {
     *     // ... data to create a TempTrackingLink
     *   }
     * })
     * 
     */
    create<T extends TempTrackingLinkCreateArgs>(args: SelectSubset<T, TempTrackingLinkCreateArgs<ExtArgs>>): Prisma__TempTrackingLinkClient<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TempTrackingLinks.
     * @param {TempTrackingLinkCreateManyArgs} args - Arguments to create many TempTrackingLinks.
     * @example
     * // Create many TempTrackingLinks
     * const tempTrackingLink = await prisma.tempTrackingLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TempTrackingLinkCreateManyArgs>(args?: SelectSubset<T, TempTrackingLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TempTrackingLinks and returns the data saved in the database.
     * @param {TempTrackingLinkCreateManyAndReturnArgs} args - Arguments to create many TempTrackingLinks.
     * @example
     * // Create many TempTrackingLinks
     * const tempTrackingLink = await prisma.tempTrackingLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TempTrackingLinks and only return the `id`
     * const tempTrackingLinkWithIdOnly = await prisma.tempTrackingLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TempTrackingLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, TempTrackingLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TempTrackingLink.
     * @param {TempTrackingLinkDeleteArgs} args - Arguments to delete one TempTrackingLink.
     * @example
     * // Delete one TempTrackingLink
     * const TempTrackingLink = await prisma.tempTrackingLink.delete({
     *   where: {
     *     // ... filter to delete one TempTrackingLink
     *   }
     * })
     * 
     */
    delete<T extends TempTrackingLinkDeleteArgs>(args: SelectSubset<T, TempTrackingLinkDeleteArgs<ExtArgs>>): Prisma__TempTrackingLinkClient<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TempTrackingLink.
     * @param {TempTrackingLinkUpdateArgs} args - Arguments to update one TempTrackingLink.
     * @example
     * // Update one TempTrackingLink
     * const tempTrackingLink = await prisma.tempTrackingLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TempTrackingLinkUpdateArgs>(args: SelectSubset<T, TempTrackingLinkUpdateArgs<ExtArgs>>): Prisma__TempTrackingLinkClient<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TempTrackingLinks.
     * @param {TempTrackingLinkDeleteManyArgs} args - Arguments to filter TempTrackingLinks to delete.
     * @example
     * // Delete a few TempTrackingLinks
     * const { count } = await prisma.tempTrackingLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TempTrackingLinkDeleteManyArgs>(args?: SelectSubset<T, TempTrackingLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TempTrackingLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempTrackingLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TempTrackingLinks
     * const tempTrackingLink = await prisma.tempTrackingLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TempTrackingLinkUpdateManyArgs>(args: SelectSubset<T, TempTrackingLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TempTrackingLinks and returns the data updated in the database.
     * @param {TempTrackingLinkUpdateManyAndReturnArgs} args - Arguments to update many TempTrackingLinks.
     * @example
     * // Update many TempTrackingLinks
     * const tempTrackingLink = await prisma.tempTrackingLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TempTrackingLinks and only return the `id`
     * const tempTrackingLinkWithIdOnly = await prisma.tempTrackingLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TempTrackingLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, TempTrackingLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TempTrackingLink.
     * @param {TempTrackingLinkUpsertArgs} args - Arguments to update or create a TempTrackingLink.
     * @example
     * // Update or create a TempTrackingLink
     * const tempTrackingLink = await prisma.tempTrackingLink.upsert({
     *   create: {
     *     // ... data to create a TempTrackingLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TempTrackingLink we want to update
     *   }
     * })
     */
    upsert<T extends TempTrackingLinkUpsertArgs>(args: SelectSubset<T, TempTrackingLinkUpsertArgs<ExtArgs>>): Prisma__TempTrackingLinkClient<$Result.GetResult<Prisma.$TempTrackingLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TempTrackingLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempTrackingLinkCountArgs} args - Arguments to filter TempTrackingLinks to count.
     * @example
     * // Count the number of TempTrackingLinks
     * const count = await prisma.tempTrackingLink.count({
     *   where: {
     *     // ... the filter for the TempTrackingLinks we want to count
     *   }
     * })
    **/
    count<T extends TempTrackingLinkCountArgs>(
      args?: Subset<T, TempTrackingLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TempTrackingLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TempTrackingLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempTrackingLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TempTrackingLinkAggregateArgs>(args: Subset<T, TempTrackingLinkAggregateArgs>): Prisma.PrismaPromise<GetTempTrackingLinkAggregateType<T>>

    /**
     * Group by TempTrackingLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TempTrackingLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TempTrackingLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TempTrackingLinkGroupByArgs['orderBy'] }
        : { orderBy?: TempTrackingLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TempTrackingLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTempTrackingLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TempTrackingLink model
   */
  readonly fields: TempTrackingLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TempTrackingLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TempTrackingLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TempTrackingLink model
   */
  interface TempTrackingLinkFieldRefs {
    readonly id: FieldRef<"TempTrackingLink", 'String'>
    readonly phoneNumber: FieldRef<"TempTrackingLink", 'String'>
    readonly deviceId: FieldRef<"TempTrackingLink", 'String'>
    readonly deviceName: FieldRef<"TempTrackingLink", 'String'>
    readonly trackingLink: FieldRef<"TempTrackingLink", 'String'>
    readonly expiresAt: FieldRef<"TempTrackingLink", 'DateTime'>
    readonly createdAt: FieldRef<"TempTrackingLink", 'DateTime'>
    readonly updatedAt: FieldRef<"TempTrackingLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TempTrackingLink findUnique
   */
  export type TempTrackingLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * Filter, which TempTrackingLink to fetch.
     */
    where: TempTrackingLinkWhereUniqueInput
  }

  /**
   * TempTrackingLink findUniqueOrThrow
   */
  export type TempTrackingLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * Filter, which TempTrackingLink to fetch.
     */
    where: TempTrackingLinkWhereUniqueInput
  }

  /**
   * TempTrackingLink findFirst
   */
  export type TempTrackingLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * Filter, which TempTrackingLink to fetch.
     */
    where?: TempTrackingLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempTrackingLinks to fetch.
     */
    orderBy?: TempTrackingLinkOrderByWithRelationInput | TempTrackingLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TempTrackingLinks.
     */
    cursor?: TempTrackingLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempTrackingLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempTrackingLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TempTrackingLinks.
     */
    distinct?: TempTrackingLinkScalarFieldEnum | TempTrackingLinkScalarFieldEnum[]
  }

  /**
   * TempTrackingLink findFirstOrThrow
   */
  export type TempTrackingLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * Filter, which TempTrackingLink to fetch.
     */
    where?: TempTrackingLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempTrackingLinks to fetch.
     */
    orderBy?: TempTrackingLinkOrderByWithRelationInput | TempTrackingLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TempTrackingLinks.
     */
    cursor?: TempTrackingLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempTrackingLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempTrackingLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TempTrackingLinks.
     */
    distinct?: TempTrackingLinkScalarFieldEnum | TempTrackingLinkScalarFieldEnum[]
  }

  /**
   * TempTrackingLink findMany
   */
  export type TempTrackingLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * Filter, which TempTrackingLinks to fetch.
     */
    where?: TempTrackingLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TempTrackingLinks to fetch.
     */
    orderBy?: TempTrackingLinkOrderByWithRelationInput | TempTrackingLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TempTrackingLinks.
     */
    cursor?: TempTrackingLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TempTrackingLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TempTrackingLinks.
     */
    skip?: number
    distinct?: TempTrackingLinkScalarFieldEnum | TempTrackingLinkScalarFieldEnum[]
  }

  /**
   * TempTrackingLink create
   */
  export type TempTrackingLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * The data needed to create a TempTrackingLink.
     */
    data: XOR<TempTrackingLinkCreateInput, TempTrackingLinkUncheckedCreateInput>
  }

  /**
   * TempTrackingLink createMany
   */
  export type TempTrackingLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TempTrackingLinks.
     */
    data: TempTrackingLinkCreateManyInput | TempTrackingLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TempTrackingLink createManyAndReturn
   */
  export type TempTrackingLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * The data used to create many TempTrackingLinks.
     */
    data: TempTrackingLinkCreateManyInput | TempTrackingLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TempTrackingLink update
   */
  export type TempTrackingLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * The data needed to update a TempTrackingLink.
     */
    data: XOR<TempTrackingLinkUpdateInput, TempTrackingLinkUncheckedUpdateInput>
    /**
     * Choose, which TempTrackingLink to update.
     */
    where: TempTrackingLinkWhereUniqueInput
  }

  /**
   * TempTrackingLink updateMany
   */
  export type TempTrackingLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TempTrackingLinks.
     */
    data: XOR<TempTrackingLinkUpdateManyMutationInput, TempTrackingLinkUncheckedUpdateManyInput>
    /**
     * Filter which TempTrackingLinks to update
     */
    where?: TempTrackingLinkWhereInput
    /**
     * Limit how many TempTrackingLinks to update.
     */
    limit?: number
  }

  /**
   * TempTrackingLink updateManyAndReturn
   */
  export type TempTrackingLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * The data used to update TempTrackingLinks.
     */
    data: XOR<TempTrackingLinkUpdateManyMutationInput, TempTrackingLinkUncheckedUpdateManyInput>
    /**
     * Filter which TempTrackingLinks to update
     */
    where?: TempTrackingLinkWhereInput
    /**
     * Limit how many TempTrackingLinks to update.
     */
    limit?: number
  }

  /**
   * TempTrackingLink upsert
   */
  export type TempTrackingLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * The filter to search for the TempTrackingLink to update in case it exists.
     */
    where: TempTrackingLinkWhereUniqueInput
    /**
     * In case the TempTrackingLink found by the `where` argument doesn't exist, create a new TempTrackingLink with this data.
     */
    create: XOR<TempTrackingLinkCreateInput, TempTrackingLinkUncheckedCreateInput>
    /**
     * In case the TempTrackingLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TempTrackingLinkUpdateInput, TempTrackingLinkUncheckedUpdateInput>
  }

  /**
   * TempTrackingLink delete
   */
  export type TempTrackingLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
    /**
     * Filter which TempTrackingLink to delete.
     */
    where: TempTrackingLinkWhereUniqueInput
  }

  /**
   * TempTrackingLink deleteMany
   */
  export type TempTrackingLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TempTrackingLinks to delete
     */
    where?: TempTrackingLinkWhereInput
    /**
     * Limit how many TempTrackingLinks to delete.
     */
    limit?: number
  }

  /**
   * TempTrackingLink without action
   */
  export type TempTrackingLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TempTrackingLink
     */
    select?: TempTrackingLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TempTrackingLink
     */
    omit?: TempTrackingLinkOmit<ExtArgs> | null
  }


  /**
   * Model RouteFeatures
   */

  export type AggregateRouteFeatures = {
    _count: RouteFeaturesCountAggregateOutputType | null
    _min: RouteFeaturesMinAggregateOutputType | null
    _max: RouteFeaturesMaxAggregateOutputType | null
  }

  export type RouteFeaturesMinAggregateOutputType = {
    id: string | null
    routeId: string | null
    liveTracking: boolean | null
    videoSurveillance: boolean | null
    childLocks: boolean | null
    speedMonitoring: boolean | null
    ac: boolean | null
    parentAlerts: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteFeaturesMaxAggregateOutputType = {
    id: string | null
    routeId: string | null
    liveTracking: boolean | null
    videoSurveillance: boolean | null
    childLocks: boolean | null
    speedMonitoring: boolean | null
    ac: boolean | null
    parentAlerts: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteFeaturesCountAggregateOutputType = {
    id: number
    routeId: number
    liveTracking: number
    videoSurveillance: number
    childLocks: number
    speedMonitoring: number
    ac: number
    parentAlerts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RouteFeaturesMinAggregateInputType = {
    id?: true
    routeId?: true
    liveTracking?: true
    videoSurveillance?: true
    childLocks?: true
    speedMonitoring?: true
    ac?: true
    parentAlerts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteFeaturesMaxAggregateInputType = {
    id?: true
    routeId?: true
    liveTracking?: true
    videoSurveillance?: true
    childLocks?: true
    speedMonitoring?: true
    ac?: true
    parentAlerts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteFeaturesCountAggregateInputType = {
    id?: true
    routeId?: true
    liveTracking?: true
    videoSurveillance?: true
    childLocks?: true
    speedMonitoring?: true
    ac?: true
    parentAlerts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RouteFeaturesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteFeatures to aggregate.
     */
    where?: RouteFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteFeatures to fetch.
     */
    orderBy?: RouteFeaturesOrderByWithRelationInput | RouteFeaturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteFeatures
    **/
    _count?: true | RouteFeaturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteFeaturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteFeaturesMaxAggregateInputType
  }

  export type GetRouteFeaturesAggregateType<T extends RouteFeaturesAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteFeatures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteFeatures[P]>
      : GetScalarType<T[P], AggregateRouteFeatures[P]>
  }




  export type RouteFeaturesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteFeaturesWhereInput
    orderBy?: RouteFeaturesOrderByWithAggregationInput | RouteFeaturesOrderByWithAggregationInput[]
    by: RouteFeaturesScalarFieldEnum[] | RouteFeaturesScalarFieldEnum
    having?: RouteFeaturesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteFeaturesCountAggregateInputType | true
    _min?: RouteFeaturesMinAggregateInputType
    _max?: RouteFeaturesMaxAggregateInputType
  }

  export type RouteFeaturesGroupByOutputType = {
    id: string
    routeId: string
    liveTracking: boolean
    videoSurveillance: boolean
    childLocks: boolean
    speedMonitoring: boolean
    ac: boolean
    parentAlerts: boolean
    createdAt: Date
    updatedAt: Date
    _count: RouteFeaturesCountAggregateOutputType | null
    _min: RouteFeaturesMinAggregateOutputType | null
    _max: RouteFeaturesMaxAggregateOutputType | null
  }

  type GetRouteFeaturesGroupByPayload<T extends RouteFeaturesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteFeaturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteFeaturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteFeaturesGroupByOutputType[P]>
            : GetScalarType<T[P], RouteFeaturesGroupByOutputType[P]>
        }
      >
    >


  export type RouteFeaturesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeFeatures"]>

  export type RouteFeaturesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeFeatures"]>

  export type RouteFeaturesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeFeatures"]>

  export type RouteFeaturesSelectScalar = {
    id?: boolean
    routeId?: boolean
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RouteFeaturesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "routeId" | "liveTracking" | "videoSurveillance" | "childLocks" | "speedMonitoring" | "ac" | "parentAlerts" | "createdAt" | "updatedAt", ExtArgs["result"]["routeFeatures"]>
  export type RouteFeaturesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }
  export type RouteFeaturesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }
  export type RouteFeaturesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }

  export type $RouteFeaturesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteFeatures"
    objects: {
      route: Prisma.$RoutePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routeId: string
      liveTracking: boolean
      videoSurveillance: boolean
      childLocks: boolean
      speedMonitoring: boolean
      ac: boolean
      parentAlerts: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routeFeatures"]>
    composites: {}
  }

  type RouteFeaturesGetPayload<S extends boolean | null | undefined | RouteFeaturesDefaultArgs> = $Result.GetResult<Prisma.$RouteFeaturesPayload, S>

  type RouteFeaturesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteFeaturesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteFeaturesCountAggregateInputType | true
    }

  export interface RouteFeaturesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteFeatures'], meta: { name: 'RouteFeatures' } }
    /**
     * Find zero or one RouteFeatures that matches the filter.
     * @param {RouteFeaturesFindUniqueArgs} args - Arguments to find a RouteFeatures
     * @example
     * // Get one RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteFeaturesFindUniqueArgs>(args: SelectSubset<T, RouteFeaturesFindUniqueArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RouteFeatures that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteFeaturesFindUniqueOrThrowArgs} args - Arguments to find a RouteFeatures
     * @example
     * // Get one RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteFeaturesFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteFeaturesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFeaturesFindFirstArgs} args - Arguments to find a RouteFeatures
     * @example
     * // Get one RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteFeaturesFindFirstArgs>(args?: SelectSubset<T, RouteFeaturesFindFirstArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteFeatures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFeaturesFindFirstOrThrowArgs} args - Arguments to find a RouteFeatures
     * @example
     * // Get one RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteFeaturesFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteFeaturesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RouteFeatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFeaturesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.findMany()
     * 
     * // Get first 10 RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeFeaturesWithIdOnly = await prisma.routeFeatures.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteFeaturesFindManyArgs>(args?: SelectSubset<T, RouteFeaturesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RouteFeatures.
     * @param {RouteFeaturesCreateArgs} args - Arguments to create a RouteFeatures.
     * @example
     * // Create one RouteFeatures
     * const RouteFeatures = await prisma.routeFeatures.create({
     *   data: {
     *     // ... data to create a RouteFeatures
     *   }
     * })
     * 
     */
    create<T extends RouteFeaturesCreateArgs>(args: SelectSubset<T, RouteFeaturesCreateArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RouteFeatures.
     * @param {RouteFeaturesCreateManyArgs} args - Arguments to create many RouteFeatures.
     * @example
     * // Create many RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteFeaturesCreateManyArgs>(args?: SelectSubset<T, RouteFeaturesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteFeatures and returns the data saved in the database.
     * @param {RouteFeaturesCreateManyAndReturnArgs} args - Arguments to create many RouteFeatures.
     * @example
     * // Create many RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteFeatures and only return the `id`
     * const routeFeaturesWithIdOnly = await prisma.routeFeatures.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteFeaturesCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteFeaturesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RouteFeatures.
     * @param {RouteFeaturesDeleteArgs} args - Arguments to delete one RouteFeatures.
     * @example
     * // Delete one RouteFeatures
     * const RouteFeatures = await prisma.routeFeatures.delete({
     *   where: {
     *     // ... filter to delete one RouteFeatures
     *   }
     * })
     * 
     */
    delete<T extends RouteFeaturesDeleteArgs>(args: SelectSubset<T, RouteFeaturesDeleteArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RouteFeatures.
     * @param {RouteFeaturesUpdateArgs} args - Arguments to update one RouteFeatures.
     * @example
     * // Update one RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteFeaturesUpdateArgs>(args: SelectSubset<T, RouteFeaturesUpdateArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RouteFeatures.
     * @param {RouteFeaturesDeleteManyArgs} args - Arguments to filter RouteFeatures to delete.
     * @example
     * // Delete a few RouteFeatures
     * const { count } = await prisma.routeFeatures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteFeaturesDeleteManyArgs>(args?: SelectSubset<T, RouteFeaturesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFeaturesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteFeaturesUpdateManyArgs>(args: SelectSubset<T, RouteFeaturesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteFeatures and returns the data updated in the database.
     * @param {RouteFeaturesUpdateManyAndReturnArgs} args - Arguments to update many RouteFeatures.
     * @example
     * // Update many RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RouteFeatures and only return the `id`
     * const routeFeaturesWithIdOnly = await prisma.routeFeatures.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RouteFeaturesUpdateManyAndReturnArgs>(args: SelectSubset<T, RouteFeaturesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RouteFeatures.
     * @param {RouteFeaturesUpsertArgs} args - Arguments to update or create a RouteFeatures.
     * @example
     * // Update or create a RouteFeatures
     * const routeFeatures = await prisma.routeFeatures.upsert({
     *   create: {
     *     // ... data to create a RouteFeatures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteFeatures we want to update
     *   }
     * })
     */
    upsert<T extends RouteFeaturesUpsertArgs>(args: SelectSubset<T, RouteFeaturesUpsertArgs<ExtArgs>>): Prisma__RouteFeaturesClient<$Result.GetResult<Prisma.$RouteFeaturesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RouteFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFeaturesCountArgs} args - Arguments to filter RouteFeatures to count.
     * @example
     * // Count the number of RouteFeatures
     * const count = await prisma.routeFeatures.count({
     *   where: {
     *     // ... the filter for the RouteFeatures we want to count
     *   }
     * })
    **/
    count<T extends RouteFeaturesCountArgs>(
      args?: Subset<T, RouteFeaturesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteFeaturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFeaturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteFeaturesAggregateArgs>(args: Subset<T, RouteFeaturesAggregateArgs>): Prisma.PrismaPromise<GetRouteFeaturesAggregateType<T>>

    /**
     * Group by RouteFeatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFeaturesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteFeaturesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteFeaturesGroupByArgs['orderBy'] }
        : { orderBy?: RouteFeaturesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteFeaturesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteFeaturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteFeatures model
   */
  readonly fields: RouteFeaturesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteFeatures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteFeaturesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteFeatures model
   */
  interface RouteFeaturesFieldRefs {
    readonly id: FieldRef<"RouteFeatures", 'String'>
    readonly routeId: FieldRef<"RouteFeatures", 'String'>
    readonly liveTracking: FieldRef<"RouteFeatures", 'Boolean'>
    readonly videoSurveillance: FieldRef<"RouteFeatures", 'Boolean'>
    readonly childLocks: FieldRef<"RouteFeatures", 'Boolean'>
    readonly speedMonitoring: FieldRef<"RouteFeatures", 'Boolean'>
    readonly ac: FieldRef<"RouteFeatures", 'Boolean'>
    readonly parentAlerts: FieldRef<"RouteFeatures", 'Boolean'>
    readonly createdAt: FieldRef<"RouteFeatures", 'DateTime'>
    readonly updatedAt: FieldRef<"RouteFeatures", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteFeatures findUnique
   */
  export type RouteFeaturesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which RouteFeatures to fetch.
     */
    where: RouteFeaturesWhereUniqueInput
  }

  /**
   * RouteFeatures findUniqueOrThrow
   */
  export type RouteFeaturesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which RouteFeatures to fetch.
     */
    where: RouteFeaturesWhereUniqueInput
  }

  /**
   * RouteFeatures findFirst
   */
  export type RouteFeaturesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which RouteFeatures to fetch.
     */
    where?: RouteFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteFeatures to fetch.
     */
    orderBy?: RouteFeaturesOrderByWithRelationInput | RouteFeaturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteFeatures.
     */
    cursor?: RouteFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteFeatures.
     */
    distinct?: RouteFeaturesScalarFieldEnum | RouteFeaturesScalarFieldEnum[]
  }

  /**
   * RouteFeatures findFirstOrThrow
   */
  export type RouteFeaturesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which RouteFeatures to fetch.
     */
    where?: RouteFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteFeatures to fetch.
     */
    orderBy?: RouteFeaturesOrderByWithRelationInput | RouteFeaturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteFeatures.
     */
    cursor?: RouteFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteFeatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteFeatures.
     */
    distinct?: RouteFeaturesScalarFieldEnum | RouteFeaturesScalarFieldEnum[]
  }

  /**
   * RouteFeatures findMany
   */
  export type RouteFeaturesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * Filter, which RouteFeatures to fetch.
     */
    where?: RouteFeaturesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteFeatures to fetch.
     */
    orderBy?: RouteFeaturesOrderByWithRelationInput | RouteFeaturesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteFeatures.
     */
    cursor?: RouteFeaturesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteFeatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteFeatures.
     */
    skip?: number
    distinct?: RouteFeaturesScalarFieldEnum | RouteFeaturesScalarFieldEnum[]
  }

  /**
   * RouteFeatures create
   */
  export type RouteFeaturesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteFeatures.
     */
    data: XOR<RouteFeaturesCreateInput, RouteFeaturesUncheckedCreateInput>
  }

  /**
   * RouteFeatures createMany
   */
  export type RouteFeaturesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteFeatures.
     */
    data: RouteFeaturesCreateManyInput | RouteFeaturesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteFeatures createManyAndReturn
   */
  export type RouteFeaturesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * The data used to create many RouteFeatures.
     */
    data: RouteFeaturesCreateManyInput | RouteFeaturesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteFeatures update
   */
  export type RouteFeaturesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteFeatures.
     */
    data: XOR<RouteFeaturesUpdateInput, RouteFeaturesUncheckedUpdateInput>
    /**
     * Choose, which RouteFeatures to update.
     */
    where: RouteFeaturesWhereUniqueInput
  }

  /**
   * RouteFeatures updateMany
   */
  export type RouteFeaturesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteFeatures.
     */
    data: XOR<RouteFeaturesUpdateManyMutationInput, RouteFeaturesUncheckedUpdateManyInput>
    /**
     * Filter which RouteFeatures to update
     */
    where?: RouteFeaturesWhereInput
    /**
     * Limit how many RouteFeatures to update.
     */
    limit?: number
  }

  /**
   * RouteFeatures updateManyAndReturn
   */
  export type RouteFeaturesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * The data used to update RouteFeatures.
     */
    data: XOR<RouteFeaturesUpdateManyMutationInput, RouteFeaturesUncheckedUpdateManyInput>
    /**
     * Filter which RouteFeatures to update
     */
    where?: RouteFeaturesWhereInput
    /**
     * Limit how many RouteFeatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteFeatures upsert
   */
  export type RouteFeaturesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteFeatures to update in case it exists.
     */
    where: RouteFeaturesWhereUniqueInput
    /**
     * In case the RouteFeatures found by the `where` argument doesn't exist, create a new RouteFeatures with this data.
     */
    create: XOR<RouteFeaturesCreateInput, RouteFeaturesUncheckedCreateInput>
    /**
     * In case the RouteFeatures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteFeaturesUpdateInput, RouteFeaturesUncheckedUpdateInput>
  }

  /**
   * RouteFeatures delete
   */
  export type RouteFeaturesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
    /**
     * Filter which RouteFeatures to delete.
     */
    where: RouteFeaturesWhereUniqueInput
  }

  /**
   * RouteFeatures deleteMany
   */
  export type RouteFeaturesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteFeatures to delete
     */
    where?: RouteFeaturesWhereInput
    /**
     * Limit how many RouteFeatures to delete.
     */
    limit?: number
  }

  /**
   * RouteFeatures without action
   */
  export type RouteFeaturesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFeatures
     */
    select?: RouteFeaturesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFeatures
     */
    omit?: RouteFeaturesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFeaturesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    role: 'role',
    isActive: 'isActive',
    fcmToken: 'fcmToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    type: 'type',
    isVerified: 'isVerified',
    contactNumber: 'contactNumber',
    operatingHours: 'operatingHours',
    createdBy: 'createdBy',
    verifiedBy: 'verifiedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const RouteScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    routeType: 'routeType',
    frequency: 'frequency',
    daysOfWeek: 'daysOfWeek',
    startDate: 'startDate',
    endDate: 'endDate',
    isRecurring: 'isRecurring',
    baseFare: 'baseFare',
    pricingType: 'pricingType',
    perKmRate: 'perKmRate',
    roundTripDiscount: 'roundTripDiscount',
    totalSeats: 'totalSeats',
    availableSeats: 'availableSeats',
    farePerSeat: 'farePerSeat',
    status: 'status',
    isActive: 'isActive',
    isListedPublicly: 'isListedPublicly',
    allowDriverBidding: 'allowDriverBidding',
    autoApproveRequests: 'autoApproveRequests',
    minOccupancyRatio: 'minOccupancyRatio',
    maxOccupancyRatio: 'maxOccupancyRatio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RouteScalarFieldEnum = (typeof RouteScalarFieldEnum)[keyof typeof RouteScalarFieldEnum]


  export const RouteStopScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    locationId: 'locationId',
    sequence: 'sequence',
    arrivalTime: 'arrivalTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RouteStopScalarFieldEnum = (typeof RouteStopScalarFieldEnum)[keyof typeof RouteStopScalarFieldEnum]


  export const RouteDriverScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    driverId: 'driverId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RouteDriverScalarFieldEnum = (typeof RouteDriverScalarFieldEnum)[keyof typeof RouteDriverScalarFieldEnum]


  export const TripScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    driverId: 'driverId',
    date: 'date',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TripScalarFieldEnum = (typeof TripScalarFieldEnum)[keyof typeof TripScalarFieldEnum]


  export const RideScalarFieldEnum: {
    id: 'id',
    tripId: 'tripId',
    teenId: 'teenId',
    pickupStopId: 'pickupStopId',
    dropStopId: 'dropStopId',
    status: 'status',
    scheduledPickupTime: 'scheduledPickupTime',
    actualPickupTime: 'actualPickupTime',
    scheduledDropTime: 'scheduledDropTime',
    actualDropTime: 'actualDropTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RideScalarFieldEnum = (typeof RideScalarFieldEnum)[keyof typeof RideScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    licenseNumber: 'licenseNumber',
    aadharNumber: 'aadharNumber',
    verificationStatus: 'verificationStatus',
    rating: 'rating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const TeenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    parentId: 'parentId',
    inviteCode: 'inviteCode',
    inviteExpiry: 'inviteExpiry',
    inviteStatus: 'inviteStatus',
    inviteType: 'inviteType',
    name: 'name',
    age: 'age',
    grade: 'grade',
    avatar: 'avatar',
    schoolId: 'schoolId',
    emergencyContact: 'emergencyContact',
    medicalInfo: 'medicalInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeenScalarFieldEnum = (typeof TeenScalarFieldEnum)[keyof typeof TeenScalarFieldEnum]


  export const RideRequestScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    teenId: 'teenId',
    routeId: 'routeId',
    pickupStopId: 'pickupStopId',
    dropStopId: 'dropStopId',
    requestType: 'requestType',
    seatsRequired: 'seatsRequired',
    expectedPickupTime: 'expectedPickupTime',
    expectedDropTime: 'expectedDropTime',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RideRequestScalarFieldEnum = (typeof RideRequestScalarFieldEnum)[keyof typeof RideRequestScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    make: 'make',
    model: 'model',
    year: 'year',
    plateNumber: 'plateNumber',
    capacity: 'capacity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const DriverVerificationScalarFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    status: 'status',
    vehiclePhotos: 'vehiclePhotos',
    policeVerification: 'policeVerification',
    backgroundCheck: 'backgroundCheck',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriverVerificationScalarFieldEnum = (typeof DriverVerificationScalarFieldEnum)[keyof typeof DriverVerificationScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    number: 'number',
    expiryDate: 'expiryDate',
    fileUrl: 'fileUrl',
    verificationId: 'verificationId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    balance: 'balance',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    amount: 'amount',
    type: 'type',
    status: 'status',
    description: 'description',
    rideId: 'rideId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TeenBuddyScalarFieldEnum: {
    id: 'id',
    teenId: 'teenId',
    buddyId: 'buddyId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeenBuddyScalarFieldEnum = (typeof TeenBuddyScalarFieldEnum)[keyof typeof TeenBuddyScalarFieldEnum]


  export const TeenRewardsScalarFieldEnum: {
    id: 'id',
    teenId: 'teenId',
    points: 'points',
    level: 'level',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeenRewardsScalarFieldEnum = (typeof TeenRewardsScalarFieldEnum)[keyof typeof TeenRewardsScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    points: 'points',
    rewardId: 'rewardId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const TempTrackingLinkScalarFieldEnum: {
    id: 'id',
    phoneNumber: 'phoneNumber',
    deviceId: 'deviceId',
    deviceName: 'deviceName',
    trackingLink: 'trackingLink',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TempTrackingLinkScalarFieldEnum = (typeof TempTrackingLinkScalarFieldEnum)[keyof typeof TempTrackingLinkScalarFieldEnum]


  export const RouteFeaturesScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    liveTracking: 'liveTracking',
    videoSurveillance: 'videoSurveillance',
    childLocks: 'childLocks',
    speedMonitoring: 'speedMonitoring',
    ac: 'ac',
    parentAlerts: 'parentAlerts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RouteFeaturesScalarFieldEnum = (typeof RouteFeaturesScalarFieldEnum)[keyof typeof RouteFeaturesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LocationType'
   */
  export type EnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType'>
    


  /**
   * Reference to a field of type 'LocationType[]'
   */
  export type ListEnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'RouteType'
   */
  export type EnumRouteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteType'>
    


  /**
   * Reference to a field of type 'RouteType[]'
   */
  export type ListEnumRouteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteType[]'>
    


  /**
   * Reference to a field of type 'RouteFrequency'
   */
  export type EnumRouteFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteFrequency'>
    


  /**
   * Reference to a field of type 'RouteFrequency[]'
   */
  export type ListEnumRouteFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteFrequency[]'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'PricingType'
   */
  export type EnumPricingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingType'>
    


  /**
   * Reference to a field of type 'PricingType[]'
   */
  export type ListEnumPricingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingType[]'>
    


  /**
   * Reference to a field of type 'RouteStatus'
   */
  export type EnumRouteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteStatus'>
    


  /**
   * Reference to a field of type 'RouteStatus[]'
   */
  export type ListEnumRouteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RouteStatus[]'>
    


  /**
   * Reference to a field of type 'TripStatus'
   */
  export type EnumTripStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TripStatus'>
    


  /**
   * Reference to a field of type 'TripStatus[]'
   */
  export type ListEnumTripStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TripStatus[]'>
    


  /**
   * Reference to a field of type 'RideStatus'
   */
  export type EnumRideStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RideStatus'>
    


  /**
   * Reference to a field of type 'RideStatus[]'
   */
  export type ListEnumRideStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RideStatus[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'InviteStatus'
   */
  export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus'>
    


  /**
   * Reference to a field of type 'InviteStatus[]'
   */
  export type ListEnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus[]'>
    


  /**
   * Reference to a field of type 'InviteType'
   */
  export type EnumInviteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteType'>
    


  /**
   * Reference to a field of type 'InviteType[]'
   */
  export type ListEnumInviteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteType[]'>
    


  /**
   * Reference to a field of type 'RequestType'
   */
  export type EnumRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestType'>
    


  /**
   * Reference to a field of type 'RequestType[]'
   */
  export type ListEnumRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestType[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'BuddyStatus'
   */
  export type EnumBuddyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BuddyStatus'>
    


  /**
   * Reference to a field of type 'BuddyStatus[]'
   */
  export type ListEnumBuddyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BuddyStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    fcmToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    parent?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    teen?: XOR<TeenNullableScalarRelationFilter, TeenWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    teen?: TeenOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    fcmToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    parent?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    teen?: XOR<TeenNullableScalarRelationFilter, TeenWhereInput> | null
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    fcmToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    isVerified?: BoolFilter<"Location"> | boolean
    contactNumber?: StringNullableFilter<"Location"> | string | null
    operatingHours?: JsonNullableFilter<"Location">
    createdBy?: StringNullableFilter<"Location"> | string | null
    verifiedBy?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    routeStops?: RouteStopListRelationFilter
    teens?: TeenListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    type?: SortOrder
    isVerified?: SortOrder
    contactNumber?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    routeStops?: RouteStopOrderByRelationAggregateInput
    teens?: TeenOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    address?: StringFilter<"Location"> | string
    latitude?: FloatFilter<"Location"> | number
    longitude?: FloatFilter<"Location"> | number
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    isVerified?: BoolFilter<"Location"> | boolean
    contactNumber?: StringNullableFilter<"Location"> | string | null
    operatingHours?: JsonNullableFilter<"Location">
    createdBy?: StringNullableFilter<"Location"> | string | null
    verifiedBy?: StringNullableFilter<"Location"> | string | null
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    routeStops?: RouteStopListRelationFilter
    teens?: TeenListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    type?: SortOrder
    isVerified?: SortOrder
    contactNumber?: SortOrderInput | SortOrder
    operatingHours?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    address?: StringWithAggregatesFilter<"Location"> | string
    latitude?: FloatWithAggregatesFilter<"Location"> | number
    longitude?: FloatWithAggregatesFilter<"Location"> | number
    type?: EnumLocationTypeWithAggregatesFilter<"Location"> | $Enums.LocationType
    isVerified?: BoolWithAggregatesFilter<"Location"> | boolean
    contactNumber?: StringNullableWithAggregatesFilter<"Location"> | string | null
    operatingHours?: JsonNullableWithAggregatesFilter<"Location">
    createdBy?: StringNullableWithAggregatesFilter<"Location"> | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"Location"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type RouteWhereInput = {
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    id?: StringFilter<"Route"> | string
    name?: StringFilter<"Route"> | string
    description?: StringNullableFilter<"Route"> | string | null
    routeType?: EnumRouteTypeFilter<"Route"> | $Enums.RouteType
    frequency?: EnumRouteFrequencyFilter<"Route"> | $Enums.RouteFrequency
    daysOfWeek?: IntNullableListFilter<"Route">
    startDate?: DateTimeFilter<"Route"> | Date | string
    endDate?: DateTimeNullableFilter<"Route"> | Date | string | null
    isRecurring?: BoolFilter<"Route"> | boolean
    baseFare?: FloatFilter<"Route"> | number
    pricingType?: EnumPricingTypeFilter<"Route"> | $Enums.PricingType
    perKmRate?: FloatNullableFilter<"Route"> | number | null
    roundTripDiscount?: FloatNullableFilter<"Route"> | number | null
    totalSeats?: IntFilter<"Route"> | number
    availableSeats?: IntFilter<"Route"> | number
    farePerSeat?: FloatFilter<"Route"> | number
    status?: EnumRouteStatusFilter<"Route"> | $Enums.RouteStatus
    isActive?: BoolFilter<"Route"> | boolean
    isListedPublicly?: BoolFilter<"Route"> | boolean
    allowDriverBidding?: BoolFilter<"Route"> | boolean
    autoApproveRequests?: BoolFilter<"Route"> | boolean
    minOccupancyRatio?: FloatFilter<"Route"> | number
    maxOccupancyRatio?: FloatFilter<"Route"> | number
    createdAt?: DateTimeFilter<"Route"> | Date | string
    updatedAt?: DateTimeFilter<"Route"> | Date | string
    features?: XOR<RouteFeaturesNullableScalarRelationFilter, RouteFeaturesWhereInput> | null
    requests?: RideRequestListRelationFilter
    drivers?: RouteDriverListRelationFilter
    stops?: RouteStopListRelationFilter
    trips?: TripListRelationFilter
  }

  export type RouteOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    routeType?: SortOrder
    frequency?: SortOrder
    daysOfWeek?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    baseFare?: SortOrder
    pricingType?: SortOrder
    perKmRate?: SortOrderInput | SortOrder
    roundTripDiscount?: SortOrderInput | SortOrder
    totalSeats?: SortOrder
    availableSeats?: SortOrder
    farePerSeat?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isListedPublicly?: SortOrder
    allowDriverBidding?: SortOrder
    autoApproveRequests?: SortOrder
    minOccupancyRatio?: SortOrder
    maxOccupancyRatio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    features?: RouteFeaturesOrderByWithRelationInput
    requests?: RideRequestOrderByRelationAggregateInput
    drivers?: RouteDriverOrderByRelationAggregateInput
    stops?: RouteStopOrderByRelationAggregateInput
    trips?: TripOrderByRelationAggregateInput
  }

  export type RouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    name?: StringFilter<"Route"> | string
    description?: StringNullableFilter<"Route"> | string | null
    routeType?: EnumRouteTypeFilter<"Route"> | $Enums.RouteType
    frequency?: EnumRouteFrequencyFilter<"Route"> | $Enums.RouteFrequency
    daysOfWeek?: IntNullableListFilter<"Route">
    startDate?: DateTimeFilter<"Route"> | Date | string
    endDate?: DateTimeNullableFilter<"Route"> | Date | string | null
    isRecurring?: BoolFilter<"Route"> | boolean
    baseFare?: FloatFilter<"Route"> | number
    pricingType?: EnumPricingTypeFilter<"Route"> | $Enums.PricingType
    perKmRate?: FloatNullableFilter<"Route"> | number | null
    roundTripDiscount?: FloatNullableFilter<"Route"> | number | null
    totalSeats?: IntFilter<"Route"> | number
    availableSeats?: IntFilter<"Route"> | number
    farePerSeat?: FloatFilter<"Route"> | number
    status?: EnumRouteStatusFilter<"Route"> | $Enums.RouteStatus
    isActive?: BoolFilter<"Route"> | boolean
    isListedPublicly?: BoolFilter<"Route"> | boolean
    allowDriverBidding?: BoolFilter<"Route"> | boolean
    autoApproveRequests?: BoolFilter<"Route"> | boolean
    minOccupancyRatio?: FloatFilter<"Route"> | number
    maxOccupancyRatio?: FloatFilter<"Route"> | number
    createdAt?: DateTimeFilter<"Route"> | Date | string
    updatedAt?: DateTimeFilter<"Route"> | Date | string
    features?: XOR<RouteFeaturesNullableScalarRelationFilter, RouteFeaturesWhereInput> | null
    requests?: RideRequestListRelationFilter
    drivers?: RouteDriverListRelationFilter
    stops?: RouteStopListRelationFilter
    trips?: TripListRelationFilter
  }, "id">

  export type RouteOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    routeType?: SortOrder
    frequency?: SortOrder
    daysOfWeek?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    baseFare?: SortOrder
    pricingType?: SortOrder
    perKmRate?: SortOrderInput | SortOrder
    roundTripDiscount?: SortOrderInput | SortOrder
    totalSeats?: SortOrder
    availableSeats?: SortOrder
    farePerSeat?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isListedPublicly?: SortOrder
    allowDriverBidding?: SortOrder
    autoApproveRequests?: SortOrder
    minOccupancyRatio?: SortOrder
    maxOccupancyRatio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RouteCountOrderByAggregateInput
    _avg?: RouteAvgOrderByAggregateInput
    _max?: RouteMaxOrderByAggregateInput
    _min?: RouteMinOrderByAggregateInput
    _sum?: RouteSumOrderByAggregateInput
  }

  export type RouteScalarWhereWithAggregatesInput = {
    AND?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    OR?: RouteScalarWhereWithAggregatesInput[]
    NOT?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Route"> | string
    name?: StringWithAggregatesFilter<"Route"> | string
    description?: StringNullableWithAggregatesFilter<"Route"> | string | null
    routeType?: EnumRouteTypeWithAggregatesFilter<"Route"> | $Enums.RouteType
    frequency?: EnumRouteFrequencyWithAggregatesFilter<"Route"> | $Enums.RouteFrequency
    daysOfWeek?: IntNullableListFilter<"Route">
    startDate?: DateTimeWithAggregatesFilter<"Route"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Route"> | Date | string | null
    isRecurring?: BoolWithAggregatesFilter<"Route"> | boolean
    baseFare?: FloatWithAggregatesFilter<"Route"> | number
    pricingType?: EnumPricingTypeWithAggregatesFilter<"Route"> | $Enums.PricingType
    perKmRate?: FloatNullableWithAggregatesFilter<"Route"> | number | null
    roundTripDiscount?: FloatNullableWithAggregatesFilter<"Route"> | number | null
    totalSeats?: IntWithAggregatesFilter<"Route"> | number
    availableSeats?: IntWithAggregatesFilter<"Route"> | number
    farePerSeat?: FloatWithAggregatesFilter<"Route"> | number
    status?: EnumRouteStatusWithAggregatesFilter<"Route"> | $Enums.RouteStatus
    isActive?: BoolWithAggregatesFilter<"Route"> | boolean
    isListedPublicly?: BoolWithAggregatesFilter<"Route"> | boolean
    allowDriverBidding?: BoolWithAggregatesFilter<"Route"> | boolean
    autoApproveRequests?: BoolWithAggregatesFilter<"Route"> | boolean
    minOccupancyRatio?: FloatWithAggregatesFilter<"Route"> | number
    maxOccupancyRatio?: FloatWithAggregatesFilter<"Route"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Route"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Route"> | Date | string
  }

  export type RouteStopWhereInput = {
    AND?: RouteStopWhereInput | RouteStopWhereInput[]
    OR?: RouteStopWhereInput[]
    NOT?: RouteStopWhereInput | RouteStopWhereInput[]
    id?: StringFilter<"RouteStop"> | string
    routeId?: StringFilter<"RouteStop"> | string
    locationId?: StringFilter<"RouteStop"> | string
    sequence?: IntFilter<"RouteStop"> | number
    arrivalTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
    createdAt?: DateTimeFilter<"RouteStop"> | Date | string
    updatedAt?: DateTimeFilter<"RouteStop"> | Date | string
    dropRides?: RideListRelationFilter
    pickupRides?: RideListRelationFilter
    dropRequests?: RideRequestListRelationFilter
    pickupRequests?: RideRequestListRelationFilter
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }

  export type RouteStopOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    sequence?: SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dropRides?: RideOrderByRelationAggregateInput
    pickupRides?: RideOrderByRelationAggregateInput
    dropRequests?: RideRequestOrderByRelationAggregateInput
    pickupRequests?: RideRequestOrderByRelationAggregateInput
    location?: LocationOrderByWithRelationInput
    route?: RouteOrderByWithRelationInput
  }

  export type RouteStopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RouteStopWhereInput | RouteStopWhereInput[]
    OR?: RouteStopWhereInput[]
    NOT?: RouteStopWhereInput | RouteStopWhereInput[]
    routeId?: StringFilter<"RouteStop"> | string
    locationId?: StringFilter<"RouteStop"> | string
    sequence?: IntFilter<"RouteStop"> | number
    arrivalTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
    createdAt?: DateTimeFilter<"RouteStop"> | Date | string
    updatedAt?: DateTimeFilter<"RouteStop"> | Date | string
    dropRides?: RideListRelationFilter
    pickupRides?: RideListRelationFilter
    dropRequests?: RideRequestListRelationFilter
    pickupRequests?: RideRequestListRelationFilter
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }, "id">

  export type RouteStopOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    sequence?: SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RouteStopCountOrderByAggregateInput
    _avg?: RouteStopAvgOrderByAggregateInput
    _max?: RouteStopMaxOrderByAggregateInput
    _min?: RouteStopMinOrderByAggregateInput
    _sum?: RouteStopSumOrderByAggregateInput
  }

  export type RouteStopScalarWhereWithAggregatesInput = {
    AND?: RouteStopScalarWhereWithAggregatesInput | RouteStopScalarWhereWithAggregatesInput[]
    OR?: RouteStopScalarWhereWithAggregatesInput[]
    NOT?: RouteStopScalarWhereWithAggregatesInput | RouteStopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RouteStop"> | string
    routeId?: StringWithAggregatesFilter<"RouteStop"> | string
    locationId?: StringWithAggregatesFilter<"RouteStop"> | string
    sequence?: IntWithAggregatesFilter<"RouteStop"> | number
    arrivalTime?: DateTimeNullableWithAggregatesFilter<"RouteStop"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RouteStop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RouteStop"> | Date | string
  }

  export type RouteDriverWhereInput = {
    AND?: RouteDriverWhereInput | RouteDriverWhereInput[]
    OR?: RouteDriverWhereInput[]
    NOT?: RouteDriverWhereInput | RouteDriverWhereInput[]
    id?: StringFilter<"RouteDriver"> | string
    routeId?: StringFilter<"RouteDriver"> | string
    driverId?: StringFilter<"RouteDriver"> | string
    startDate?: DateTimeFilter<"RouteDriver"> | Date | string
    endDate?: DateTimeNullableFilter<"RouteDriver"> | Date | string | null
    isActive?: BoolFilter<"RouteDriver"> | boolean
    createdAt?: DateTimeFilter<"RouteDriver"> | Date | string
    updatedAt?: DateTimeFilter<"RouteDriver"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }

  export type RouteDriverOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    driver?: DriverOrderByWithRelationInput
    route?: RouteOrderByWithRelationInput
  }

  export type RouteDriverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RouteDriverWhereInput | RouteDriverWhereInput[]
    OR?: RouteDriverWhereInput[]
    NOT?: RouteDriverWhereInput | RouteDriverWhereInput[]
    routeId?: StringFilter<"RouteDriver"> | string
    driverId?: StringFilter<"RouteDriver"> | string
    startDate?: DateTimeFilter<"RouteDriver"> | Date | string
    endDate?: DateTimeNullableFilter<"RouteDriver"> | Date | string | null
    isActive?: BoolFilter<"RouteDriver"> | boolean
    createdAt?: DateTimeFilter<"RouteDriver"> | Date | string
    updatedAt?: DateTimeFilter<"RouteDriver"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }, "id">

  export type RouteDriverOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RouteDriverCountOrderByAggregateInput
    _max?: RouteDriverMaxOrderByAggregateInput
    _min?: RouteDriverMinOrderByAggregateInput
  }

  export type RouteDriverScalarWhereWithAggregatesInput = {
    AND?: RouteDriverScalarWhereWithAggregatesInput | RouteDriverScalarWhereWithAggregatesInput[]
    OR?: RouteDriverScalarWhereWithAggregatesInput[]
    NOT?: RouteDriverScalarWhereWithAggregatesInput | RouteDriverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RouteDriver"> | string
    routeId?: StringWithAggregatesFilter<"RouteDriver"> | string
    driverId?: StringWithAggregatesFilter<"RouteDriver"> | string
    startDate?: DateTimeWithAggregatesFilter<"RouteDriver"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"RouteDriver"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"RouteDriver"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RouteDriver"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RouteDriver"> | Date | string
  }

  export type TripWhereInput = {
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    id?: StringFilter<"Trip"> | string
    routeId?: StringFilter<"Trip"> | string
    driverId?: StringFilter<"Trip"> | string
    date?: DateTimeFilter<"Trip"> | Date | string
    status?: EnumTripStatusFilter<"Trip"> | $Enums.TripStatus
    startTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    rides?: RideListRelationFilter
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }

  export type TripOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rides?: RideOrderByRelationAggregateInput
    driver?: DriverOrderByWithRelationInput
    route?: RouteOrderByWithRelationInput
  }

  export type TripWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TripWhereInput | TripWhereInput[]
    OR?: TripWhereInput[]
    NOT?: TripWhereInput | TripWhereInput[]
    routeId?: StringFilter<"Trip"> | string
    driverId?: StringFilter<"Trip"> | string
    date?: DateTimeFilter<"Trip"> | Date | string
    status?: EnumTripStatusFilter<"Trip"> | $Enums.TripStatus
    startTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
    rides?: RideListRelationFilter
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }, "id">

  export type TripOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TripCountOrderByAggregateInput
    _max?: TripMaxOrderByAggregateInput
    _min?: TripMinOrderByAggregateInput
  }

  export type TripScalarWhereWithAggregatesInput = {
    AND?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    OR?: TripScalarWhereWithAggregatesInput[]
    NOT?: TripScalarWhereWithAggregatesInput | TripScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Trip"> | string
    routeId?: StringWithAggregatesFilter<"Trip"> | string
    driverId?: StringWithAggregatesFilter<"Trip"> | string
    date?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    status?: EnumTripStatusWithAggregatesFilter<"Trip"> | $Enums.TripStatus
    startTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Trip"> | Date | string
  }

  export type RideWhereInput = {
    AND?: RideWhereInput | RideWhereInput[]
    OR?: RideWhereInput[]
    NOT?: RideWhereInput | RideWhereInput[]
    id?: StringFilter<"Ride"> | string
    tripId?: StringFilter<"Ride"> | string
    teenId?: StringFilter<"Ride"> | string
    pickupStopId?: StringFilter<"Ride"> | string
    dropStopId?: StringFilter<"Ride"> | string
    status?: EnumRideStatusFilter<"Ride"> | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFilter<"Ride"> | Date | string
    actualPickupTime?: DateTimeNullableFilter<"Ride"> | Date | string | null
    scheduledDropTime?: DateTimeFilter<"Ride"> | Date | string
    actualDropTime?: DateTimeNullableFilter<"Ride"> | Date | string | null
    createdAt?: DateTimeFilter<"Ride"> | Date | string
    updatedAt?: DateTimeFilter<"Ride"> | Date | string
    dropStop?: XOR<RouteStopScalarRelationFilter, RouteStopWhereInput>
    pickupStop?: XOR<RouteStopScalarRelationFilter, RouteStopWhereInput>
    teen?: XOR<TeenScalarRelationFilter, TeenWhereInput>
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type RideOrderByWithRelationInput = {
    id?: SortOrder
    tripId?: SortOrder
    teenId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    status?: SortOrder
    scheduledPickupTime?: SortOrder
    actualPickupTime?: SortOrderInput | SortOrder
    scheduledDropTime?: SortOrder
    actualDropTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dropStop?: RouteStopOrderByWithRelationInput
    pickupStop?: RouteStopOrderByWithRelationInput
    teen?: TeenOrderByWithRelationInput
    trip?: TripOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type RideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RideWhereInput | RideWhereInput[]
    OR?: RideWhereInput[]
    NOT?: RideWhereInput | RideWhereInput[]
    tripId?: StringFilter<"Ride"> | string
    teenId?: StringFilter<"Ride"> | string
    pickupStopId?: StringFilter<"Ride"> | string
    dropStopId?: StringFilter<"Ride"> | string
    status?: EnumRideStatusFilter<"Ride"> | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFilter<"Ride"> | Date | string
    actualPickupTime?: DateTimeNullableFilter<"Ride"> | Date | string | null
    scheduledDropTime?: DateTimeFilter<"Ride"> | Date | string
    actualDropTime?: DateTimeNullableFilter<"Ride"> | Date | string | null
    createdAt?: DateTimeFilter<"Ride"> | Date | string
    updatedAt?: DateTimeFilter<"Ride"> | Date | string
    dropStop?: XOR<RouteStopScalarRelationFilter, RouteStopWhereInput>
    pickupStop?: XOR<RouteStopScalarRelationFilter, RouteStopWhereInput>
    teen?: XOR<TeenScalarRelationFilter, TeenWhereInput>
    trip?: XOR<TripScalarRelationFilter, TripWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id">

  export type RideOrderByWithAggregationInput = {
    id?: SortOrder
    tripId?: SortOrder
    teenId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    status?: SortOrder
    scheduledPickupTime?: SortOrder
    actualPickupTime?: SortOrderInput | SortOrder
    scheduledDropTime?: SortOrder
    actualDropTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RideCountOrderByAggregateInput
    _max?: RideMaxOrderByAggregateInput
    _min?: RideMinOrderByAggregateInput
  }

  export type RideScalarWhereWithAggregatesInput = {
    AND?: RideScalarWhereWithAggregatesInput | RideScalarWhereWithAggregatesInput[]
    OR?: RideScalarWhereWithAggregatesInput[]
    NOT?: RideScalarWhereWithAggregatesInput | RideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ride"> | string
    tripId?: StringWithAggregatesFilter<"Ride"> | string
    teenId?: StringWithAggregatesFilter<"Ride"> | string
    pickupStopId?: StringWithAggregatesFilter<"Ride"> | string
    dropStopId?: StringWithAggregatesFilter<"Ride"> | string
    status?: EnumRideStatusWithAggregatesFilter<"Ride"> | $Enums.RideStatus
    scheduledPickupTime?: DateTimeWithAggregatesFilter<"Ride"> | Date | string
    actualPickupTime?: DateTimeNullableWithAggregatesFilter<"Ride"> | Date | string | null
    scheduledDropTime?: DateTimeWithAggregatesFilter<"Ride"> | Date | string
    actualDropTime?: DateTimeNullableWithAggregatesFilter<"Ride"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ride"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ride"> | Date | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    userId?: StringFilter<"Parent"> | string
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    rideRequests?: RideRequestListRelationFilter
    teens?: TeenListRelationFilter
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    rideRequests?: RideRequestOrderByRelationAggregateInput
    teens?: TeenOrderByRelationAggregateInput
    wallet?: WalletOrderByWithRelationInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    rideRequests?: RideRequestListRelationFilter
    teens?: TeenListRelationFilter
    wallet?: XOR<WalletNullableScalarRelationFilter, WalletWhereInput> | null
  }, "id" | "userId">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    userId?: StringWithAggregatesFilter<"Parent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    id?: StringFilter<"Driver"> | string
    userId?: StringFilter<"Driver"> | string
    licenseNumber?: StringFilter<"Driver"> | string
    aadharNumber?: StringFilter<"Driver"> | string
    verificationStatus?: EnumVerificationStatusNullableFilter<"Driver"> | $Enums.VerificationStatus | null
    rating?: FloatFilter<"Driver"> | number
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    verification?: XOR<DriverVerificationNullableScalarRelationFilter, DriverVerificationWhereInput> | null
    routeAssignments?: RouteDriverListRelationFilter
    trips?: TripListRelationFilter
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    aadharNumber?: SortOrder
    verificationStatus?: SortOrderInput | SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    verification?: DriverVerificationOrderByWithRelationInput
    routeAssignments?: RouteDriverOrderByRelationAggregateInput
    trips?: TripOrderByRelationAggregateInput
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    licenseNumber?: string
    aadharNumber?: string
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    verificationStatus?: EnumVerificationStatusNullableFilter<"Driver"> | $Enums.VerificationStatus | null
    rating?: FloatFilter<"Driver"> | number
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    verification?: XOR<DriverVerificationNullableScalarRelationFilter, DriverVerificationWhereInput> | null
    routeAssignments?: RouteDriverListRelationFilter
    trips?: TripListRelationFilter
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
  }, "id" | "userId" | "licenseNumber" | "aadharNumber">

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    aadharNumber?: SortOrder
    verificationStatus?: SortOrderInput | SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _avg?: DriverAvgOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
    _sum?: DriverSumOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Driver"> | string
    userId?: StringWithAggregatesFilter<"Driver"> | string
    licenseNumber?: StringWithAggregatesFilter<"Driver"> | string
    aadharNumber?: StringWithAggregatesFilter<"Driver"> | string
    verificationStatus?: EnumVerificationStatusNullableWithAggregatesFilter<"Driver"> | $Enums.VerificationStatus | null
    rating?: FloatWithAggregatesFilter<"Driver"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
  }

  export type TeenWhereInput = {
    AND?: TeenWhereInput | TeenWhereInput[]
    OR?: TeenWhereInput[]
    NOT?: TeenWhereInput | TeenWhereInput[]
    id?: StringFilter<"Teen"> | string
    userId?: StringFilter<"Teen"> | string
    parentId?: StringFilter<"Teen"> | string
    inviteCode?: StringNullableFilter<"Teen"> | string | null
    inviteExpiry?: DateTimeNullableFilter<"Teen"> | Date | string | null
    inviteStatus?: EnumInviteStatusFilter<"Teen"> | $Enums.InviteStatus
    inviteType?: EnumInviteTypeNullableFilter<"Teen"> | $Enums.InviteType | null
    name?: StringFilter<"Teen"> | string
    age?: IntFilter<"Teen"> | number
    grade?: StringNullableFilter<"Teen"> | string | null
    avatar?: StringNullableFilter<"Teen"> | string | null
    schoolId?: StringNullableFilter<"Teen"> | string | null
    emergencyContact?: StringNullableFilter<"Teen"> | string | null
    medicalInfo?: StringNullableFilter<"Teen"> | string | null
    createdAt?: DateTimeFilter<"Teen"> | Date | string
    updatedAt?: DateTimeFilter<"Teen"> | Date | string
    rides?: RideListRelationFilter
    rideRequests?: RideRequestListRelationFilter
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
    school?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    buddyOf?: TeenBuddyListRelationFilter
    buddies?: TeenBuddyListRelationFilter
    rewards?: XOR<TeenRewardsNullableScalarRelationFilter, TeenRewardsWhereInput> | null
  }

  export type TeenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    inviteCode?: SortOrderInput | SortOrder
    inviteExpiry?: SortOrderInput | SortOrder
    inviteStatus?: SortOrder
    inviteType?: SortOrderInput | SortOrder
    name?: SortOrder
    age?: SortOrder
    grade?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    medicalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rides?: RideOrderByRelationAggregateInput
    rideRequests?: RideRequestOrderByRelationAggregateInput
    parent?: ParentOrderByWithRelationInput
    school?: LocationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    buddyOf?: TeenBuddyOrderByRelationAggregateInput
    buddies?: TeenBuddyOrderByRelationAggregateInput
    rewards?: TeenRewardsOrderByWithRelationInput
  }

  export type TeenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    inviteCode?: string
    AND?: TeenWhereInput | TeenWhereInput[]
    OR?: TeenWhereInput[]
    NOT?: TeenWhereInput | TeenWhereInput[]
    parentId?: StringFilter<"Teen"> | string
    inviteExpiry?: DateTimeNullableFilter<"Teen"> | Date | string | null
    inviteStatus?: EnumInviteStatusFilter<"Teen"> | $Enums.InviteStatus
    inviteType?: EnumInviteTypeNullableFilter<"Teen"> | $Enums.InviteType | null
    name?: StringFilter<"Teen"> | string
    age?: IntFilter<"Teen"> | number
    grade?: StringNullableFilter<"Teen"> | string | null
    avatar?: StringNullableFilter<"Teen"> | string | null
    schoolId?: StringNullableFilter<"Teen"> | string | null
    emergencyContact?: StringNullableFilter<"Teen"> | string | null
    medicalInfo?: StringNullableFilter<"Teen"> | string | null
    createdAt?: DateTimeFilter<"Teen"> | Date | string
    updatedAt?: DateTimeFilter<"Teen"> | Date | string
    rides?: RideListRelationFilter
    rideRequests?: RideRequestListRelationFilter
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
    school?: XOR<LocationNullableScalarRelationFilter, LocationWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    buddyOf?: TeenBuddyListRelationFilter
    buddies?: TeenBuddyListRelationFilter
    rewards?: XOR<TeenRewardsNullableScalarRelationFilter, TeenRewardsWhereInput> | null
  }, "id" | "userId" | "inviteCode">

  export type TeenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    inviteCode?: SortOrderInput | SortOrder
    inviteExpiry?: SortOrderInput | SortOrder
    inviteStatus?: SortOrder
    inviteType?: SortOrderInput | SortOrder
    name?: SortOrder
    age?: SortOrder
    grade?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    medicalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeenCountOrderByAggregateInput
    _avg?: TeenAvgOrderByAggregateInput
    _max?: TeenMaxOrderByAggregateInput
    _min?: TeenMinOrderByAggregateInput
    _sum?: TeenSumOrderByAggregateInput
  }

  export type TeenScalarWhereWithAggregatesInput = {
    AND?: TeenScalarWhereWithAggregatesInput | TeenScalarWhereWithAggregatesInput[]
    OR?: TeenScalarWhereWithAggregatesInput[]
    NOT?: TeenScalarWhereWithAggregatesInput | TeenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teen"> | string
    userId?: StringWithAggregatesFilter<"Teen"> | string
    parentId?: StringWithAggregatesFilter<"Teen"> | string
    inviteCode?: StringNullableWithAggregatesFilter<"Teen"> | string | null
    inviteExpiry?: DateTimeNullableWithAggregatesFilter<"Teen"> | Date | string | null
    inviteStatus?: EnumInviteStatusWithAggregatesFilter<"Teen"> | $Enums.InviteStatus
    inviteType?: EnumInviteTypeNullableWithAggregatesFilter<"Teen"> | $Enums.InviteType | null
    name?: StringWithAggregatesFilter<"Teen"> | string
    age?: IntWithAggregatesFilter<"Teen"> | number
    grade?: StringNullableWithAggregatesFilter<"Teen"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"Teen"> | string | null
    schoolId?: StringNullableWithAggregatesFilter<"Teen"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Teen"> | string | null
    medicalInfo?: StringNullableWithAggregatesFilter<"Teen"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Teen"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teen"> | Date | string
  }

  export type RideRequestWhereInput = {
    AND?: RideRequestWhereInput | RideRequestWhereInput[]
    OR?: RideRequestWhereInput[]
    NOT?: RideRequestWhereInput | RideRequestWhereInput[]
    id?: StringFilter<"RideRequest"> | string
    parentId?: StringFilter<"RideRequest"> | string
    teenId?: StringFilter<"RideRequest"> | string
    routeId?: StringFilter<"RideRequest"> | string
    pickupStopId?: StringFilter<"RideRequest"> | string
    dropStopId?: StringFilter<"RideRequest"> | string
    requestType?: EnumRequestTypeFilter<"RideRequest"> | $Enums.RequestType
    seatsRequired?: IntFilter<"RideRequest"> | number
    expectedPickupTime?: DateTimeFilter<"RideRequest"> | Date | string
    expectedDropTime?: DateTimeFilter<"RideRequest"> | Date | string
    status?: EnumRouteStatusFilter<"RideRequest"> | $Enums.RouteStatus
    createdAt?: DateTimeFilter<"RideRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RideRequest"> | Date | string
    dropStop?: XOR<RouteStopScalarRelationFilter, RouteStopWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
    pickupStop?: XOR<RouteStopScalarRelationFilter, RouteStopWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
    teen?: XOR<TeenScalarRelationFilter, TeenWhereInput>
  }

  export type RideRequestOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrder
    teenId?: SortOrder
    routeId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    requestType?: SortOrder
    seatsRequired?: SortOrder
    expectedPickupTime?: SortOrder
    expectedDropTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dropStop?: RouteStopOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    pickupStop?: RouteStopOrderByWithRelationInput
    route?: RouteOrderByWithRelationInput
    teen?: TeenOrderByWithRelationInput
  }

  export type RideRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RideRequestWhereInput | RideRequestWhereInput[]
    OR?: RideRequestWhereInput[]
    NOT?: RideRequestWhereInput | RideRequestWhereInput[]
    parentId?: StringFilter<"RideRequest"> | string
    teenId?: StringFilter<"RideRequest"> | string
    routeId?: StringFilter<"RideRequest"> | string
    pickupStopId?: StringFilter<"RideRequest"> | string
    dropStopId?: StringFilter<"RideRequest"> | string
    requestType?: EnumRequestTypeFilter<"RideRequest"> | $Enums.RequestType
    seatsRequired?: IntFilter<"RideRequest"> | number
    expectedPickupTime?: DateTimeFilter<"RideRequest"> | Date | string
    expectedDropTime?: DateTimeFilter<"RideRequest"> | Date | string
    status?: EnumRouteStatusFilter<"RideRequest"> | $Enums.RouteStatus
    createdAt?: DateTimeFilter<"RideRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RideRequest"> | Date | string
    dropStop?: XOR<RouteStopScalarRelationFilter, RouteStopWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
    pickupStop?: XOR<RouteStopScalarRelationFilter, RouteStopWhereInput>
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
    teen?: XOR<TeenScalarRelationFilter, TeenWhereInput>
  }, "id">

  export type RideRequestOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrder
    teenId?: SortOrder
    routeId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    requestType?: SortOrder
    seatsRequired?: SortOrder
    expectedPickupTime?: SortOrder
    expectedDropTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RideRequestCountOrderByAggregateInput
    _avg?: RideRequestAvgOrderByAggregateInput
    _max?: RideRequestMaxOrderByAggregateInput
    _min?: RideRequestMinOrderByAggregateInput
    _sum?: RideRequestSumOrderByAggregateInput
  }

  export type RideRequestScalarWhereWithAggregatesInput = {
    AND?: RideRequestScalarWhereWithAggregatesInput | RideRequestScalarWhereWithAggregatesInput[]
    OR?: RideRequestScalarWhereWithAggregatesInput[]
    NOT?: RideRequestScalarWhereWithAggregatesInput | RideRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RideRequest"> | string
    parentId?: StringWithAggregatesFilter<"RideRequest"> | string
    teenId?: StringWithAggregatesFilter<"RideRequest"> | string
    routeId?: StringWithAggregatesFilter<"RideRequest"> | string
    pickupStopId?: StringWithAggregatesFilter<"RideRequest"> | string
    dropStopId?: StringWithAggregatesFilter<"RideRequest"> | string
    requestType?: EnumRequestTypeWithAggregatesFilter<"RideRequest"> | $Enums.RequestType
    seatsRequired?: IntWithAggregatesFilter<"RideRequest"> | number
    expectedPickupTime?: DateTimeWithAggregatesFilter<"RideRequest"> | Date | string
    expectedDropTime?: DateTimeWithAggregatesFilter<"RideRequest"> | Date | string
    status?: EnumRouteStatusWithAggregatesFilter<"RideRequest"> | $Enums.RouteStatus
    createdAt?: DateTimeWithAggregatesFilter<"RideRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RideRequest"> | Date | string
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    driverId?: StringFilter<"Vehicle"> | string
    make?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    plateNumber?: StringFilter<"Vehicle"> | string
    capacity?: IntFilter<"Vehicle"> | number
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    driverId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    driver?: DriverOrderByWithRelationInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    driverId?: string
    plateNumber?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    make?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    capacity?: IntFilter<"Vehicle"> | number
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
  }, "id" | "driverId" | "plateNumber">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    driverId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicle"> | string
    driverId?: StringWithAggregatesFilter<"Vehicle"> | string
    make?: StringWithAggregatesFilter<"Vehicle"> | string
    model?: StringWithAggregatesFilter<"Vehicle"> | string
    year?: IntWithAggregatesFilter<"Vehicle"> | number
    plateNumber?: StringWithAggregatesFilter<"Vehicle"> | string
    capacity?: IntWithAggregatesFilter<"Vehicle"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
  }

  export type DriverVerificationWhereInput = {
    AND?: DriverVerificationWhereInput | DriverVerificationWhereInput[]
    OR?: DriverVerificationWhereInput[]
    NOT?: DriverVerificationWhereInput | DriverVerificationWhereInput[]
    id?: StringFilter<"DriverVerification"> | string
    driverId?: StringFilter<"DriverVerification"> | string
    status?: EnumVerificationStatusFilter<"DriverVerification"> | $Enums.VerificationStatus
    vehiclePhotos?: StringNullableListFilter<"DriverVerification">
    policeVerification?: StringNullableFilter<"DriverVerification"> | string | null
    backgroundCheck?: StringNullableFilter<"DriverVerification"> | string | null
    createdAt?: DateTimeFilter<"DriverVerification"> | Date | string
    updatedAt?: DateTimeFilter<"DriverVerification"> | Date | string
    documents?: DocumentListRelationFilter
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
  }

  export type DriverVerificationOrderByWithRelationInput = {
    id?: SortOrder
    driverId?: SortOrder
    status?: SortOrder
    vehiclePhotos?: SortOrder
    policeVerification?: SortOrderInput | SortOrder
    backgroundCheck?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documents?: DocumentOrderByRelationAggregateInput
    driver?: DriverOrderByWithRelationInput
  }

  export type DriverVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    driverId?: string
    AND?: DriverVerificationWhereInput | DriverVerificationWhereInput[]
    OR?: DriverVerificationWhereInput[]
    NOT?: DriverVerificationWhereInput | DriverVerificationWhereInput[]
    status?: EnumVerificationStatusFilter<"DriverVerification"> | $Enums.VerificationStatus
    vehiclePhotos?: StringNullableListFilter<"DriverVerification">
    policeVerification?: StringNullableFilter<"DriverVerification"> | string | null
    backgroundCheck?: StringNullableFilter<"DriverVerification"> | string | null
    createdAt?: DateTimeFilter<"DriverVerification"> | Date | string
    updatedAt?: DateTimeFilter<"DriverVerification"> | Date | string
    documents?: DocumentListRelationFilter
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
  }, "id" | "driverId">

  export type DriverVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    driverId?: SortOrder
    status?: SortOrder
    vehiclePhotos?: SortOrder
    policeVerification?: SortOrderInput | SortOrder
    backgroundCheck?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DriverVerificationCountOrderByAggregateInput
    _max?: DriverVerificationMaxOrderByAggregateInput
    _min?: DriverVerificationMinOrderByAggregateInput
  }

  export type DriverVerificationScalarWhereWithAggregatesInput = {
    AND?: DriverVerificationScalarWhereWithAggregatesInput | DriverVerificationScalarWhereWithAggregatesInput[]
    OR?: DriverVerificationScalarWhereWithAggregatesInput[]
    NOT?: DriverVerificationScalarWhereWithAggregatesInput | DriverVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DriverVerification"> | string
    driverId?: StringWithAggregatesFilter<"DriverVerification"> | string
    status?: EnumVerificationStatusWithAggregatesFilter<"DriverVerification"> | $Enums.VerificationStatus
    vehiclePhotos?: StringNullableListFilter<"DriverVerification">
    policeVerification?: StringNullableWithAggregatesFilter<"DriverVerification"> | string | null
    backgroundCheck?: StringNullableWithAggregatesFilter<"DriverVerification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DriverVerification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DriverVerification"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    number?: StringFilter<"Document"> | string
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    fileUrl?: StringFilter<"Document"> | string
    verificationId?: StringFilter<"Document"> | string
    status?: EnumVerificationStatusFilter<"Document"> | $Enums.VerificationStatus
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    verification?: XOR<DriverVerificationScalarRelationFilter, DriverVerificationWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    verificationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verification?: DriverVerificationOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    number?: StringFilter<"Document"> | string
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    fileUrl?: StringFilter<"Document"> | string
    verificationId?: StringFilter<"Document"> | string
    status?: EnumVerificationStatusFilter<"Document"> | $Enums.VerificationStatus
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    verification?: XOR<DriverVerificationScalarRelationFilter, DriverVerificationWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    verificationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    number?: StringWithAggregatesFilter<"Document"> | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    verificationId?: StringWithAggregatesFilter<"Document"> | string
    status?: EnumVerificationStatusWithAggregatesFilter<"Document"> | $Enums.VerificationStatus
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    balance?: FloatFilter<"Wallet"> | number
    parentId?: StringFilter<"Wallet"> | string
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    transactions?: TransactionListRelationFilter
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    balance?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    parent?: ParentOrderByWithRelationInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    parentId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    balance?: FloatFilter<"Wallet"> | number
    createdAt?: DateTimeFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    transactions?: TransactionListRelationFilter
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }, "id" | "parentId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    balance?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: FloatWithAggregatesFilter<"Wallet"> | number
    parentId?: StringWithAggregatesFilter<"Wallet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    walletId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumPaymentStatusFilter<"Transaction"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Transaction"> | string | null
    rideId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    ride?: XOR<RideNullableScalarRelationFilter, RideWhereInput> | null
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    rideId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ride?: RideOrderByWithRelationInput
    wallet?: WalletOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    walletId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumPaymentStatusFilter<"Transaction"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Transaction"> | string | null
    rideId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    ride?: XOR<RideNullableScalarRelationFilter, RideWhereInput> | null
    wallet?: XOR<WalletScalarRelationFilter, WalletWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    rideId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    walletId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumPaymentStatusWithAggregatesFilter<"Transaction"> | $Enums.PaymentStatus
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    rideId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type TeenBuddyWhereInput = {
    AND?: TeenBuddyWhereInput | TeenBuddyWhereInput[]
    OR?: TeenBuddyWhereInput[]
    NOT?: TeenBuddyWhereInput | TeenBuddyWhereInput[]
    id?: StringFilter<"TeenBuddy"> | string
    teenId?: StringFilter<"TeenBuddy"> | string
    buddyId?: StringFilter<"TeenBuddy"> | string
    status?: EnumBuddyStatusFilter<"TeenBuddy"> | $Enums.BuddyStatus
    createdAt?: DateTimeFilter<"TeenBuddy"> | Date | string
    updatedAt?: DateTimeFilter<"TeenBuddy"> | Date | string
    buddy?: XOR<TeenScalarRelationFilter, TeenWhereInput>
    teen?: XOR<TeenScalarRelationFilter, TeenWhereInput>
  }

  export type TeenBuddyOrderByWithRelationInput = {
    id?: SortOrder
    teenId?: SortOrder
    buddyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    buddy?: TeenOrderByWithRelationInput
    teen?: TeenOrderByWithRelationInput
  }

  export type TeenBuddyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeenBuddyWhereInput | TeenBuddyWhereInput[]
    OR?: TeenBuddyWhereInput[]
    NOT?: TeenBuddyWhereInput | TeenBuddyWhereInput[]
    teenId?: StringFilter<"TeenBuddy"> | string
    buddyId?: StringFilter<"TeenBuddy"> | string
    status?: EnumBuddyStatusFilter<"TeenBuddy"> | $Enums.BuddyStatus
    createdAt?: DateTimeFilter<"TeenBuddy"> | Date | string
    updatedAt?: DateTimeFilter<"TeenBuddy"> | Date | string
    buddy?: XOR<TeenScalarRelationFilter, TeenWhereInput>
    teen?: XOR<TeenScalarRelationFilter, TeenWhereInput>
  }, "id">

  export type TeenBuddyOrderByWithAggregationInput = {
    id?: SortOrder
    teenId?: SortOrder
    buddyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeenBuddyCountOrderByAggregateInput
    _max?: TeenBuddyMaxOrderByAggregateInput
    _min?: TeenBuddyMinOrderByAggregateInput
  }

  export type TeenBuddyScalarWhereWithAggregatesInput = {
    AND?: TeenBuddyScalarWhereWithAggregatesInput | TeenBuddyScalarWhereWithAggregatesInput[]
    OR?: TeenBuddyScalarWhereWithAggregatesInput[]
    NOT?: TeenBuddyScalarWhereWithAggregatesInput | TeenBuddyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeenBuddy"> | string
    teenId?: StringWithAggregatesFilter<"TeenBuddy"> | string
    buddyId?: StringWithAggregatesFilter<"TeenBuddy"> | string
    status?: EnumBuddyStatusWithAggregatesFilter<"TeenBuddy"> | $Enums.BuddyStatus
    createdAt?: DateTimeWithAggregatesFilter<"TeenBuddy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeenBuddy"> | Date | string
  }

  export type TeenRewardsWhereInput = {
    AND?: TeenRewardsWhereInput | TeenRewardsWhereInput[]
    OR?: TeenRewardsWhereInput[]
    NOT?: TeenRewardsWhereInput | TeenRewardsWhereInput[]
    id?: StringFilter<"TeenRewards"> | string
    teenId?: StringFilter<"TeenRewards"> | string
    points?: IntFilter<"TeenRewards"> | number
    level?: IntFilter<"TeenRewards"> | number
    createdAt?: DateTimeFilter<"TeenRewards"> | Date | string
    updatedAt?: DateTimeFilter<"TeenRewards"> | Date | string
    achievements?: AchievementListRelationFilter
    teen?: XOR<TeenScalarRelationFilter, TeenWhereInput>
  }

  export type TeenRewardsOrderByWithRelationInput = {
    id?: SortOrder
    teenId?: SortOrder
    points?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    achievements?: AchievementOrderByRelationAggregateInput
    teen?: TeenOrderByWithRelationInput
  }

  export type TeenRewardsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teenId?: string
    AND?: TeenRewardsWhereInput | TeenRewardsWhereInput[]
    OR?: TeenRewardsWhereInput[]
    NOT?: TeenRewardsWhereInput | TeenRewardsWhereInput[]
    points?: IntFilter<"TeenRewards"> | number
    level?: IntFilter<"TeenRewards"> | number
    createdAt?: DateTimeFilter<"TeenRewards"> | Date | string
    updatedAt?: DateTimeFilter<"TeenRewards"> | Date | string
    achievements?: AchievementListRelationFilter
    teen?: XOR<TeenScalarRelationFilter, TeenWhereInput>
  }, "id" | "teenId">

  export type TeenRewardsOrderByWithAggregationInput = {
    id?: SortOrder
    teenId?: SortOrder
    points?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeenRewardsCountOrderByAggregateInput
    _avg?: TeenRewardsAvgOrderByAggregateInput
    _max?: TeenRewardsMaxOrderByAggregateInput
    _min?: TeenRewardsMinOrderByAggregateInput
    _sum?: TeenRewardsSumOrderByAggregateInput
  }

  export type TeenRewardsScalarWhereWithAggregatesInput = {
    AND?: TeenRewardsScalarWhereWithAggregatesInput | TeenRewardsScalarWhereWithAggregatesInput[]
    OR?: TeenRewardsScalarWhereWithAggregatesInput[]
    NOT?: TeenRewardsScalarWhereWithAggregatesInput | TeenRewardsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeenRewards"> | string
    teenId?: StringWithAggregatesFilter<"TeenRewards"> | string
    points?: IntWithAggregatesFilter<"TeenRewards"> | number
    level?: IntWithAggregatesFilter<"TeenRewards"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TeenRewards"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeenRewards"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    rewardId?: StringFilter<"Achievement"> | string
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    reward?: XOR<TeenRewardsScalarRelationFilter, TeenRewardsWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    rewardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reward?: TeenRewardsOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    rewardId?: StringFilter<"Achievement"> | string
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    reward?: XOR<TeenRewardsScalarRelationFilter, TeenRewardsWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    rewardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    points?: IntWithAggregatesFilter<"Achievement"> | number
    rewardId?: StringWithAggregatesFilter<"Achievement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    permissions?: JsonNullableFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    permissions?: JsonNullableFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    permissions?: JsonNullableWithAggregatesFilter<"Admin">
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type TempTrackingLinkWhereInput = {
    AND?: TempTrackingLinkWhereInput | TempTrackingLinkWhereInput[]
    OR?: TempTrackingLinkWhereInput[]
    NOT?: TempTrackingLinkWhereInput | TempTrackingLinkWhereInput[]
    id?: StringFilter<"TempTrackingLink"> | string
    phoneNumber?: StringFilter<"TempTrackingLink"> | string
    deviceId?: StringFilter<"TempTrackingLink"> | string
    deviceName?: StringFilter<"TempTrackingLink"> | string
    trackingLink?: StringFilter<"TempTrackingLink"> | string
    expiresAt?: DateTimeFilter<"TempTrackingLink"> | Date | string
    createdAt?: DateTimeFilter<"TempTrackingLink"> | Date | string
    updatedAt?: DateTimeFilter<"TempTrackingLink"> | Date | string
  }

  export type TempTrackingLinkOrderByWithRelationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    trackingLink?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TempTrackingLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TempTrackingLinkWhereInput | TempTrackingLinkWhereInput[]
    OR?: TempTrackingLinkWhereInput[]
    NOT?: TempTrackingLinkWhereInput | TempTrackingLinkWhereInput[]
    phoneNumber?: StringFilter<"TempTrackingLink"> | string
    deviceId?: StringFilter<"TempTrackingLink"> | string
    deviceName?: StringFilter<"TempTrackingLink"> | string
    trackingLink?: StringFilter<"TempTrackingLink"> | string
    expiresAt?: DateTimeFilter<"TempTrackingLink"> | Date | string
    createdAt?: DateTimeFilter<"TempTrackingLink"> | Date | string
    updatedAt?: DateTimeFilter<"TempTrackingLink"> | Date | string
  }, "id">

  export type TempTrackingLinkOrderByWithAggregationInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    trackingLink?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TempTrackingLinkCountOrderByAggregateInput
    _max?: TempTrackingLinkMaxOrderByAggregateInput
    _min?: TempTrackingLinkMinOrderByAggregateInput
  }

  export type TempTrackingLinkScalarWhereWithAggregatesInput = {
    AND?: TempTrackingLinkScalarWhereWithAggregatesInput | TempTrackingLinkScalarWhereWithAggregatesInput[]
    OR?: TempTrackingLinkScalarWhereWithAggregatesInput[]
    NOT?: TempTrackingLinkScalarWhereWithAggregatesInput | TempTrackingLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TempTrackingLink"> | string
    phoneNumber?: StringWithAggregatesFilter<"TempTrackingLink"> | string
    deviceId?: StringWithAggregatesFilter<"TempTrackingLink"> | string
    deviceName?: StringWithAggregatesFilter<"TempTrackingLink"> | string
    trackingLink?: StringWithAggregatesFilter<"TempTrackingLink"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"TempTrackingLink"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"TempTrackingLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TempTrackingLink"> | Date | string
  }

  export type RouteFeaturesWhereInput = {
    AND?: RouteFeaturesWhereInput | RouteFeaturesWhereInput[]
    OR?: RouteFeaturesWhereInput[]
    NOT?: RouteFeaturesWhereInput | RouteFeaturesWhereInput[]
    id?: StringFilter<"RouteFeatures"> | string
    routeId?: StringFilter<"RouteFeatures"> | string
    liveTracking?: BoolFilter<"RouteFeatures"> | boolean
    videoSurveillance?: BoolFilter<"RouteFeatures"> | boolean
    childLocks?: BoolFilter<"RouteFeatures"> | boolean
    speedMonitoring?: BoolFilter<"RouteFeatures"> | boolean
    ac?: BoolFilter<"RouteFeatures"> | boolean
    parentAlerts?: BoolFilter<"RouteFeatures"> | boolean
    createdAt?: DateTimeFilter<"RouteFeatures"> | Date | string
    updatedAt?: DateTimeFilter<"RouteFeatures"> | Date | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }

  export type RouteFeaturesOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    liveTracking?: SortOrder
    videoSurveillance?: SortOrder
    childLocks?: SortOrder
    speedMonitoring?: SortOrder
    ac?: SortOrder
    parentAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    route?: RouteOrderByWithRelationInput
  }

  export type RouteFeaturesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    routeId?: string
    AND?: RouteFeaturesWhereInput | RouteFeaturesWhereInput[]
    OR?: RouteFeaturesWhereInput[]
    NOT?: RouteFeaturesWhereInput | RouteFeaturesWhereInput[]
    liveTracking?: BoolFilter<"RouteFeatures"> | boolean
    videoSurveillance?: BoolFilter<"RouteFeatures"> | boolean
    childLocks?: BoolFilter<"RouteFeatures"> | boolean
    speedMonitoring?: BoolFilter<"RouteFeatures"> | boolean
    ac?: BoolFilter<"RouteFeatures"> | boolean
    parentAlerts?: BoolFilter<"RouteFeatures"> | boolean
    createdAt?: DateTimeFilter<"RouteFeatures"> | Date | string
    updatedAt?: DateTimeFilter<"RouteFeatures"> | Date | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }, "id" | "routeId">

  export type RouteFeaturesOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    liveTracking?: SortOrder
    videoSurveillance?: SortOrder
    childLocks?: SortOrder
    speedMonitoring?: SortOrder
    ac?: SortOrder
    parentAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RouteFeaturesCountOrderByAggregateInput
    _max?: RouteFeaturesMaxOrderByAggregateInput
    _min?: RouteFeaturesMinOrderByAggregateInput
  }

  export type RouteFeaturesScalarWhereWithAggregatesInput = {
    AND?: RouteFeaturesScalarWhereWithAggregatesInput | RouteFeaturesScalarWhereWithAggregatesInput[]
    OR?: RouteFeaturesScalarWhereWithAggregatesInput[]
    NOT?: RouteFeaturesScalarWhereWithAggregatesInput | RouteFeaturesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RouteFeatures"> | string
    routeId?: StringWithAggregatesFilter<"RouteFeatures"> | string
    liveTracking?: BoolWithAggregatesFilter<"RouteFeatures"> | boolean
    videoSurveillance?: BoolWithAggregatesFilter<"RouteFeatures"> | boolean
    childLocks?: BoolWithAggregatesFilter<"RouteFeatures"> | boolean
    speedMonitoring?: BoolWithAggregatesFilter<"RouteFeatures"> | boolean
    ac?: BoolWithAggregatesFilter<"RouteFeatures"> | boolean
    parentAlerts?: BoolWithAggregatesFilter<"RouteFeatures"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RouteFeatures"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RouteFeatures"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    driver?: DriverCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    teen?: TeenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    teen?: TeenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    teen?: TeenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    teen?: TeenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    address: string
    latitude: number
    longitude: number
    type: $Enums.LocationType
    isVerified?: boolean
    contactNumber?: string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routeStops?: RouteStopCreateNestedManyWithoutLocationInput
    teens?: TeenCreateNestedManyWithoutSchoolInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    latitude: number
    longitude: number
    type: $Enums.LocationType
    isVerified?: boolean
    contactNumber?: string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutLocationInput
    teens?: TeenUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routeStops?: RouteStopUpdateManyWithoutLocationNestedInput
    teens?: TeenUpdateManyWithoutSchoolNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routeStops?: RouteStopUncheckedUpdateManyWithoutLocationNestedInput
    teens?: TeenUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    address: string
    latitude: number
    longitude: number
    type: $Enums.LocationType
    isVerified?: boolean
    contactNumber?: string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteCreateInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesCreateNestedOneWithoutRouteInput
    requests?: RideRequestCreateNestedManyWithoutRouteInput
    drivers?: RouteDriverCreateNestedManyWithoutRouteInput
    stops?: RouteStopCreateNestedManyWithoutRouteInput
    trips?: TripCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesUncheckedCreateNestedOneWithoutRouteInput
    requests?: RideRequestUncheckedCreateNestedManyWithoutRouteInput
    drivers?: RouteDriverUncheckedCreateNestedManyWithoutRouteInput
    stops?: RouteStopUncheckedCreateNestedManyWithoutRouteInput
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUpdateOneWithoutRouteNestedInput
    requests?: RideRequestUpdateManyWithoutRouteNestedInput
    drivers?: RouteDriverUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUpdateManyWithoutRouteNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUncheckedUpdateOneWithoutRouteNestedInput
    requests?: RideRequestUncheckedUpdateManyWithoutRouteNestedInput
    drivers?: RouteDriverUncheckedUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUncheckedUpdateManyWithoutRouteNestedInput
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteStopCreateInput = {
    id?: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideCreateNestedManyWithoutDropStopInput
    pickupRides?: RideCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestCreateNestedManyWithoutPickupStopInput
    location: LocationCreateNestedOneWithoutRouteStopsInput
    route: RouteCreateNestedOneWithoutStopsInput
  }

  export type RouteStopUncheckedCreateInput = {
    id?: string
    routeId: string
    locationId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideUncheckedCreateNestedManyWithoutDropStopInput
    pickupRides?: RideUncheckedCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestUncheckedCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestUncheckedCreateNestedManyWithoutPickupStopInput
  }

  export type RouteStopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUpdateManyWithoutPickupStopNestedInput
    location?: LocationUpdateOneRequiredWithoutRouteStopsNestedInput
    route?: RouteUpdateOneRequiredWithoutStopsNestedInput
  }

  export type RouteStopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUncheckedUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUncheckedUpdateManyWithoutPickupStopNestedInput
  }

  export type RouteStopCreateManyInput = {
    id?: string
    routeId: string
    locationId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteStopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteStopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteDriverCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    driver: DriverCreateNestedOneWithoutRouteAssignmentsInput
    route: RouteCreateNestedOneWithoutDriversInput
  }

  export type RouteDriverUncheckedCreateInput = {
    id?: string
    routeId: string
    driverId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteDriverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutRouteAssignmentsNestedInput
    route?: RouteUpdateOneRequiredWithoutDriversNestedInput
  }

  export type RouteDriverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteDriverCreateManyInput = {
    id?: string
    routeId: string
    driverId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteDriverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteDriverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripCreateInput = {
    id?: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTripInput
    driver: DriverCreateNestedOneWithoutTripsInput
    route: RouteCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateInput = {
    id?: string
    routeId: string
    driverId: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTripNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripCreateManyInput = {
    id?: string
    routeId: string
    driverId: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideCreateInput = {
    id?: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRidesInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRidesInput
    teen: TeenCreateNestedOneWithoutRidesInput
    trip: TripCreateNestedOneWithoutRidesInput
    transactions?: TransactionCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateInput = {
    id?: string
    tripId: string
    teenId: string
    pickupStopId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRidesNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRidesNestedInput
    teen?: TeenUpdateOneRequiredWithoutRidesNestedInput
    trip?: TripUpdateOneRequiredWithoutRidesNestedInput
    transactions?: TransactionUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideCreateManyInput = {
    id?: string
    tripId: string
    teenId: string
    pickupStopId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
    rideRequests?: RideRequestCreateNestedManyWithoutParentInput
    teens?: TeenCreateNestedManyWithoutParentInput
    wallet?: WalletCreateNestedOneWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutParentInput
    teens?: TeenUncheckedCreateNestedManyWithoutParentInput
    wallet?: WalletUncheckedCreateNestedOneWithoutParentInput
  }

  export type ParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    rideRequests?: RideRequestUpdateManyWithoutParentNestedInput
    teens?: TeenUpdateManyWithoutParentNestedInput
    wallet?: WalletUpdateOneWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideRequests?: RideRequestUncheckedUpdateManyWithoutParentNestedInput
    teens?: TeenUncheckedUpdateManyWithoutParentNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    id?: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverInput
    verification?: DriverVerificationCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverCreateNestedManyWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
    vehicle?: VehicleCreateNestedOneWithoutDriverInput
  }

  export type DriverUncheckedCreateInput = {
    id?: string
    userId: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verification?: DriverVerificationUncheckedCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
    vehicle?: VehicleUncheckedCreateNestedOneWithoutDriverInput
  }

  export type DriverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    verification?: DriverVerificationUpdateOneWithoutDriverNestedInput
    routeAssignments?: RouteDriverUpdateManyWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUpdateOneWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verification?: DriverVerificationUncheckedUpdateOneWithoutDriverNestedInput
    routeAssignments?: RouteDriverUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type DriverCreateManyInput = {
    id?: string
    userId: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenCreateInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestCreateNestedManyWithoutTeenInput
    parent: ParentCreateNestedOneWithoutTeensInput
    school?: LocationCreateNestedOneWithoutTeensInput
    user: UserCreateNestedOneWithoutTeenInput
    buddyOf?: TeenBuddyCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsCreateNestedOneWithoutTeenInput
  }

  export type TeenUncheckedCreateInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutTeenInput
    buddyOf?: TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyUncheckedCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsUncheckedCreateNestedOneWithoutTeenInput
  }

  export type TeenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUpdateManyWithoutTeenNestedInput
    parent?: ParentUpdateOneRequiredWithoutTeensNestedInput
    school?: LocationUpdateOneWithoutTeensNestedInput
    user?: UserUpdateOneRequiredWithoutTeenNestedInput
    buddyOf?: TeenBuddyUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUncheckedUpdateManyWithoutTeenNestedInput
    buddyOf?: TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput
  }

  export type TeenCreateManyInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestCreateInput = {
    id?: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRequestsInput
    parent: ParentCreateNestedOneWithoutRideRequestsInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRequestsInput
    route: RouteCreateNestedOneWithoutRequestsInput
    teen: TeenCreateNestedOneWithoutRideRequestsInput
  }

  export type RideRequestUncheckedCreateInput = {
    id?: string
    parentId: string
    teenId: string
    routeId: string
    pickupStopId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRequestsNestedInput
    parent?: ParentUpdateOneRequiredWithoutRideRequestsNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRequestsNestedInput
    route?: RouteUpdateOneRequiredWithoutRequestsNestedInput
    teen?: TeenUpdateOneRequiredWithoutRideRequestsNestedInput
  }

  export type RideRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestCreateManyInput = {
    id?: string
    parentId: string
    teenId: string
    routeId: string
    pickupStopId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateInput = {
    id?: string
    make: string
    model: string
    year: number
    plateNumber: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    driver: DriverCreateNestedOneWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    driverId: string
    make: string
    model: string
    year: number
    plateNumber: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateManyInput = {
    id?: string
    driverId: string
    make: string
    model: string
    year: number
    plateNumber: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVerificationCreateInput = {
    id?: string
    status?: $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationCreatevehiclePhotosInput | string[]
    policeVerification?: string | null
    backgroundCheck?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutVerificationInput
    driver: DriverCreateNestedOneWithoutVerificationInput
  }

  export type DriverVerificationUncheckedCreateInput = {
    id?: string
    driverId: string
    status?: $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationCreatevehiclePhotosInput | string[]
    policeVerification?: string | null
    backgroundCheck?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutVerificationInput
  }

  export type DriverVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationUpdatevehiclePhotosInput | string[]
    policeVerification?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutVerificationNestedInput
    driver?: DriverUpdateOneRequiredWithoutVerificationNestedInput
  }

  export type DriverVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationUpdatevehiclePhotosInput | string[]
    policeVerification?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutVerificationNestedInput
  }

  export type DriverVerificationCreateManyInput = {
    id?: string
    driverId: string
    status?: $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationCreatevehiclePhotosInput | string[]
    policeVerification?: string | null
    backgroundCheck?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationUpdatevehiclePhotosInput | string[]
    policeVerification?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationUpdatevehiclePhotosInput | string[]
    policeVerification?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    expiryDate?: Date | string | null
    fileUrl: string
    status?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    verification: DriverVerificationCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    expiryDate?: Date | string | null
    fileUrl: string
    verificationId: string
    status?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verification?: DriverVerificationUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationId?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    expiryDate?: Date | string | null
    fileUrl: string
    verificationId: string
    status?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    verificationId?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutWalletInput
    parent: ParentCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    balance?: number
    parentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutWalletNestedInput
    parent?: ParentUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    parentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    balance?: number
    parentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    parentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ride?: RideCreateNestedOneWithoutTransactionsInput
    wallet: WalletCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    walletId: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    rideId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: RideUpdateOneWithoutTransactionsNestedInput
    wallet?: WalletUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    walletId: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    rideId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenBuddyCreateInput = {
    id?: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    buddy: TeenCreateNestedOneWithoutBuddyOfInput
    teen: TeenCreateNestedOneWithoutBuddiesInput
  }

  export type TeenBuddyUncheckedCreateInput = {
    id?: string
    teenId: string
    buddyId: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenBuddyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buddy?: TeenUpdateOneRequiredWithoutBuddyOfNestedInput
    teen?: TeenUpdateOneRequiredWithoutBuddiesNestedInput
  }

  export type TeenBuddyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    buddyId?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenBuddyCreateManyInput = {
    id?: string
    teenId: string
    buddyId: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenBuddyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenBuddyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    buddyId?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenRewardsCreateInput = {
    id?: string
    points?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementCreateNestedManyWithoutRewardInput
    teen: TeenCreateNestedOneWithoutRewardsInput
  }

  export type TeenRewardsUncheckedCreateInput = {
    id?: string
    teenId: string
    points?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementUncheckedCreateNestedManyWithoutRewardInput
  }

  export type TeenRewardsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUpdateManyWithoutRewardNestedInput
    teen?: TeenUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type TeenRewardsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type TeenRewardsCreateManyInput = {
    id?: string
    teenId: string
    points?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenRewardsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenRewardsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    description: string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reward: TeenRewardsCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    points: number
    rewardId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reward?: TeenRewardsUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    rewardId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyInput = {
    id?: string
    name: string
    description: string
    points: number
    rewardId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    rewardId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempTrackingLinkCreateInput = {
    id?: string
    phoneNumber: string
    deviceId: string
    deviceName: string
    trackingLink: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempTrackingLinkUncheckedCreateInput = {
    id?: string
    phoneNumber: string
    deviceId: string
    deviceName: string
    trackingLink: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempTrackingLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    trackingLink?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempTrackingLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    trackingLink?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempTrackingLinkCreateManyInput = {
    id?: string
    phoneNumber: string
    deviceId: string
    deviceName: string
    trackingLink: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TempTrackingLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    trackingLink?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TempTrackingLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    deviceName?: StringFieldUpdateOperationsInput | string
    trackingLink?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFeaturesCreateInput = {
    id?: string
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    route: RouteCreateNestedOneWithoutFeaturesInput
  }

  export type RouteFeaturesUncheckedCreateInput = {
    id?: string
    routeId: string
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFeaturesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    liveTracking?: BoolFieldUpdateOperationsInput | boolean
    videoSurveillance?: BoolFieldUpdateOperationsInput | boolean
    childLocks?: BoolFieldUpdateOperationsInput | boolean
    speedMonitoring?: BoolFieldUpdateOperationsInput | boolean
    ac?: BoolFieldUpdateOperationsInput | boolean
    parentAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: RouteUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type RouteFeaturesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    liveTracking?: BoolFieldUpdateOperationsInput | boolean
    videoSurveillance?: BoolFieldUpdateOperationsInput | boolean
    childLocks?: BoolFieldUpdateOperationsInput | boolean
    speedMonitoring?: BoolFieldUpdateOperationsInput | boolean
    ac?: BoolFieldUpdateOperationsInput | boolean
    parentAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFeaturesCreateManyInput = {
    id?: string
    routeId: string
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFeaturesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    liveTracking?: BoolFieldUpdateOperationsInput | boolean
    videoSurveillance?: BoolFieldUpdateOperationsInput | boolean
    childLocks?: BoolFieldUpdateOperationsInput | boolean
    speedMonitoring?: BoolFieldUpdateOperationsInput | boolean
    ac?: BoolFieldUpdateOperationsInput | boolean
    parentAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFeaturesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    liveTracking?: BoolFieldUpdateOperationsInput | boolean
    videoSurveillance?: BoolFieldUpdateOperationsInput | boolean
    childLocks?: BoolFieldUpdateOperationsInput | boolean
    speedMonitoring?: BoolFieldUpdateOperationsInput | boolean
    ac?: BoolFieldUpdateOperationsInput | boolean
    parentAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type DriverNullableScalarRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type ParentNullableScalarRelationFilter = {
    is?: ParentWhereInput | null
    isNot?: ParentWhereInput | null
  }

  export type TeenNullableScalarRelationFilter = {
    is?: TeenWhereInput | null
    isNot?: TeenWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RouteStopListRelationFilter = {
    every?: RouteStopWhereInput
    some?: RouteStopWhereInput
    none?: RouteStopWhereInput
  }

  export type TeenListRelationFilter = {
    every?: TeenWhereInput
    some?: TeenWhereInput
    none?: TeenWhereInput
  }

  export type RouteStopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    type?: SortOrder
    isVerified?: SortOrder
    contactNumber?: SortOrder
    operatingHours?: SortOrder
    createdBy?: SortOrder
    verifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    type?: SortOrder
    isVerified?: SortOrder
    contactNumber?: SortOrder
    createdBy?: SortOrder
    verifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    type?: SortOrder
    isVerified?: SortOrder
    contactNumber?: SortOrder
    createdBy?: SortOrder
    verifiedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumRouteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteType | EnumRouteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RouteType[] | ListEnumRouteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteType[] | ListEnumRouteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteTypeFilter<$PrismaModel> | $Enums.RouteType
  }

  export type EnumRouteFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteFrequency | EnumRouteFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RouteFrequency[] | ListEnumRouteFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteFrequency[] | ListEnumRouteFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteFrequencyFilter<$PrismaModel> | $Enums.RouteFrequency
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumPricingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeFilter<$PrismaModel> | $Enums.PricingType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumRouteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteStatus | EnumRouteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RouteStatus[] | ListEnumRouteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteStatus[] | ListEnumRouteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteStatusFilter<$PrismaModel> | $Enums.RouteStatus
  }

  export type RouteFeaturesNullableScalarRelationFilter = {
    is?: RouteFeaturesWhereInput | null
    isNot?: RouteFeaturesWhereInput | null
  }

  export type RideRequestListRelationFilter = {
    every?: RideRequestWhereInput
    some?: RideRequestWhereInput
    none?: RideRequestWhereInput
  }

  export type RouteDriverListRelationFilter = {
    every?: RouteDriverWhereInput
    some?: RouteDriverWhereInput
    none?: RouteDriverWhereInput
  }

  export type TripListRelationFilter = {
    every?: TripWhereInput
    some?: TripWhereInput
    none?: TripWhereInput
  }

  export type RideRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteDriverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    routeType?: SortOrder
    frequency?: SortOrder
    daysOfWeek?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isRecurring?: SortOrder
    baseFare?: SortOrder
    pricingType?: SortOrder
    perKmRate?: SortOrder
    roundTripDiscount?: SortOrder
    totalSeats?: SortOrder
    availableSeats?: SortOrder
    farePerSeat?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isListedPublicly?: SortOrder
    allowDriverBidding?: SortOrder
    autoApproveRequests?: SortOrder
    minOccupancyRatio?: SortOrder
    maxOccupancyRatio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteAvgOrderByAggregateInput = {
    daysOfWeek?: SortOrder
    baseFare?: SortOrder
    perKmRate?: SortOrder
    roundTripDiscount?: SortOrder
    totalSeats?: SortOrder
    availableSeats?: SortOrder
    farePerSeat?: SortOrder
    minOccupancyRatio?: SortOrder
    maxOccupancyRatio?: SortOrder
  }

  export type RouteMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    routeType?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isRecurring?: SortOrder
    baseFare?: SortOrder
    pricingType?: SortOrder
    perKmRate?: SortOrder
    roundTripDiscount?: SortOrder
    totalSeats?: SortOrder
    availableSeats?: SortOrder
    farePerSeat?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isListedPublicly?: SortOrder
    allowDriverBidding?: SortOrder
    autoApproveRequests?: SortOrder
    minOccupancyRatio?: SortOrder
    maxOccupancyRatio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    routeType?: SortOrder
    frequency?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isRecurring?: SortOrder
    baseFare?: SortOrder
    pricingType?: SortOrder
    perKmRate?: SortOrder
    roundTripDiscount?: SortOrder
    totalSeats?: SortOrder
    availableSeats?: SortOrder
    farePerSeat?: SortOrder
    status?: SortOrder
    isActive?: SortOrder
    isListedPublicly?: SortOrder
    allowDriverBidding?: SortOrder
    autoApproveRequests?: SortOrder
    minOccupancyRatio?: SortOrder
    maxOccupancyRatio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteSumOrderByAggregateInput = {
    daysOfWeek?: SortOrder
    baseFare?: SortOrder
    perKmRate?: SortOrder
    roundTripDiscount?: SortOrder
    totalSeats?: SortOrder
    availableSeats?: SortOrder
    farePerSeat?: SortOrder
    minOccupancyRatio?: SortOrder
    maxOccupancyRatio?: SortOrder
  }

  export type EnumRouteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteType | EnumRouteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RouteType[] | ListEnumRouteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteType[] | ListEnumRouteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteTypeWithAggregatesFilter<$PrismaModel> | $Enums.RouteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRouteTypeFilter<$PrismaModel>
    _max?: NestedEnumRouteTypeFilter<$PrismaModel>
  }

  export type EnumRouteFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteFrequency | EnumRouteFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RouteFrequency[] | ListEnumRouteFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteFrequency[] | ListEnumRouteFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.RouteFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRouteFrequencyFilter<$PrismaModel>
    _max?: NestedEnumRouteFrequencyFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPricingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PricingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingTypeFilter<$PrismaModel>
    _max?: NestedEnumPricingTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumRouteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteStatus | EnumRouteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RouteStatus[] | ListEnumRouteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteStatus[] | ListEnumRouteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteStatusWithAggregatesFilter<$PrismaModel> | $Enums.RouteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRouteStatusFilter<$PrismaModel>
    _max?: NestedEnumRouteStatusFilter<$PrismaModel>
  }

  export type RideListRelationFilter = {
    every?: RideWhereInput
    some?: RideWhereInput
    none?: RideWhereInput
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type RouteScalarRelationFilter = {
    is?: RouteWhereInput
    isNot?: RouteWhereInput
  }

  export type RideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteStopCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    sequence?: SortOrder
    arrivalTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteStopAvgOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type RouteStopMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    sequence?: SortOrder
    arrivalTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteStopMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    sequence?: SortOrder
    arrivalTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteStopSumOrderByAggregateInput = {
    sequence?: SortOrder
  }

  export type DriverScalarRelationFilter = {
    is?: DriverWhereInput
    isNot?: DriverWhereInput
  }

  export type RouteDriverCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteDriverMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteDriverMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTripStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TripStatus | EnumTripStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTripStatusFilter<$PrismaModel> | $Enums.TripStatus
  }

  export type TripCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    driverId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTripStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TripStatus | EnumTripStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTripStatusWithAggregatesFilter<$PrismaModel> | $Enums.TripStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTripStatusFilter<$PrismaModel>
    _max?: NestedEnumTripStatusFilter<$PrismaModel>
  }

  export type EnumRideStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RideStatus | EnumRideStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRideStatusFilter<$PrismaModel> | $Enums.RideStatus
  }

  export type RouteStopScalarRelationFilter = {
    is?: RouteStopWhereInput
    isNot?: RouteStopWhereInput
  }

  export type TeenScalarRelationFilter = {
    is?: TeenWhereInput
    isNot?: TeenWhereInput
  }

  export type TripScalarRelationFilter = {
    is?: TripWhereInput
    isNot?: TripWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RideCountOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    teenId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    status?: SortOrder
    scheduledPickupTime?: SortOrder
    actualPickupTime?: SortOrder
    scheduledDropTime?: SortOrder
    actualDropTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RideMaxOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    teenId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    status?: SortOrder
    scheduledPickupTime?: SortOrder
    actualPickupTime?: SortOrder
    scheduledDropTime?: SortOrder
    actualDropTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RideMinOrderByAggregateInput = {
    id?: SortOrder
    tripId?: SortOrder
    teenId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    status?: SortOrder
    scheduledPickupTime?: SortOrder
    actualPickupTime?: SortOrder
    scheduledDropTime?: SortOrder
    actualDropTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRideStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RideStatus | EnumRideStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRideStatusWithAggregatesFilter<$PrismaModel> | $Enums.RideStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRideStatusFilter<$PrismaModel>
    _max?: NestedEnumRideStatusFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type WalletNullableScalarRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVerificationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationStatusNullableFilter<$PrismaModel> | $Enums.VerificationStatus | null
  }

  export type DriverVerificationNullableScalarRelationFilter = {
    is?: DriverVerificationWhereInput | null
    isNot?: DriverVerificationWhereInput | null
  }

  export type VehicleNullableScalarRelationFilter = {
    is?: VehicleWhereInput | null
    isNot?: VehicleWhereInput | null
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    aadharNumber?: SortOrder
    verificationStatus?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    aadharNumber?: SortOrder
    verificationStatus?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    aadharNumber?: SortOrder
    verificationStatus?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumVerificationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusNullableFilter<$PrismaModel>
  }

  export type EnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type EnumInviteTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteType | EnumInviteTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.InviteType[] | ListEnumInviteTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InviteType[] | ListEnumInviteTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInviteTypeNullableFilter<$PrismaModel> | $Enums.InviteType | null
  }

  export type ParentScalarRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type LocationNullableScalarRelationFilter = {
    is?: LocationWhereInput | null
    isNot?: LocationWhereInput | null
  }

  export type TeenBuddyListRelationFilter = {
    every?: TeenBuddyWhereInput
    some?: TeenBuddyWhereInput
    none?: TeenBuddyWhereInput
  }

  export type TeenRewardsNullableScalarRelationFilter = {
    is?: TeenRewardsWhereInput | null
    isNot?: TeenRewardsWhereInput | null
  }

  export type TeenBuddyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    inviteCode?: SortOrder
    inviteExpiry?: SortOrder
    inviteStatus?: SortOrder
    inviteType?: SortOrder
    name?: SortOrder
    age?: SortOrder
    grade?: SortOrder
    avatar?: SortOrder
    schoolId?: SortOrder
    emergencyContact?: SortOrder
    medicalInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeenAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type TeenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    inviteCode?: SortOrder
    inviteExpiry?: SortOrder
    inviteStatus?: SortOrder
    inviteType?: SortOrder
    name?: SortOrder
    age?: SortOrder
    grade?: SortOrder
    avatar?: SortOrder
    schoolId?: SortOrder
    emergencyContact?: SortOrder
    medicalInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    parentId?: SortOrder
    inviteCode?: SortOrder
    inviteExpiry?: SortOrder
    inviteStatus?: SortOrder
    inviteType?: SortOrder
    name?: SortOrder
    age?: SortOrder
    grade?: SortOrder
    avatar?: SortOrder
    schoolId?: SortOrder
    emergencyContact?: SortOrder
    medicalInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeenSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type EnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type EnumInviteTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteType | EnumInviteTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.InviteType[] | ListEnumInviteTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InviteType[] | ListEnumInviteTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInviteTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.InviteType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInviteTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumInviteTypeNullableFilter<$PrismaModel>
  }

  export type EnumRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeFilter<$PrismaModel> | $Enums.RequestType
  }

  export type RideRequestCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    teenId?: SortOrder
    routeId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    requestType?: SortOrder
    seatsRequired?: SortOrder
    expectedPickupTime?: SortOrder
    expectedDropTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RideRequestAvgOrderByAggregateInput = {
    seatsRequired?: SortOrder
  }

  export type RideRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    teenId?: SortOrder
    routeId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    requestType?: SortOrder
    seatsRequired?: SortOrder
    expectedPickupTime?: SortOrder
    expectedDropTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RideRequestMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    teenId?: SortOrder
    routeId?: SortOrder
    pickupStopId?: SortOrder
    dropStopId?: SortOrder
    requestType?: SortOrder
    seatsRequired?: SortOrder
    expectedPickupTime?: SortOrder
    expectedDropTime?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RideRequestSumOrderByAggregateInput = {
    seatsRequired?: SortOrder
  }

  export type EnumRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.RequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumRequestTypeFilter<$PrismaModel>
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    year?: SortOrder
    capacity?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    make?: SortOrder
    model?: SortOrder
    year?: SortOrder
    plateNumber?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    year?: SortOrder
    capacity?: SortOrder
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    status?: SortOrder
    vehiclePhotos?: SortOrder
    policeVerification?: SortOrder
    backgroundCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    status?: SortOrder
    policeVerification?: SortOrder
    backgroundCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    status?: SortOrder
    policeVerification?: SortOrder
    backgroundCheck?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type DriverVerificationScalarRelationFilter = {
    is?: DriverVerificationWhereInput
    isNot?: DriverVerificationWhereInput
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    expiryDate?: SortOrder
    fileUrl?: SortOrder
    verificationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    expiryDate?: SortOrder
    fileUrl?: SortOrder
    verificationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    number?: SortOrder
    expiryDate?: SortOrder
    fileUrl?: SortOrder
    verificationId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    balance?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type RideNullableScalarRelationFilter = {
    is?: RideWhereInput | null
    isNot?: RideWhereInput | null
  }

  export type WalletScalarRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    rideId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    rideId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    rideId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumBuddyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BuddyStatus | EnumBuddyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BuddyStatus[] | ListEnumBuddyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BuddyStatus[] | ListEnumBuddyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBuddyStatusFilter<$PrismaModel> | $Enums.BuddyStatus
  }

  export type TeenBuddyCountOrderByAggregateInput = {
    id?: SortOrder
    teenId?: SortOrder
    buddyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeenBuddyMaxOrderByAggregateInput = {
    id?: SortOrder
    teenId?: SortOrder
    buddyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeenBuddyMinOrderByAggregateInput = {
    id?: SortOrder
    teenId?: SortOrder
    buddyId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBuddyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BuddyStatus | EnumBuddyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BuddyStatus[] | ListEnumBuddyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BuddyStatus[] | ListEnumBuddyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBuddyStatusWithAggregatesFilter<$PrismaModel> | $Enums.BuddyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBuddyStatusFilter<$PrismaModel>
    _max?: NestedEnumBuddyStatusFilter<$PrismaModel>
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeenRewardsCountOrderByAggregateInput = {
    id?: SortOrder
    teenId?: SortOrder
    points?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeenRewardsAvgOrderByAggregateInput = {
    points?: SortOrder
    level?: SortOrder
  }

  export type TeenRewardsMaxOrderByAggregateInput = {
    id?: SortOrder
    teenId?: SortOrder
    points?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeenRewardsMinOrderByAggregateInput = {
    id?: SortOrder
    teenId?: SortOrder
    points?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeenRewardsSumOrderByAggregateInput = {
    points?: SortOrder
    level?: SortOrder
  }

  export type TeenRewardsScalarRelationFilter = {
    is?: TeenRewardsWhereInput
    isNot?: TeenRewardsWhereInput
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    rewardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    rewardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    points?: SortOrder
    rewardId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TempTrackingLinkCountOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    trackingLink?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TempTrackingLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    trackingLink?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TempTrackingLinkMinOrderByAggregateInput = {
    id?: SortOrder
    phoneNumber?: SortOrder
    deviceId?: SortOrder
    deviceName?: SortOrder
    trackingLink?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteFeaturesCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    liveTracking?: SortOrder
    videoSurveillance?: SortOrder
    childLocks?: SortOrder
    speedMonitoring?: SortOrder
    ac?: SortOrder
    parentAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteFeaturesMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    liveTracking?: SortOrder
    videoSurveillance?: SortOrder
    childLocks?: SortOrder
    speedMonitoring?: SortOrder
    ac?: SortOrder
    parentAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteFeaturesMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    liveTracking?: SortOrder
    videoSurveillance?: SortOrder
    childLocks?: SortOrder
    speedMonitoring?: SortOrder
    ac?: SortOrder
    parentAlerts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    connect?: DriverWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type TeenCreateNestedOneWithoutUserInput = {
    create?: XOR<TeenCreateWithoutUserInput, TeenUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeenCreateOrConnectWithoutUserInput
    connect?: TeenWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type DriverUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    connect?: DriverWhereUniqueInput
  }

  export type ParentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type TeenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeenCreateWithoutUserInput, TeenUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeenCreateOrConnectWithoutUserInput
    connect?: TeenWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type DriverUpdateOneWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    upsert?: DriverUpsertWithoutUserInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutUserInput, DriverUpdateWithoutUserInput>, DriverUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type TeenUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeenCreateWithoutUserInput, TeenUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeenCreateOrConnectWithoutUserInput
    upsert?: TeenUpsertWithoutUserInput
    disconnect?: TeenWhereInput | boolean
    delete?: TeenWhereInput | boolean
    connect?: TeenWhereUniqueInput
    update?: XOR<XOR<TeenUpdateToOneWithWhereWithoutUserInput, TeenUpdateWithoutUserInput>, TeenUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type DriverUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    upsert?: DriverUpsertWithoutUserInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutUserInput, DriverUpdateWithoutUserInput>, DriverUncheckedUpdateWithoutUserInput>
  }

  export type ParentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type TeenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeenCreateWithoutUserInput, TeenUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeenCreateOrConnectWithoutUserInput
    upsert?: TeenUpsertWithoutUserInput
    disconnect?: TeenWhereInput | boolean
    delete?: TeenWhereInput | boolean
    connect?: TeenWhereUniqueInput
    update?: XOR<XOR<TeenUpdateToOneWithWhereWithoutUserInput, TeenUpdateWithoutUserInput>, TeenUncheckedUpdateWithoutUserInput>
  }

  export type RouteStopCreateNestedManyWithoutLocationInput = {
    create?: XOR<RouteStopCreateWithoutLocationInput, RouteStopUncheckedCreateWithoutLocationInput> | RouteStopCreateWithoutLocationInput[] | RouteStopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutLocationInput | RouteStopCreateOrConnectWithoutLocationInput[]
    createMany?: RouteStopCreateManyLocationInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type TeenCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeenCreateWithoutSchoolInput, TeenUncheckedCreateWithoutSchoolInput> | TeenCreateWithoutSchoolInput[] | TeenUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeenCreateOrConnectWithoutSchoolInput | TeenCreateOrConnectWithoutSchoolInput[]
    createMany?: TeenCreateManySchoolInputEnvelope
    connect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
  }

  export type RouteStopUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<RouteStopCreateWithoutLocationInput, RouteStopUncheckedCreateWithoutLocationInput> | RouteStopCreateWithoutLocationInput[] | RouteStopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutLocationInput | RouteStopCreateOrConnectWithoutLocationInput[]
    createMany?: RouteStopCreateManyLocationInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type TeenUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<TeenCreateWithoutSchoolInput, TeenUncheckedCreateWithoutSchoolInput> | TeenCreateWithoutSchoolInput[] | TeenUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeenCreateOrConnectWithoutSchoolInput | TeenCreateOrConnectWithoutSchoolInput[]
    createMany?: TeenCreateManySchoolInputEnvelope
    connect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumLocationTypeFieldUpdateOperationsInput = {
    set?: $Enums.LocationType
  }

  export type RouteStopUpdateManyWithoutLocationNestedInput = {
    create?: XOR<RouteStopCreateWithoutLocationInput, RouteStopUncheckedCreateWithoutLocationInput> | RouteStopCreateWithoutLocationInput[] | RouteStopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutLocationInput | RouteStopCreateOrConnectWithoutLocationInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutLocationInput | RouteStopUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: RouteStopCreateManyLocationInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutLocationInput | RouteStopUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutLocationInput | RouteStopUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type TeenUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeenCreateWithoutSchoolInput, TeenUncheckedCreateWithoutSchoolInput> | TeenCreateWithoutSchoolInput[] | TeenUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeenCreateOrConnectWithoutSchoolInput | TeenCreateOrConnectWithoutSchoolInput[]
    upsert?: TeenUpsertWithWhereUniqueWithoutSchoolInput | TeenUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeenCreateManySchoolInputEnvelope
    set?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    disconnect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    delete?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    connect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    update?: TeenUpdateWithWhereUniqueWithoutSchoolInput | TeenUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeenUpdateManyWithWhereWithoutSchoolInput | TeenUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeenScalarWhereInput | TeenScalarWhereInput[]
  }

  export type RouteStopUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<RouteStopCreateWithoutLocationInput, RouteStopUncheckedCreateWithoutLocationInput> | RouteStopCreateWithoutLocationInput[] | RouteStopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutLocationInput | RouteStopCreateOrConnectWithoutLocationInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutLocationInput | RouteStopUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: RouteStopCreateManyLocationInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutLocationInput | RouteStopUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutLocationInput | RouteStopUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type TeenUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<TeenCreateWithoutSchoolInput, TeenUncheckedCreateWithoutSchoolInput> | TeenCreateWithoutSchoolInput[] | TeenUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: TeenCreateOrConnectWithoutSchoolInput | TeenCreateOrConnectWithoutSchoolInput[]
    upsert?: TeenUpsertWithWhereUniqueWithoutSchoolInput | TeenUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: TeenCreateManySchoolInputEnvelope
    set?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    disconnect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    delete?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    connect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    update?: TeenUpdateWithWhereUniqueWithoutSchoolInput | TeenUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: TeenUpdateManyWithWhereWithoutSchoolInput | TeenUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: TeenScalarWhereInput | TeenScalarWhereInput[]
  }

  export type RouteCreatedaysOfWeekInput = {
    set: number[]
  }

  export type RouteFeaturesCreateNestedOneWithoutRouteInput = {
    create?: XOR<RouteFeaturesCreateWithoutRouteInput, RouteFeaturesUncheckedCreateWithoutRouteInput>
    connectOrCreate?: RouteFeaturesCreateOrConnectWithoutRouteInput
    connect?: RouteFeaturesWhereUniqueInput
  }

  export type RideRequestCreateNestedManyWithoutRouteInput = {
    create?: XOR<RideRequestCreateWithoutRouteInput, RideRequestUncheckedCreateWithoutRouteInput> | RideRequestCreateWithoutRouteInput[] | RideRequestUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutRouteInput | RideRequestCreateOrConnectWithoutRouteInput[]
    createMany?: RideRequestCreateManyRouteInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type RouteDriverCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteDriverCreateWithoutRouteInput, RouteDriverUncheckedCreateWithoutRouteInput> | RouteDriverCreateWithoutRouteInput[] | RouteDriverUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteDriverCreateOrConnectWithoutRouteInput | RouteDriverCreateOrConnectWithoutRouteInput[]
    createMany?: RouteDriverCreateManyRouteInputEnvelope
    connect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
  }

  export type RouteStopCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput> | RouteStopCreateWithoutRouteInput[] | RouteStopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutRouteInput | RouteStopCreateOrConnectWithoutRouteInput[]
    createMany?: RouteStopCreateManyRouteInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type TripCreateNestedManyWithoutRouteInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type RouteFeaturesUncheckedCreateNestedOneWithoutRouteInput = {
    create?: XOR<RouteFeaturesCreateWithoutRouteInput, RouteFeaturesUncheckedCreateWithoutRouteInput>
    connectOrCreate?: RouteFeaturesCreateOrConnectWithoutRouteInput
    connect?: RouteFeaturesWhereUniqueInput
  }

  export type RideRequestUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<RideRequestCreateWithoutRouteInput, RideRequestUncheckedCreateWithoutRouteInput> | RideRequestCreateWithoutRouteInput[] | RideRequestUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutRouteInput | RideRequestCreateOrConnectWithoutRouteInput[]
    createMany?: RideRequestCreateManyRouteInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type RouteDriverUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteDriverCreateWithoutRouteInput, RouteDriverUncheckedCreateWithoutRouteInput> | RouteDriverCreateWithoutRouteInput[] | RouteDriverUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteDriverCreateOrConnectWithoutRouteInput | RouteDriverCreateOrConnectWithoutRouteInput[]
    createMany?: RouteDriverCreateManyRouteInputEnvelope
    connect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
  }

  export type RouteStopUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput> | RouteStopCreateWithoutRouteInput[] | RouteStopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutRouteInput | RouteStopCreateOrConnectWithoutRouteInput[]
    createMany?: RouteStopCreateManyRouteInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type EnumRouteTypeFieldUpdateOperationsInput = {
    set?: $Enums.RouteType
  }

  export type EnumRouteFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.RouteFrequency
  }

  export type RouteUpdatedaysOfWeekInput = {
    set?: number[]
    push?: number | number[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumPricingTypeFieldUpdateOperationsInput = {
    set?: $Enums.PricingType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumRouteStatusFieldUpdateOperationsInput = {
    set?: $Enums.RouteStatus
  }

  export type RouteFeaturesUpdateOneWithoutRouteNestedInput = {
    create?: XOR<RouteFeaturesCreateWithoutRouteInput, RouteFeaturesUncheckedCreateWithoutRouteInput>
    connectOrCreate?: RouteFeaturesCreateOrConnectWithoutRouteInput
    upsert?: RouteFeaturesUpsertWithoutRouteInput
    disconnect?: RouteFeaturesWhereInput | boolean
    delete?: RouteFeaturesWhereInput | boolean
    connect?: RouteFeaturesWhereUniqueInput
    update?: XOR<XOR<RouteFeaturesUpdateToOneWithWhereWithoutRouteInput, RouteFeaturesUpdateWithoutRouteInput>, RouteFeaturesUncheckedUpdateWithoutRouteInput>
  }

  export type RideRequestUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RideRequestCreateWithoutRouteInput, RideRequestUncheckedCreateWithoutRouteInput> | RideRequestCreateWithoutRouteInput[] | RideRequestUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutRouteInput | RideRequestCreateOrConnectWithoutRouteInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutRouteInput | RideRequestUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RideRequestCreateManyRouteInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutRouteInput | RideRequestUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutRouteInput | RideRequestUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type RouteDriverUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteDriverCreateWithoutRouteInput, RouteDriverUncheckedCreateWithoutRouteInput> | RouteDriverCreateWithoutRouteInput[] | RouteDriverUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteDriverCreateOrConnectWithoutRouteInput | RouteDriverCreateOrConnectWithoutRouteInput[]
    upsert?: RouteDriverUpsertWithWhereUniqueWithoutRouteInput | RouteDriverUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteDriverCreateManyRouteInputEnvelope
    set?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    disconnect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    delete?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    connect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    update?: RouteDriverUpdateWithWhereUniqueWithoutRouteInput | RouteDriverUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteDriverUpdateManyWithWhereWithoutRouteInput | RouteDriverUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteDriverScalarWhereInput | RouteDriverScalarWhereInput[]
  }

  export type RouteStopUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput> | RouteStopCreateWithoutRouteInput[] | RouteStopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutRouteInput | RouteStopCreateOrConnectWithoutRouteInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutRouteInput | RouteStopUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteStopCreateManyRouteInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutRouteInput | RouteStopUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutRouteInput | RouteStopUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type TripUpdateManyWithoutRouteNestedInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutRouteInput | TripUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutRouteInput | TripUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: TripUpdateManyWithWhereWithoutRouteInput | TripUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type RouteFeaturesUncheckedUpdateOneWithoutRouteNestedInput = {
    create?: XOR<RouteFeaturesCreateWithoutRouteInput, RouteFeaturesUncheckedCreateWithoutRouteInput>
    connectOrCreate?: RouteFeaturesCreateOrConnectWithoutRouteInput
    upsert?: RouteFeaturesUpsertWithoutRouteInput
    disconnect?: RouteFeaturesWhereInput | boolean
    delete?: RouteFeaturesWhereInput | boolean
    connect?: RouteFeaturesWhereUniqueInput
    update?: XOR<XOR<RouteFeaturesUpdateToOneWithWhereWithoutRouteInput, RouteFeaturesUpdateWithoutRouteInput>, RouteFeaturesUncheckedUpdateWithoutRouteInput>
  }

  export type RideRequestUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RideRequestCreateWithoutRouteInput, RideRequestUncheckedCreateWithoutRouteInput> | RideRequestCreateWithoutRouteInput[] | RideRequestUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutRouteInput | RideRequestCreateOrConnectWithoutRouteInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutRouteInput | RideRequestUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RideRequestCreateManyRouteInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutRouteInput | RideRequestUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutRouteInput | RideRequestUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type RouteDriverUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteDriverCreateWithoutRouteInput, RouteDriverUncheckedCreateWithoutRouteInput> | RouteDriverCreateWithoutRouteInput[] | RouteDriverUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteDriverCreateOrConnectWithoutRouteInput | RouteDriverCreateOrConnectWithoutRouteInput[]
    upsert?: RouteDriverUpsertWithWhereUniqueWithoutRouteInput | RouteDriverUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteDriverCreateManyRouteInputEnvelope
    set?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    disconnect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    delete?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    connect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    update?: RouteDriverUpdateWithWhereUniqueWithoutRouteInput | RouteDriverUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteDriverUpdateManyWithWhereWithoutRouteInput | RouteDriverUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteDriverScalarWhereInput | RouteDriverScalarWhereInput[]
  }

  export type RouteStopUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput> | RouteStopCreateWithoutRouteInput[] | RouteStopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutRouteInput | RouteStopCreateOrConnectWithoutRouteInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutRouteInput | RouteStopUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteStopCreateManyRouteInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutRouteInput | RouteStopUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutRouteInput | RouteStopUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput> | TripCreateWithoutRouteInput[] | TripUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: TripCreateOrConnectWithoutRouteInput | TripCreateOrConnectWithoutRouteInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutRouteInput | TripUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: TripCreateManyRouteInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutRouteInput | TripUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: TripUpdateManyWithWhereWithoutRouteInput | TripUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type RideCreateNestedManyWithoutDropStopInput = {
    create?: XOR<RideCreateWithoutDropStopInput, RideUncheckedCreateWithoutDropStopInput> | RideCreateWithoutDropStopInput[] | RideUncheckedCreateWithoutDropStopInput[]
    connectOrCreate?: RideCreateOrConnectWithoutDropStopInput | RideCreateOrConnectWithoutDropStopInput[]
    createMany?: RideCreateManyDropStopInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideCreateNestedManyWithoutPickupStopInput = {
    create?: XOR<RideCreateWithoutPickupStopInput, RideUncheckedCreateWithoutPickupStopInput> | RideCreateWithoutPickupStopInput[] | RideUncheckedCreateWithoutPickupStopInput[]
    connectOrCreate?: RideCreateOrConnectWithoutPickupStopInput | RideCreateOrConnectWithoutPickupStopInput[]
    createMany?: RideCreateManyPickupStopInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideRequestCreateNestedManyWithoutDropStopInput = {
    create?: XOR<RideRequestCreateWithoutDropStopInput, RideRequestUncheckedCreateWithoutDropStopInput> | RideRequestCreateWithoutDropStopInput[] | RideRequestUncheckedCreateWithoutDropStopInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutDropStopInput | RideRequestCreateOrConnectWithoutDropStopInput[]
    createMany?: RideRequestCreateManyDropStopInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type RideRequestCreateNestedManyWithoutPickupStopInput = {
    create?: XOR<RideRequestCreateWithoutPickupStopInput, RideRequestUncheckedCreateWithoutPickupStopInput> | RideRequestCreateWithoutPickupStopInput[] | RideRequestUncheckedCreateWithoutPickupStopInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutPickupStopInput | RideRequestCreateOrConnectWithoutPickupStopInput[]
    createMany?: RideRequestCreateManyPickupStopInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type LocationCreateNestedOneWithoutRouteStopsInput = {
    create?: XOR<LocationCreateWithoutRouteStopsInput, LocationUncheckedCreateWithoutRouteStopsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRouteStopsInput
    connect?: LocationWhereUniqueInput
  }

  export type RouteCreateNestedOneWithoutStopsInput = {
    create?: XOR<RouteCreateWithoutStopsInput, RouteUncheckedCreateWithoutStopsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutStopsInput
    connect?: RouteWhereUniqueInput
  }

  export type RideUncheckedCreateNestedManyWithoutDropStopInput = {
    create?: XOR<RideCreateWithoutDropStopInput, RideUncheckedCreateWithoutDropStopInput> | RideCreateWithoutDropStopInput[] | RideUncheckedCreateWithoutDropStopInput[]
    connectOrCreate?: RideCreateOrConnectWithoutDropStopInput | RideCreateOrConnectWithoutDropStopInput[]
    createMany?: RideCreateManyDropStopInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideUncheckedCreateNestedManyWithoutPickupStopInput = {
    create?: XOR<RideCreateWithoutPickupStopInput, RideUncheckedCreateWithoutPickupStopInput> | RideCreateWithoutPickupStopInput[] | RideUncheckedCreateWithoutPickupStopInput[]
    connectOrCreate?: RideCreateOrConnectWithoutPickupStopInput | RideCreateOrConnectWithoutPickupStopInput[]
    createMany?: RideCreateManyPickupStopInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideRequestUncheckedCreateNestedManyWithoutDropStopInput = {
    create?: XOR<RideRequestCreateWithoutDropStopInput, RideRequestUncheckedCreateWithoutDropStopInput> | RideRequestCreateWithoutDropStopInput[] | RideRequestUncheckedCreateWithoutDropStopInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutDropStopInput | RideRequestCreateOrConnectWithoutDropStopInput[]
    createMany?: RideRequestCreateManyDropStopInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type RideRequestUncheckedCreateNestedManyWithoutPickupStopInput = {
    create?: XOR<RideRequestCreateWithoutPickupStopInput, RideRequestUncheckedCreateWithoutPickupStopInput> | RideRequestCreateWithoutPickupStopInput[] | RideRequestUncheckedCreateWithoutPickupStopInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutPickupStopInput | RideRequestCreateOrConnectWithoutPickupStopInput[]
    createMany?: RideRequestCreateManyPickupStopInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type RideUpdateManyWithoutDropStopNestedInput = {
    create?: XOR<RideCreateWithoutDropStopInput, RideUncheckedCreateWithoutDropStopInput> | RideCreateWithoutDropStopInput[] | RideUncheckedCreateWithoutDropStopInput[]
    connectOrCreate?: RideCreateOrConnectWithoutDropStopInput | RideCreateOrConnectWithoutDropStopInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutDropStopInput | RideUpsertWithWhereUniqueWithoutDropStopInput[]
    createMany?: RideCreateManyDropStopInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutDropStopInput | RideUpdateWithWhereUniqueWithoutDropStopInput[]
    updateMany?: RideUpdateManyWithWhereWithoutDropStopInput | RideUpdateManyWithWhereWithoutDropStopInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideUpdateManyWithoutPickupStopNestedInput = {
    create?: XOR<RideCreateWithoutPickupStopInput, RideUncheckedCreateWithoutPickupStopInput> | RideCreateWithoutPickupStopInput[] | RideUncheckedCreateWithoutPickupStopInput[]
    connectOrCreate?: RideCreateOrConnectWithoutPickupStopInput | RideCreateOrConnectWithoutPickupStopInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutPickupStopInput | RideUpsertWithWhereUniqueWithoutPickupStopInput[]
    createMany?: RideCreateManyPickupStopInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutPickupStopInput | RideUpdateWithWhereUniqueWithoutPickupStopInput[]
    updateMany?: RideUpdateManyWithWhereWithoutPickupStopInput | RideUpdateManyWithWhereWithoutPickupStopInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideRequestUpdateManyWithoutDropStopNestedInput = {
    create?: XOR<RideRequestCreateWithoutDropStopInput, RideRequestUncheckedCreateWithoutDropStopInput> | RideRequestCreateWithoutDropStopInput[] | RideRequestUncheckedCreateWithoutDropStopInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutDropStopInput | RideRequestCreateOrConnectWithoutDropStopInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutDropStopInput | RideRequestUpsertWithWhereUniqueWithoutDropStopInput[]
    createMany?: RideRequestCreateManyDropStopInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutDropStopInput | RideRequestUpdateWithWhereUniqueWithoutDropStopInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutDropStopInput | RideRequestUpdateManyWithWhereWithoutDropStopInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type RideRequestUpdateManyWithoutPickupStopNestedInput = {
    create?: XOR<RideRequestCreateWithoutPickupStopInput, RideRequestUncheckedCreateWithoutPickupStopInput> | RideRequestCreateWithoutPickupStopInput[] | RideRequestUncheckedCreateWithoutPickupStopInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutPickupStopInput | RideRequestCreateOrConnectWithoutPickupStopInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutPickupStopInput | RideRequestUpsertWithWhereUniqueWithoutPickupStopInput[]
    createMany?: RideRequestCreateManyPickupStopInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutPickupStopInput | RideRequestUpdateWithWhereUniqueWithoutPickupStopInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutPickupStopInput | RideRequestUpdateManyWithWhereWithoutPickupStopInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type LocationUpdateOneRequiredWithoutRouteStopsNestedInput = {
    create?: XOR<LocationCreateWithoutRouteStopsInput, LocationUncheckedCreateWithoutRouteStopsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRouteStopsInput
    upsert?: LocationUpsertWithoutRouteStopsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutRouteStopsInput, LocationUpdateWithoutRouteStopsInput>, LocationUncheckedUpdateWithoutRouteStopsInput>
  }

  export type RouteUpdateOneRequiredWithoutStopsNestedInput = {
    create?: XOR<RouteCreateWithoutStopsInput, RouteUncheckedCreateWithoutStopsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutStopsInput
    upsert?: RouteUpsertWithoutStopsInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutStopsInput, RouteUpdateWithoutStopsInput>, RouteUncheckedUpdateWithoutStopsInput>
  }

  export type RideUncheckedUpdateManyWithoutDropStopNestedInput = {
    create?: XOR<RideCreateWithoutDropStopInput, RideUncheckedCreateWithoutDropStopInput> | RideCreateWithoutDropStopInput[] | RideUncheckedCreateWithoutDropStopInput[]
    connectOrCreate?: RideCreateOrConnectWithoutDropStopInput | RideCreateOrConnectWithoutDropStopInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutDropStopInput | RideUpsertWithWhereUniqueWithoutDropStopInput[]
    createMany?: RideCreateManyDropStopInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutDropStopInput | RideUpdateWithWhereUniqueWithoutDropStopInput[]
    updateMany?: RideUpdateManyWithWhereWithoutDropStopInput | RideUpdateManyWithWhereWithoutDropStopInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideUncheckedUpdateManyWithoutPickupStopNestedInput = {
    create?: XOR<RideCreateWithoutPickupStopInput, RideUncheckedCreateWithoutPickupStopInput> | RideCreateWithoutPickupStopInput[] | RideUncheckedCreateWithoutPickupStopInput[]
    connectOrCreate?: RideCreateOrConnectWithoutPickupStopInput | RideCreateOrConnectWithoutPickupStopInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutPickupStopInput | RideUpsertWithWhereUniqueWithoutPickupStopInput[]
    createMany?: RideCreateManyPickupStopInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutPickupStopInput | RideUpdateWithWhereUniqueWithoutPickupStopInput[]
    updateMany?: RideUpdateManyWithWhereWithoutPickupStopInput | RideUpdateManyWithWhereWithoutPickupStopInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideRequestUncheckedUpdateManyWithoutDropStopNestedInput = {
    create?: XOR<RideRequestCreateWithoutDropStopInput, RideRequestUncheckedCreateWithoutDropStopInput> | RideRequestCreateWithoutDropStopInput[] | RideRequestUncheckedCreateWithoutDropStopInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutDropStopInput | RideRequestCreateOrConnectWithoutDropStopInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutDropStopInput | RideRequestUpsertWithWhereUniqueWithoutDropStopInput[]
    createMany?: RideRequestCreateManyDropStopInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutDropStopInput | RideRequestUpdateWithWhereUniqueWithoutDropStopInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutDropStopInput | RideRequestUpdateManyWithWhereWithoutDropStopInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type RideRequestUncheckedUpdateManyWithoutPickupStopNestedInput = {
    create?: XOR<RideRequestCreateWithoutPickupStopInput, RideRequestUncheckedCreateWithoutPickupStopInput> | RideRequestCreateWithoutPickupStopInput[] | RideRequestUncheckedCreateWithoutPickupStopInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutPickupStopInput | RideRequestCreateOrConnectWithoutPickupStopInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutPickupStopInput | RideRequestUpsertWithWhereUniqueWithoutPickupStopInput[]
    createMany?: RideRequestCreateManyPickupStopInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutPickupStopInput | RideRequestUpdateWithWhereUniqueWithoutPickupStopInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutPickupStopInput | RideRequestUpdateManyWithWhereWithoutPickupStopInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type DriverCreateNestedOneWithoutRouteAssignmentsInput = {
    create?: XOR<DriverCreateWithoutRouteAssignmentsInput, DriverUncheckedCreateWithoutRouteAssignmentsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutRouteAssignmentsInput
    connect?: DriverWhereUniqueInput
  }

  export type RouteCreateNestedOneWithoutDriversInput = {
    create?: XOR<RouteCreateWithoutDriversInput, RouteUncheckedCreateWithoutDriversInput>
    connectOrCreate?: RouteCreateOrConnectWithoutDriversInput
    connect?: RouteWhereUniqueInput
  }

  export type DriverUpdateOneRequiredWithoutRouteAssignmentsNestedInput = {
    create?: XOR<DriverCreateWithoutRouteAssignmentsInput, DriverUncheckedCreateWithoutRouteAssignmentsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutRouteAssignmentsInput
    upsert?: DriverUpsertWithoutRouteAssignmentsInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutRouteAssignmentsInput, DriverUpdateWithoutRouteAssignmentsInput>, DriverUncheckedUpdateWithoutRouteAssignmentsInput>
  }

  export type RouteUpdateOneRequiredWithoutDriversNestedInput = {
    create?: XOR<RouteCreateWithoutDriversInput, RouteUncheckedCreateWithoutDriversInput>
    connectOrCreate?: RouteCreateOrConnectWithoutDriversInput
    upsert?: RouteUpsertWithoutDriversInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutDriversInput, RouteUpdateWithoutDriversInput>, RouteUncheckedUpdateWithoutDriversInput>
  }

  export type RideCreateNestedManyWithoutTripInput = {
    create?: XOR<RideCreateWithoutTripInput, RideUncheckedCreateWithoutTripInput> | RideCreateWithoutTripInput[] | RideUncheckedCreateWithoutTripInput[]
    connectOrCreate?: RideCreateOrConnectWithoutTripInput | RideCreateOrConnectWithoutTripInput[]
    createMany?: RideCreateManyTripInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type DriverCreateNestedOneWithoutTripsInput = {
    create?: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTripsInput
    connect?: DriverWhereUniqueInput
  }

  export type RouteCreateNestedOneWithoutTripsInput = {
    create?: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutTripsInput
    connect?: RouteWhereUniqueInput
  }

  export type RideUncheckedCreateNestedManyWithoutTripInput = {
    create?: XOR<RideCreateWithoutTripInput, RideUncheckedCreateWithoutTripInput> | RideCreateWithoutTripInput[] | RideUncheckedCreateWithoutTripInput[]
    connectOrCreate?: RideCreateOrConnectWithoutTripInput | RideCreateOrConnectWithoutTripInput[]
    createMany?: RideCreateManyTripInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type EnumTripStatusFieldUpdateOperationsInput = {
    set?: $Enums.TripStatus
  }

  export type RideUpdateManyWithoutTripNestedInput = {
    create?: XOR<RideCreateWithoutTripInput, RideUncheckedCreateWithoutTripInput> | RideCreateWithoutTripInput[] | RideUncheckedCreateWithoutTripInput[]
    connectOrCreate?: RideCreateOrConnectWithoutTripInput | RideCreateOrConnectWithoutTripInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutTripInput | RideUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: RideCreateManyTripInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutTripInput | RideUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: RideUpdateManyWithWhereWithoutTripInput | RideUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type DriverUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTripsInput
    upsert?: DriverUpsertWithoutTripsInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutTripsInput, DriverUpdateWithoutTripsInput>, DriverUncheckedUpdateWithoutTripsInput>
  }

  export type RouteUpdateOneRequiredWithoutTripsNestedInput = {
    create?: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutTripsInput
    upsert?: RouteUpsertWithoutTripsInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutTripsInput, RouteUpdateWithoutTripsInput>, RouteUncheckedUpdateWithoutTripsInput>
  }

  export type RideUncheckedUpdateManyWithoutTripNestedInput = {
    create?: XOR<RideCreateWithoutTripInput, RideUncheckedCreateWithoutTripInput> | RideCreateWithoutTripInput[] | RideUncheckedCreateWithoutTripInput[]
    connectOrCreate?: RideCreateOrConnectWithoutTripInput | RideCreateOrConnectWithoutTripInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutTripInput | RideUpsertWithWhereUniqueWithoutTripInput[]
    createMany?: RideCreateManyTripInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutTripInput | RideUpdateWithWhereUniqueWithoutTripInput[]
    updateMany?: RideUpdateManyWithWhereWithoutTripInput | RideUpdateManyWithWhereWithoutTripInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RouteStopCreateNestedOneWithoutDropRidesInput = {
    create?: XOR<RouteStopCreateWithoutDropRidesInput, RouteStopUncheckedCreateWithoutDropRidesInput>
    connectOrCreate?: RouteStopCreateOrConnectWithoutDropRidesInput
    connect?: RouteStopWhereUniqueInput
  }

  export type RouteStopCreateNestedOneWithoutPickupRidesInput = {
    create?: XOR<RouteStopCreateWithoutPickupRidesInput, RouteStopUncheckedCreateWithoutPickupRidesInput>
    connectOrCreate?: RouteStopCreateOrConnectWithoutPickupRidesInput
    connect?: RouteStopWhereUniqueInput
  }

  export type TeenCreateNestedOneWithoutRidesInput = {
    create?: XOR<TeenCreateWithoutRidesInput, TeenUncheckedCreateWithoutRidesInput>
    connectOrCreate?: TeenCreateOrConnectWithoutRidesInput
    connect?: TeenWhereUniqueInput
  }

  export type TripCreateNestedOneWithoutRidesInput = {
    create?: XOR<TripCreateWithoutRidesInput, TripUncheckedCreateWithoutRidesInput>
    connectOrCreate?: TripCreateOrConnectWithoutRidesInput
    connect?: TripWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutRideInput = {
    create?: XOR<TransactionCreateWithoutRideInput, TransactionUncheckedCreateWithoutRideInput> | TransactionCreateWithoutRideInput[] | TransactionUncheckedCreateWithoutRideInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRideInput | TransactionCreateOrConnectWithoutRideInput[]
    createMany?: TransactionCreateManyRideInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutRideInput = {
    create?: XOR<TransactionCreateWithoutRideInput, TransactionUncheckedCreateWithoutRideInput> | TransactionCreateWithoutRideInput[] | TransactionUncheckedCreateWithoutRideInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRideInput | TransactionCreateOrConnectWithoutRideInput[]
    createMany?: TransactionCreateManyRideInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumRideStatusFieldUpdateOperationsInput = {
    set?: $Enums.RideStatus
  }

  export type RouteStopUpdateOneRequiredWithoutDropRidesNestedInput = {
    create?: XOR<RouteStopCreateWithoutDropRidesInput, RouteStopUncheckedCreateWithoutDropRidesInput>
    connectOrCreate?: RouteStopCreateOrConnectWithoutDropRidesInput
    upsert?: RouteStopUpsertWithoutDropRidesInput
    connect?: RouteStopWhereUniqueInput
    update?: XOR<XOR<RouteStopUpdateToOneWithWhereWithoutDropRidesInput, RouteStopUpdateWithoutDropRidesInput>, RouteStopUncheckedUpdateWithoutDropRidesInput>
  }

  export type RouteStopUpdateOneRequiredWithoutPickupRidesNestedInput = {
    create?: XOR<RouteStopCreateWithoutPickupRidesInput, RouteStopUncheckedCreateWithoutPickupRidesInput>
    connectOrCreate?: RouteStopCreateOrConnectWithoutPickupRidesInput
    upsert?: RouteStopUpsertWithoutPickupRidesInput
    connect?: RouteStopWhereUniqueInput
    update?: XOR<XOR<RouteStopUpdateToOneWithWhereWithoutPickupRidesInput, RouteStopUpdateWithoutPickupRidesInput>, RouteStopUncheckedUpdateWithoutPickupRidesInput>
  }

  export type TeenUpdateOneRequiredWithoutRidesNestedInput = {
    create?: XOR<TeenCreateWithoutRidesInput, TeenUncheckedCreateWithoutRidesInput>
    connectOrCreate?: TeenCreateOrConnectWithoutRidesInput
    upsert?: TeenUpsertWithoutRidesInput
    connect?: TeenWhereUniqueInput
    update?: XOR<XOR<TeenUpdateToOneWithWhereWithoutRidesInput, TeenUpdateWithoutRidesInput>, TeenUncheckedUpdateWithoutRidesInput>
  }

  export type TripUpdateOneRequiredWithoutRidesNestedInput = {
    create?: XOR<TripCreateWithoutRidesInput, TripUncheckedCreateWithoutRidesInput>
    connectOrCreate?: TripCreateOrConnectWithoutRidesInput
    upsert?: TripUpsertWithoutRidesInput
    connect?: TripWhereUniqueInput
    update?: XOR<XOR<TripUpdateToOneWithWhereWithoutRidesInput, TripUpdateWithoutRidesInput>, TripUncheckedUpdateWithoutRidesInput>
  }

  export type TransactionUpdateManyWithoutRideNestedInput = {
    create?: XOR<TransactionCreateWithoutRideInput, TransactionUncheckedCreateWithoutRideInput> | TransactionCreateWithoutRideInput[] | TransactionUncheckedCreateWithoutRideInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRideInput | TransactionCreateOrConnectWithoutRideInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutRideInput | TransactionUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: TransactionCreateManyRideInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutRideInput | TransactionUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutRideInput | TransactionUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutRideNestedInput = {
    create?: XOR<TransactionCreateWithoutRideInput, TransactionUncheckedCreateWithoutRideInput> | TransactionCreateWithoutRideInput[] | TransactionUncheckedCreateWithoutRideInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutRideInput | TransactionCreateOrConnectWithoutRideInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutRideInput | TransactionUpsertWithWhereUniqueWithoutRideInput[]
    createMany?: TransactionCreateManyRideInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutRideInput | TransactionUpdateWithWhereUniqueWithoutRideInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutRideInput | TransactionUpdateManyWithWhereWithoutRideInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParentInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    connect?: UserWhereUniqueInput
  }

  export type RideRequestCreateNestedManyWithoutParentInput = {
    create?: XOR<RideRequestCreateWithoutParentInput, RideRequestUncheckedCreateWithoutParentInput> | RideRequestCreateWithoutParentInput[] | RideRequestUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutParentInput | RideRequestCreateOrConnectWithoutParentInput[]
    createMany?: RideRequestCreateManyParentInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type TeenCreateNestedManyWithoutParentInput = {
    create?: XOR<TeenCreateWithoutParentInput, TeenUncheckedCreateWithoutParentInput> | TeenCreateWithoutParentInput[] | TeenUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TeenCreateOrConnectWithoutParentInput | TeenCreateOrConnectWithoutParentInput[]
    createMany?: TeenCreateManyParentInputEnvelope
    connect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
  }

  export type WalletCreateNestedOneWithoutParentInput = {
    create?: XOR<WalletCreateWithoutParentInput, WalletUncheckedCreateWithoutParentInput>
    connectOrCreate?: WalletCreateOrConnectWithoutParentInput
    connect?: WalletWhereUniqueInput
  }

  export type RideRequestUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<RideRequestCreateWithoutParentInput, RideRequestUncheckedCreateWithoutParentInput> | RideRequestCreateWithoutParentInput[] | RideRequestUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutParentInput | RideRequestCreateOrConnectWithoutParentInput[]
    createMany?: RideRequestCreateManyParentInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type TeenUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<TeenCreateWithoutParentInput, TeenUncheckedCreateWithoutParentInput> | TeenCreateWithoutParentInput[] | TeenUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TeenCreateOrConnectWithoutParentInput | TeenCreateOrConnectWithoutParentInput[]
    createMany?: TeenCreateManyParentInputEnvelope
    connect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedOneWithoutParentInput = {
    create?: XOR<WalletCreateWithoutParentInput, WalletUncheckedCreateWithoutParentInput>
    connectOrCreate?: WalletCreateOrConnectWithoutParentInput
    connect?: WalletWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutParentNestedInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    upsert?: UserUpsertWithoutParentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentInput, UserUpdateWithoutParentInput>, UserUncheckedUpdateWithoutParentInput>
  }

  export type RideRequestUpdateManyWithoutParentNestedInput = {
    create?: XOR<RideRequestCreateWithoutParentInput, RideRequestUncheckedCreateWithoutParentInput> | RideRequestCreateWithoutParentInput[] | RideRequestUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutParentInput | RideRequestCreateOrConnectWithoutParentInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutParentInput | RideRequestUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RideRequestCreateManyParentInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutParentInput | RideRequestUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutParentInput | RideRequestUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type TeenUpdateManyWithoutParentNestedInput = {
    create?: XOR<TeenCreateWithoutParentInput, TeenUncheckedCreateWithoutParentInput> | TeenCreateWithoutParentInput[] | TeenUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TeenCreateOrConnectWithoutParentInput | TeenCreateOrConnectWithoutParentInput[]
    upsert?: TeenUpsertWithWhereUniqueWithoutParentInput | TeenUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TeenCreateManyParentInputEnvelope
    set?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    disconnect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    delete?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    connect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    update?: TeenUpdateWithWhereUniqueWithoutParentInput | TeenUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TeenUpdateManyWithWhereWithoutParentInput | TeenUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TeenScalarWhereInput | TeenScalarWhereInput[]
  }

  export type WalletUpdateOneWithoutParentNestedInput = {
    create?: XOR<WalletCreateWithoutParentInput, WalletUncheckedCreateWithoutParentInput>
    connectOrCreate?: WalletCreateOrConnectWithoutParentInput
    upsert?: WalletUpsertWithoutParentInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutParentInput, WalletUpdateWithoutParentInput>, WalletUncheckedUpdateWithoutParentInput>
  }

  export type RideRequestUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<RideRequestCreateWithoutParentInput, RideRequestUncheckedCreateWithoutParentInput> | RideRequestCreateWithoutParentInput[] | RideRequestUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutParentInput | RideRequestCreateOrConnectWithoutParentInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutParentInput | RideRequestUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RideRequestCreateManyParentInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutParentInput | RideRequestUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutParentInput | RideRequestUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type TeenUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<TeenCreateWithoutParentInput, TeenUncheckedCreateWithoutParentInput> | TeenCreateWithoutParentInput[] | TeenUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TeenCreateOrConnectWithoutParentInput | TeenCreateOrConnectWithoutParentInput[]
    upsert?: TeenUpsertWithWhereUniqueWithoutParentInput | TeenUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TeenCreateManyParentInputEnvelope
    set?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    disconnect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    delete?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    connect?: TeenWhereUniqueInput | TeenWhereUniqueInput[]
    update?: TeenUpdateWithWhereUniqueWithoutParentInput | TeenUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TeenUpdateManyWithWhereWithoutParentInput | TeenUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TeenScalarWhereInput | TeenScalarWhereInput[]
  }

  export type WalletUncheckedUpdateOneWithoutParentNestedInput = {
    create?: XOR<WalletCreateWithoutParentInput, WalletUncheckedCreateWithoutParentInput>
    connectOrCreate?: WalletCreateOrConnectWithoutParentInput
    upsert?: WalletUpsertWithoutParentInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutParentInput, WalletUpdateWithoutParentInput>, WalletUncheckedUpdateWithoutParentInput>
  }

  export type UserCreateNestedOneWithoutDriverInput = {
    create?: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverInput
    connect?: UserWhereUniqueInput
  }

  export type DriverVerificationCreateNestedOneWithoutDriverInput = {
    create?: XOR<DriverVerificationCreateWithoutDriverInput, DriverVerificationUncheckedCreateWithoutDriverInput>
    connectOrCreate?: DriverVerificationCreateOrConnectWithoutDriverInput
    connect?: DriverVerificationWhereUniqueInput
  }

  export type RouteDriverCreateNestedManyWithoutDriverInput = {
    create?: XOR<RouteDriverCreateWithoutDriverInput, RouteDriverUncheckedCreateWithoutDriverInput> | RouteDriverCreateWithoutDriverInput[] | RouteDriverUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: RouteDriverCreateOrConnectWithoutDriverInput | RouteDriverCreateOrConnectWithoutDriverInput[]
    createMany?: RouteDriverCreateManyDriverInputEnvelope
    connect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
  }

  export type TripCreateNestedManyWithoutDriverInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type VehicleCreateNestedOneWithoutDriverInput = {
    create?: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverInput
    connect?: VehicleWhereUniqueInput
  }

  export type DriverVerificationUncheckedCreateNestedOneWithoutDriverInput = {
    create?: XOR<DriverVerificationCreateWithoutDriverInput, DriverVerificationUncheckedCreateWithoutDriverInput>
    connectOrCreate?: DriverVerificationCreateOrConnectWithoutDriverInput
    connect?: DriverVerificationWhereUniqueInput
  }

  export type RouteDriverUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<RouteDriverCreateWithoutDriverInput, RouteDriverUncheckedCreateWithoutDriverInput> | RouteDriverCreateWithoutDriverInput[] | RouteDriverUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: RouteDriverCreateOrConnectWithoutDriverInput | RouteDriverCreateOrConnectWithoutDriverInput[]
    createMany?: RouteDriverCreateManyDriverInputEnvelope
    connect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
  }

  export type TripUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedOneWithoutDriverInput = {
    create?: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverInput
    connect?: VehicleWhereUniqueInput
  }

  export type NullableEnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus | null
  }

  export type UserUpdateOneRequiredWithoutDriverNestedInput = {
    create?: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverInput
    upsert?: UserUpsertWithoutDriverInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDriverInput, UserUpdateWithoutDriverInput>, UserUncheckedUpdateWithoutDriverInput>
  }

  export type DriverVerificationUpdateOneWithoutDriverNestedInput = {
    create?: XOR<DriverVerificationCreateWithoutDriverInput, DriverVerificationUncheckedCreateWithoutDriverInput>
    connectOrCreate?: DriverVerificationCreateOrConnectWithoutDriverInput
    upsert?: DriverVerificationUpsertWithoutDriverInput
    disconnect?: DriverVerificationWhereInput | boolean
    delete?: DriverVerificationWhereInput | boolean
    connect?: DriverVerificationWhereUniqueInput
    update?: XOR<XOR<DriverVerificationUpdateToOneWithWhereWithoutDriverInput, DriverVerificationUpdateWithoutDriverInput>, DriverVerificationUncheckedUpdateWithoutDriverInput>
  }

  export type RouteDriverUpdateManyWithoutDriverNestedInput = {
    create?: XOR<RouteDriverCreateWithoutDriverInput, RouteDriverUncheckedCreateWithoutDriverInput> | RouteDriverCreateWithoutDriverInput[] | RouteDriverUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: RouteDriverCreateOrConnectWithoutDriverInput | RouteDriverCreateOrConnectWithoutDriverInput[]
    upsert?: RouteDriverUpsertWithWhereUniqueWithoutDriverInput | RouteDriverUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: RouteDriverCreateManyDriverInputEnvelope
    set?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    disconnect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    delete?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    connect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    update?: RouteDriverUpdateWithWhereUniqueWithoutDriverInput | RouteDriverUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: RouteDriverUpdateManyWithWhereWithoutDriverInput | RouteDriverUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: RouteDriverScalarWhereInput | RouteDriverScalarWhereInput[]
  }

  export type TripUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutDriverInput | TripUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutDriverInput | TripUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TripUpdateManyWithWhereWithoutDriverInput | TripUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type VehicleUpdateOneWithoutDriverNestedInput = {
    create?: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverInput
    upsert?: VehicleUpsertWithoutDriverInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutDriverInput, VehicleUpdateWithoutDriverInput>, VehicleUncheckedUpdateWithoutDriverInput>
  }

  export type DriverVerificationUncheckedUpdateOneWithoutDriverNestedInput = {
    create?: XOR<DriverVerificationCreateWithoutDriverInput, DriverVerificationUncheckedCreateWithoutDriverInput>
    connectOrCreate?: DriverVerificationCreateOrConnectWithoutDriverInput
    upsert?: DriverVerificationUpsertWithoutDriverInput
    disconnect?: DriverVerificationWhereInput | boolean
    delete?: DriverVerificationWhereInput | boolean
    connect?: DriverVerificationWhereUniqueInput
    update?: XOR<XOR<DriverVerificationUpdateToOneWithWhereWithoutDriverInput, DriverVerificationUpdateWithoutDriverInput>, DriverVerificationUncheckedUpdateWithoutDriverInput>
  }

  export type RouteDriverUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<RouteDriverCreateWithoutDriverInput, RouteDriverUncheckedCreateWithoutDriverInput> | RouteDriverCreateWithoutDriverInput[] | RouteDriverUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: RouteDriverCreateOrConnectWithoutDriverInput | RouteDriverCreateOrConnectWithoutDriverInput[]
    upsert?: RouteDriverUpsertWithWhereUniqueWithoutDriverInput | RouteDriverUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: RouteDriverCreateManyDriverInputEnvelope
    set?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    disconnect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    delete?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    connect?: RouteDriverWhereUniqueInput | RouteDriverWhereUniqueInput[]
    update?: RouteDriverUpdateWithWhereUniqueWithoutDriverInput | RouteDriverUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: RouteDriverUpdateManyWithWhereWithoutDriverInput | RouteDriverUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: RouteDriverScalarWhereInput | RouteDriverScalarWhereInput[]
  }

  export type TripUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput> | TripCreateWithoutDriverInput[] | TripUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripCreateOrConnectWithoutDriverInput | TripCreateOrConnectWithoutDriverInput[]
    upsert?: TripUpsertWithWhereUniqueWithoutDriverInput | TripUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TripCreateManyDriverInputEnvelope
    set?: TripWhereUniqueInput | TripWhereUniqueInput[]
    disconnect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    delete?: TripWhereUniqueInput | TripWhereUniqueInput[]
    connect?: TripWhereUniqueInput | TripWhereUniqueInput[]
    update?: TripUpdateWithWhereUniqueWithoutDriverInput | TripUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TripUpdateManyWithWhereWithoutDriverInput | TripUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TripScalarWhereInput | TripScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateOneWithoutDriverNestedInput = {
    create?: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDriverInput
    upsert?: VehicleUpsertWithoutDriverInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutDriverInput, VehicleUpdateWithoutDriverInput>, VehicleUncheckedUpdateWithoutDriverInput>
  }

  export type RideCreateNestedManyWithoutTeenInput = {
    create?: XOR<RideCreateWithoutTeenInput, RideUncheckedCreateWithoutTeenInput> | RideCreateWithoutTeenInput[] | RideUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: RideCreateOrConnectWithoutTeenInput | RideCreateOrConnectWithoutTeenInput[]
    createMany?: RideCreateManyTeenInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideRequestCreateNestedManyWithoutTeenInput = {
    create?: XOR<RideRequestCreateWithoutTeenInput, RideRequestUncheckedCreateWithoutTeenInput> | RideRequestCreateWithoutTeenInput[] | RideRequestUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutTeenInput | RideRequestCreateOrConnectWithoutTeenInput[]
    createMany?: RideRequestCreateManyTeenInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type ParentCreateNestedOneWithoutTeensInput = {
    create?: XOR<ParentCreateWithoutTeensInput, ParentUncheckedCreateWithoutTeensInput>
    connectOrCreate?: ParentCreateOrConnectWithoutTeensInput
    connect?: ParentWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutTeensInput = {
    create?: XOR<LocationCreateWithoutTeensInput, LocationUncheckedCreateWithoutTeensInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTeensInput
    connect?: LocationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeenInput = {
    create?: XOR<UserCreateWithoutTeenInput, UserUncheckedCreateWithoutTeenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeenInput
    connect?: UserWhereUniqueInput
  }

  export type TeenBuddyCreateNestedManyWithoutBuddyInput = {
    create?: XOR<TeenBuddyCreateWithoutBuddyInput, TeenBuddyUncheckedCreateWithoutBuddyInput> | TeenBuddyCreateWithoutBuddyInput[] | TeenBuddyUncheckedCreateWithoutBuddyInput[]
    connectOrCreate?: TeenBuddyCreateOrConnectWithoutBuddyInput | TeenBuddyCreateOrConnectWithoutBuddyInput[]
    createMany?: TeenBuddyCreateManyBuddyInputEnvelope
    connect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
  }

  export type TeenBuddyCreateNestedManyWithoutTeenInput = {
    create?: XOR<TeenBuddyCreateWithoutTeenInput, TeenBuddyUncheckedCreateWithoutTeenInput> | TeenBuddyCreateWithoutTeenInput[] | TeenBuddyUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: TeenBuddyCreateOrConnectWithoutTeenInput | TeenBuddyCreateOrConnectWithoutTeenInput[]
    createMany?: TeenBuddyCreateManyTeenInputEnvelope
    connect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
  }

  export type TeenRewardsCreateNestedOneWithoutTeenInput = {
    create?: XOR<TeenRewardsCreateWithoutTeenInput, TeenRewardsUncheckedCreateWithoutTeenInput>
    connectOrCreate?: TeenRewardsCreateOrConnectWithoutTeenInput
    connect?: TeenRewardsWhereUniqueInput
  }

  export type RideUncheckedCreateNestedManyWithoutTeenInput = {
    create?: XOR<RideCreateWithoutTeenInput, RideUncheckedCreateWithoutTeenInput> | RideCreateWithoutTeenInput[] | RideUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: RideCreateOrConnectWithoutTeenInput | RideCreateOrConnectWithoutTeenInput[]
    createMany?: RideCreateManyTeenInputEnvelope
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
  }

  export type RideRequestUncheckedCreateNestedManyWithoutTeenInput = {
    create?: XOR<RideRequestCreateWithoutTeenInput, RideRequestUncheckedCreateWithoutTeenInput> | RideRequestCreateWithoutTeenInput[] | RideRequestUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutTeenInput | RideRequestCreateOrConnectWithoutTeenInput[]
    createMany?: RideRequestCreateManyTeenInputEnvelope
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
  }

  export type TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput = {
    create?: XOR<TeenBuddyCreateWithoutBuddyInput, TeenBuddyUncheckedCreateWithoutBuddyInput> | TeenBuddyCreateWithoutBuddyInput[] | TeenBuddyUncheckedCreateWithoutBuddyInput[]
    connectOrCreate?: TeenBuddyCreateOrConnectWithoutBuddyInput | TeenBuddyCreateOrConnectWithoutBuddyInput[]
    createMany?: TeenBuddyCreateManyBuddyInputEnvelope
    connect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
  }

  export type TeenBuddyUncheckedCreateNestedManyWithoutTeenInput = {
    create?: XOR<TeenBuddyCreateWithoutTeenInput, TeenBuddyUncheckedCreateWithoutTeenInput> | TeenBuddyCreateWithoutTeenInput[] | TeenBuddyUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: TeenBuddyCreateOrConnectWithoutTeenInput | TeenBuddyCreateOrConnectWithoutTeenInput[]
    createMany?: TeenBuddyCreateManyTeenInputEnvelope
    connect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
  }

  export type TeenRewardsUncheckedCreateNestedOneWithoutTeenInput = {
    create?: XOR<TeenRewardsCreateWithoutTeenInput, TeenRewardsUncheckedCreateWithoutTeenInput>
    connectOrCreate?: TeenRewardsCreateOrConnectWithoutTeenInput
    connect?: TeenRewardsWhereUniqueInput
  }

  export type EnumInviteStatusFieldUpdateOperationsInput = {
    set?: $Enums.InviteStatus
  }

  export type NullableEnumInviteTypeFieldUpdateOperationsInput = {
    set?: $Enums.InviteType | null
  }

  export type RideUpdateManyWithoutTeenNestedInput = {
    create?: XOR<RideCreateWithoutTeenInput, RideUncheckedCreateWithoutTeenInput> | RideCreateWithoutTeenInput[] | RideUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: RideCreateOrConnectWithoutTeenInput | RideCreateOrConnectWithoutTeenInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutTeenInput | RideUpsertWithWhereUniqueWithoutTeenInput[]
    createMany?: RideCreateManyTeenInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutTeenInput | RideUpdateWithWhereUniqueWithoutTeenInput[]
    updateMany?: RideUpdateManyWithWhereWithoutTeenInput | RideUpdateManyWithWhereWithoutTeenInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideRequestUpdateManyWithoutTeenNestedInput = {
    create?: XOR<RideRequestCreateWithoutTeenInput, RideRequestUncheckedCreateWithoutTeenInput> | RideRequestCreateWithoutTeenInput[] | RideRequestUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutTeenInput | RideRequestCreateOrConnectWithoutTeenInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutTeenInput | RideRequestUpsertWithWhereUniqueWithoutTeenInput[]
    createMany?: RideRequestCreateManyTeenInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutTeenInput | RideRequestUpdateWithWhereUniqueWithoutTeenInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutTeenInput | RideRequestUpdateManyWithWhereWithoutTeenInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type ParentUpdateOneRequiredWithoutTeensNestedInput = {
    create?: XOR<ParentCreateWithoutTeensInput, ParentUncheckedCreateWithoutTeensInput>
    connectOrCreate?: ParentCreateOrConnectWithoutTeensInput
    upsert?: ParentUpsertWithoutTeensInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutTeensInput, ParentUpdateWithoutTeensInput>, ParentUncheckedUpdateWithoutTeensInput>
  }

  export type LocationUpdateOneWithoutTeensNestedInput = {
    create?: XOR<LocationCreateWithoutTeensInput, LocationUncheckedCreateWithoutTeensInput>
    connectOrCreate?: LocationCreateOrConnectWithoutTeensInput
    upsert?: LocationUpsertWithoutTeensInput
    disconnect?: LocationWhereInput | boolean
    delete?: LocationWhereInput | boolean
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutTeensInput, LocationUpdateWithoutTeensInput>, LocationUncheckedUpdateWithoutTeensInput>
  }

  export type UserUpdateOneRequiredWithoutTeenNestedInput = {
    create?: XOR<UserCreateWithoutTeenInput, UserUncheckedCreateWithoutTeenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeenInput
    upsert?: UserUpsertWithoutTeenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeenInput, UserUpdateWithoutTeenInput>, UserUncheckedUpdateWithoutTeenInput>
  }

  export type TeenBuddyUpdateManyWithoutBuddyNestedInput = {
    create?: XOR<TeenBuddyCreateWithoutBuddyInput, TeenBuddyUncheckedCreateWithoutBuddyInput> | TeenBuddyCreateWithoutBuddyInput[] | TeenBuddyUncheckedCreateWithoutBuddyInput[]
    connectOrCreate?: TeenBuddyCreateOrConnectWithoutBuddyInput | TeenBuddyCreateOrConnectWithoutBuddyInput[]
    upsert?: TeenBuddyUpsertWithWhereUniqueWithoutBuddyInput | TeenBuddyUpsertWithWhereUniqueWithoutBuddyInput[]
    createMany?: TeenBuddyCreateManyBuddyInputEnvelope
    set?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    disconnect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    delete?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    connect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    update?: TeenBuddyUpdateWithWhereUniqueWithoutBuddyInput | TeenBuddyUpdateWithWhereUniqueWithoutBuddyInput[]
    updateMany?: TeenBuddyUpdateManyWithWhereWithoutBuddyInput | TeenBuddyUpdateManyWithWhereWithoutBuddyInput[]
    deleteMany?: TeenBuddyScalarWhereInput | TeenBuddyScalarWhereInput[]
  }

  export type TeenBuddyUpdateManyWithoutTeenNestedInput = {
    create?: XOR<TeenBuddyCreateWithoutTeenInput, TeenBuddyUncheckedCreateWithoutTeenInput> | TeenBuddyCreateWithoutTeenInput[] | TeenBuddyUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: TeenBuddyCreateOrConnectWithoutTeenInput | TeenBuddyCreateOrConnectWithoutTeenInput[]
    upsert?: TeenBuddyUpsertWithWhereUniqueWithoutTeenInput | TeenBuddyUpsertWithWhereUniqueWithoutTeenInput[]
    createMany?: TeenBuddyCreateManyTeenInputEnvelope
    set?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    disconnect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    delete?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    connect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    update?: TeenBuddyUpdateWithWhereUniqueWithoutTeenInput | TeenBuddyUpdateWithWhereUniqueWithoutTeenInput[]
    updateMany?: TeenBuddyUpdateManyWithWhereWithoutTeenInput | TeenBuddyUpdateManyWithWhereWithoutTeenInput[]
    deleteMany?: TeenBuddyScalarWhereInput | TeenBuddyScalarWhereInput[]
  }

  export type TeenRewardsUpdateOneWithoutTeenNestedInput = {
    create?: XOR<TeenRewardsCreateWithoutTeenInput, TeenRewardsUncheckedCreateWithoutTeenInput>
    connectOrCreate?: TeenRewardsCreateOrConnectWithoutTeenInput
    upsert?: TeenRewardsUpsertWithoutTeenInput
    disconnect?: TeenRewardsWhereInput | boolean
    delete?: TeenRewardsWhereInput | boolean
    connect?: TeenRewardsWhereUniqueInput
    update?: XOR<XOR<TeenRewardsUpdateToOneWithWhereWithoutTeenInput, TeenRewardsUpdateWithoutTeenInput>, TeenRewardsUncheckedUpdateWithoutTeenInput>
  }

  export type RideUncheckedUpdateManyWithoutTeenNestedInput = {
    create?: XOR<RideCreateWithoutTeenInput, RideUncheckedCreateWithoutTeenInput> | RideCreateWithoutTeenInput[] | RideUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: RideCreateOrConnectWithoutTeenInput | RideCreateOrConnectWithoutTeenInput[]
    upsert?: RideUpsertWithWhereUniqueWithoutTeenInput | RideUpsertWithWhereUniqueWithoutTeenInput[]
    createMany?: RideCreateManyTeenInputEnvelope
    set?: RideWhereUniqueInput | RideWhereUniqueInput[]
    disconnect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    delete?: RideWhereUniqueInput | RideWhereUniqueInput[]
    connect?: RideWhereUniqueInput | RideWhereUniqueInput[]
    update?: RideUpdateWithWhereUniqueWithoutTeenInput | RideUpdateWithWhereUniqueWithoutTeenInput[]
    updateMany?: RideUpdateManyWithWhereWithoutTeenInput | RideUpdateManyWithWhereWithoutTeenInput[]
    deleteMany?: RideScalarWhereInput | RideScalarWhereInput[]
  }

  export type RideRequestUncheckedUpdateManyWithoutTeenNestedInput = {
    create?: XOR<RideRequestCreateWithoutTeenInput, RideRequestUncheckedCreateWithoutTeenInput> | RideRequestCreateWithoutTeenInput[] | RideRequestUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: RideRequestCreateOrConnectWithoutTeenInput | RideRequestCreateOrConnectWithoutTeenInput[]
    upsert?: RideRequestUpsertWithWhereUniqueWithoutTeenInput | RideRequestUpsertWithWhereUniqueWithoutTeenInput[]
    createMany?: RideRequestCreateManyTeenInputEnvelope
    set?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    disconnect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    delete?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    connect?: RideRequestWhereUniqueInput | RideRequestWhereUniqueInput[]
    update?: RideRequestUpdateWithWhereUniqueWithoutTeenInput | RideRequestUpdateWithWhereUniqueWithoutTeenInput[]
    updateMany?: RideRequestUpdateManyWithWhereWithoutTeenInput | RideRequestUpdateManyWithWhereWithoutTeenInput[]
    deleteMany?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
  }

  export type TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput = {
    create?: XOR<TeenBuddyCreateWithoutBuddyInput, TeenBuddyUncheckedCreateWithoutBuddyInput> | TeenBuddyCreateWithoutBuddyInput[] | TeenBuddyUncheckedCreateWithoutBuddyInput[]
    connectOrCreate?: TeenBuddyCreateOrConnectWithoutBuddyInput | TeenBuddyCreateOrConnectWithoutBuddyInput[]
    upsert?: TeenBuddyUpsertWithWhereUniqueWithoutBuddyInput | TeenBuddyUpsertWithWhereUniqueWithoutBuddyInput[]
    createMany?: TeenBuddyCreateManyBuddyInputEnvelope
    set?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    disconnect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    delete?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    connect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    update?: TeenBuddyUpdateWithWhereUniqueWithoutBuddyInput | TeenBuddyUpdateWithWhereUniqueWithoutBuddyInput[]
    updateMany?: TeenBuddyUpdateManyWithWhereWithoutBuddyInput | TeenBuddyUpdateManyWithWhereWithoutBuddyInput[]
    deleteMany?: TeenBuddyScalarWhereInput | TeenBuddyScalarWhereInput[]
  }

  export type TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput = {
    create?: XOR<TeenBuddyCreateWithoutTeenInput, TeenBuddyUncheckedCreateWithoutTeenInput> | TeenBuddyCreateWithoutTeenInput[] | TeenBuddyUncheckedCreateWithoutTeenInput[]
    connectOrCreate?: TeenBuddyCreateOrConnectWithoutTeenInput | TeenBuddyCreateOrConnectWithoutTeenInput[]
    upsert?: TeenBuddyUpsertWithWhereUniqueWithoutTeenInput | TeenBuddyUpsertWithWhereUniqueWithoutTeenInput[]
    createMany?: TeenBuddyCreateManyTeenInputEnvelope
    set?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    disconnect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    delete?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    connect?: TeenBuddyWhereUniqueInput | TeenBuddyWhereUniqueInput[]
    update?: TeenBuddyUpdateWithWhereUniqueWithoutTeenInput | TeenBuddyUpdateWithWhereUniqueWithoutTeenInput[]
    updateMany?: TeenBuddyUpdateManyWithWhereWithoutTeenInput | TeenBuddyUpdateManyWithWhereWithoutTeenInput[]
    deleteMany?: TeenBuddyScalarWhereInput | TeenBuddyScalarWhereInput[]
  }

  export type TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput = {
    create?: XOR<TeenRewardsCreateWithoutTeenInput, TeenRewardsUncheckedCreateWithoutTeenInput>
    connectOrCreate?: TeenRewardsCreateOrConnectWithoutTeenInput
    upsert?: TeenRewardsUpsertWithoutTeenInput
    disconnect?: TeenRewardsWhereInput | boolean
    delete?: TeenRewardsWhereInput | boolean
    connect?: TeenRewardsWhereUniqueInput
    update?: XOR<XOR<TeenRewardsUpdateToOneWithWhereWithoutTeenInput, TeenRewardsUpdateWithoutTeenInput>, TeenRewardsUncheckedUpdateWithoutTeenInput>
  }

  export type RouteStopCreateNestedOneWithoutDropRequestsInput = {
    create?: XOR<RouteStopCreateWithoutDropRequestsInput, RouteStopUncheckedCreateWithoutDropRequestsInput>
    connectOrCreate?: RouteStopCreateOrConnectWithoutDropRequestsInput
    connect?: RouteStopWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutRideRequestsInput = {
    create?: XOR<ParentCreateWithoutRideRequestsInput, ParentUncheckedCreateWithoutRideRequestsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutRideRequestsInput
    connect?: ParentWhereUniqueInput
  }

  export type RouteStopCreateNestedOneWithoutPickupRequestsInput = {
    create?: XOR<RouteStopCreateWithoutPickupRequestsInput, RouteStopUncheckedCreateWithoutPickupRequestsInput>
    connectOrCreate?: RouteStopCreateOrConnectWithoutPickupRequestsInput
    connect?: RouteStopWhereUniqueInput
  }

  export type RouteCreateNestedOneWithoutRequestsInput = {
    create?: XOR<RouteCreateWithoutRequestsInput, RouteUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutRequestsInput
    connect?: RouteWhereUniqueInput
  }

  export type TeenCreateNestedOneWithoutRideRequestsInput = {
    create?: XOR<TeenCreateWithoutRideRequestsInput, TeenUncheckedCreateWithoutRideRequestsInput>
    connectOrCreate?: TeenCreateOrConnectWithoutRideRequestsInput
    connect?: TeenWhereUniqueInput
  }

  export type EnumRequestTypeFieldUpdateOperationsInput = {
    set?: $Enums.RequestType
  }

  export type RouteStopUpdateOneRequiredWithoutDropRequestsNestedInput = {
    create?: XOR<RouteStopCreateWithoutDropRequestsInput, RouteStopUncheckedCreateWithoutDropRequestsInput>
    connectOrCreate?: RouteStopCreateOrConnectWithoutDropRequestsInput
    upsert?: RouteStopUpsertWithoutDropRequestsInput
    connect?: RouteStopWhereUniqueInput
    update?: XOR<XOR<RouteStopUpdateToOneWithWhereWithoutDropRequestsInput, RouteStopUpdateWithoutDropRequestsInput>, RouteStopUncheckedUpdateWithoutDropRequestsInput>
  }

  export type ParentUpdateOneRequiredWithoutRideRequestsNestedInput = {
    create?: XOR<ParentCreateWithoutRideRequestsInput, ParentUncheckedCreateWithoutRideRequestsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutRideRequestsInput
    upsert?: ParentUpsertWithoutRideRequestsInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutRideRequestsInput, ParentUpdateWithoutRideRequestsInput>, ParentUncheckedUpdateWithoutRideRequestsInput>
  }

  export type RouteStopUpdateOneRequiredWithoutPickupRequestsNestedInput = {
    create?: XOR<RouteStopCreateWithoutPickupRequestsInput, RouteStopUncheckedCreateWithoutPickupRequestsInput>
    connectOrCreate?: RouteStopCreateOrConnectWithoutPickupRequestsInput
    upsert?: RouteStopUpsertWithoutPickupRequestsInput
    connect?: RouteStopWhereUniqueInput
    update?: XOR<XOR<RouteStopUpdateToOneWithWhereWithoutPickupRequestsInput, RouteStopUpdateWithoutPickupRequestsInput>, RouteStopUncheckedUpdateWithoutPickupRequestsInput>
  }

  export type RouteUpdateOneRequiredWithoutRequestsNestedInput = {
    create?: XOR<RouteCreateWithoutRequestsInput, RouteUncheckedCreateWithoutRequestsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutRequestsInput
    upsert?: RouteUpsertWithoutRequestsInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutRequestsInput, RouteUpdateWithoutRequestsInput>, RouteUncheckedUpdateWithoutRequestsInput>
  }

  export type TeenUpdateOneRequiredWithoutRideRequestsNestedInput = {
    create?: XOR<TeenCreateWithoutRideRequestsInput, TeenUncheckedCreateWithoutRideRequestsInput>
    connectOrCreate?: TeenCreateOrConnectWithoutRideRequestsInput
    upsert?: TeenUpsertWithoutRideRequestsInput
    connect?: TeenWhereUniqueInput
    update?: XOR<XOR<TeenUpdateToOneWithWhereWithoutRideRequestsInput, TeenUpdateWithoutRideRequestsInput>, TeenUncheckedUpdateWithoutRideRequestsInput>
  }

  export type DriverCreateNestedOneWithoutVehicleInput = {
    create?: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput>
    connectOrCreate?: DriverCreateOrConnectWithoutVehicleInput
    connect?: DriverWhereUniqueInput
  }

  export type DriverUpdateOneRequiredWithoutVehicleNestedInput = {
    create?: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput>
    connectOrCreate?: DriverCreateOrConnectWithoutVehicleInput
    upsert?: DriverUpsertWithoutVehicleInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutVehicleInput, DriverUpdateWithoutVehicleInput>, DriverUncheckedUpdateWithoutVehicleInput>
  }

  export type DriverVerificationCreatevehiclePhotosInput = {
    set: string[]
  }

  export type DocumentCreateNestedManyWithoutVerificationInput = {
    create?: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput> | DocumentCreateWithoutVerificationInput[] | DocumentUncheckedCreateWithoutVerificationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutVerificationInput | DocumentCreateOrConnectWithoutVerificationInput[]
    createMany?: DocumentCreateManyVerificationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DriverCreateNestedOneWithoutVerificationInput = {
    create?: XOR<DriverCreateWithoutVerificationInput, DriverUncheckedCreateWithoutVerificationInput>
    connectOrCreate?: DriverCreateOrConnectWithoutVerificationInput
    connect?: DriverWhereUniqueInput
  }

  export type DocumentUncheckedCreateNestedManyWithoutVerificationInput = {
    create?: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput> | DocumentCreateWithoutVerificationInput[] | DocumentUncheckedCreateWithoutVerificationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutVerificationInput | DocumentCreateOrConnectWithoutVerificationInput[]
    createMany?: DocumentCreateManyVerificationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type DriverVerificationUpdatevehiclePhotosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DocumentUpdateManyWithoutVerificationNestedInput = {
    create?: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput> | DocumentCreateWithoutVerificationInput[] | DocumentUncheckedCreateWithoutVerificationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutVerificationInput | DocumentCreateOrConnectWithoutVerificationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutVerificationInput | DocumentUpsertWithWhereUniqueWithoutVerificationInput[]
    createMany?: DocumentCreateManyVerificationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutVerificationInput | DocumentUpdateWithWhereUniqueWithoutVerificationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutVerificationInput | DocumentUpdateManyWithWhereWithoutVerificationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DriverUpdateOneRequiredWithoutVerificationNestedInput = {
    create?: XOR<DriverCreateWithoutVerificationInput, DriverUncheckedCreateWithoutVerificationInput>
    connectOrCreate?: DriverCreateOrConnectWithoutVerificationInput
    upsert?: DriverUpsertWithoutVerificationInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutVerificationInput, DriverUpdateWithoutVerificationInput>, DriverUncheckedUpdateWithoutVerificationInput>
  }

  export type DocumentUncheckedUpdateManyWithoutVerificationNestedInput = {
    create?: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput> | DocumentCreateWithoutVerificationInput[] | DocumentUncheckedCreateWithoutVerificationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutVerificationInput | DocumentCreateOrConnectWithoutVerificationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutVerificationInput | DocumentUpsertWithWhereUniqueWithoutVerificationInput[]
    createMany?: DocumentCreateManyVerificationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutVerificationInput | DocumentUpdateWithWhereUniqueWithoutVerificationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutVerificationInput | DocumentUpdateManyWithWhereWithoutVerificationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DriverVerificationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<DriverVerificationCreateWithoutDocumentsInput, DriverVerificationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DriverVerificationCreateOrConnectWithoutDocumentsInput
    connect?: DriverVerificationWhereUniqueInput
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type DriverVerificationUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<DriverVerificationCreateWithoutDocumentsInput, DriverVerificationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: DriverVerificationCreateOrConnectWithoutDocumentsInput
    upsert?: DriverVerificationUpsertWithoutDocumentsInput
    connect?: DriverVerificationWhereUniqueInput
    update?: XOR<XOR<DriverVerificationUpdateToOneWithWhereWithoutDocumentsInput, DriverVerificationUpdateWithoutDocumentsInput>, DriverVerificationUncheckedUpdateWithoutDocumentsInput>
  }

  export type TransactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput> | TransactionCreateWithoutWalletInput[] | TransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWalletInput | TransactionCreateOrConnectWithoutWalletInput[]
    createMany?: TransactionCreateManyWalletInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ParentCreateNestedOneWithoutWalletInput = {
    create?: XOR<ParentCreateWithoutWalletInput, ParentUncheckedCreateWithoutWalletInput>
    connectOrCreate?: ParentCreateOrConnectWithoutWalletInput
    connect?: ParentWhereUniqueInput
  }

  export type TransactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput> | TransactionCreateWithoutWalletInput[] | TransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWalletInput | TransactionCreateOrConnectWithoutWalletInput[]
    createMany?: TransactionCreateManyWalletInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutWalletNestedInput = {
    create?: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput> | TransactionCreateWithoutWalletInput[] | TransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWalletInput | TransactionCreateOrConnectWithoutWalletInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutWalletInput | TransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: TransactionCreateManyWalletInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutWalletInput | TransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutWalletInput | TransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ParentUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<ParentCreateWithoutWalletInput, ParentUncheckedCreateWithoutWalletInput>
    connectOrCreate?: ParentCreateOrConnectWithoutWalletInput
    upsert?: ParentUpsertWithoutWalletInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutWalletInput, ParentUpdateWithoutWalletInput>, ParentUncheckedUpdateWithoutWalletInput>
  }

  export type TransactionUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput> | TransactionCreateWithoutWalletInput[] | TransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutWalletInput | TransactionCreateOrConnectWithoutWalletInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutWalletInput | TransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: TransactionCreateManyWalletInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutWalletInput | TransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutWalletInput | TransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type RideCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<RideCreateWithoutTransactionsInput, RideUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: RideCreateOrConnectWithoutTransactionsInput
    connect?: RideWhereUniqueInput
  }

  export type WalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type RideUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<RideCreateWithoutTransactionsInput, RideUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: RideCreateOrConnectWithoutTransactionsInput
    upsert?: RideUpsertWithoutTransactionsInput
    disconnect?: RideWhereInput | boolean
    delete?: RideWhereInput | boolean
    connect?: RideWhereUniqueInput
    update?: XOR<XOR<RideUpdateToOneWithWhereWithoutTransactionsInput, RideUpdateWithoutTransactionsInput>, RideUncheckedUpdateWithoutTransactionsInput>
  }

  export type WalletUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    upsert?: WalletUpsertWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTransactionsInput, WalletUpdateWithoutTransactionsInput>, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type TeenCreateNestedOneWithoutBuddyOfInput = {
    create?: XOR<TeenCreateWithoutBuddyOfInput, TeenUncheckedCreateWithoutBuddyOfInput>
    connectOrCreate?: TeenCreateOrConnectWithoutBuddyOfInput
    connect?: TeenWhereUniqueInput
  }

  export type TeenCreateNestedOneWithoutBuddiesInput = {
    create?: XOR<TeenCreateWithoutBuddiesInput, TeenUncheckedCreateWithoutBuddiesInput>
    connectOrCreate?: TeenCreateOrConnectWithoutBuddiesInput
    connect?: TeenWhereUniqueInput
  }

  export type EnumBuddyStatusFieldUpdateOperationsInput = {
    set?: $Enums.BuddyStatus
  }

  export type TeenUpdateOneRequiredWithoutBuddyOfNestedInput = {
    create?: XOR<TeenCreateWithoutBuddyOfInput, TeenUncheckedCreateWithoutBuddyOfInput>
    connectOrCreate?: TeenCreateOrConnectWithoutBuddyOfInput
    upsert?: TeenUpsertWithoutBuddyOfInput
    connect?: TeenWhereUniqueInput
    update?: XOR<XOR<TeenUpdateToOneWithWhereWithoutBuddyOfInput, TeenUpdateWithoutBuddyOfInput>, TeenUncheckedUpdateWithoutBuddyOfInput>
  }

  export type TeenUpdateOneRequiredWithoutBuddiesNestedInput = {
    create?: XOR<TeenCreateWithoutBuddiesInput, TeenUncheckedCreateWithoutBuddiesInput>
    connectOrCreate?: TeenCreateOrConnectWithoutBuddiesInput
    upsert?: TeenUpsertWithoutBuddiesInput
    connect?: TeenWhereUniqueInput
    update?: XOR<XOR<TeenUpdateToOneWithWhereWithoutBuddiesInput, TeenUpdateWithoutBuddiesInput>, TeenUncheckedUpdateWithoutBuddiesInput>
  }

  export type AchievementCreateNestedManyWithoutRewardInput = {
    create?: XOR<AchievementCreateWithoutRewardInput, AchievementUncheckedCreateWithoutRewardInput> | AchievementCreateWithoutRewardInput[] | AchievementUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutRewardInput | AchievementCreateOrConnectWithoutRewardInput[]
    createMany?: AchievementCreateManyRewardInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type TeenCreateNestedOneWithoutRewardsInput = {
    create?: XOR<TeenCreateWithoutRewardsInput, TeenUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: TeenCreateOrConnectWithoutRewardsInput
    connect?: TeenWhereUniqueInput
  }

  export type AchievementUncheckedCreateNestedManyWithoutRewardInput = {
    create?: XOR<AchievementCreateWithoutRewardInput, AchievementUncheckedCreateWithoutRewardInput> | AchievementCreateWithoutRewardInput[] | AchievementUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutRewardInput | AchievementCreateOrConnectWithoutRewardInput[]
    createMany?: AchievementCreateManyRewardInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type AchievementUpdateManyWithoutRewardNestedInput = {
    create?: XOR<AchievementCreateWithoutRewardInput, AchievementUncheckedCreateWithoutRewardInput> | AchievementCreateWithoutRewardInput[] | AchievementUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutRewardInput | AchievementCreateOrConnectWithoutRewardInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutRewardInput | AchievementUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: AchievementCreateManyRewardInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutRewardInput | AchievementUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutRewardInput | AchievementUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type TeenUpdateOneRequiredWithoutRewardsNestedInput = {
    create?: XOR<TeenCreateWithoutRewardsInput, TeenUncheckedCreateWithoutRewardsInput>
    connectOrCreate?: TeenCreateOrConnectWithoutRewardsInput
    upsert?: TeenUpsertWithoutRewardsInput
    connect?: TeenWhereUniqueInput
    update?: XOR<XOR<TeenUpdateToOneWithWhereWithoutRewardsInput, TeenUpdateWithoutRewardsInput>, TeenUncheckedUpdateWithoutRewardsInput>
  }

  export type AchievementUncheckedUpdateManyWithoutRewardNestedInput = {
    create?: XOR<AchievementCreateWithoutRewardInput, AchievementUncheckedCreateWithoutRewardInput> | AchievementCreateWithoutRewardInput[] | AchievementUncheckedCreateWithoutRewardInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutRewardInput | AchievementCreateOrConnectWithoutRewardInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutRewardInput | AchievementUpsertWithWhereUniqueWithoutRewardInput[]
    createMany?: AchievementCreateManyRewardInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutRewardInput | AchievementUpdateWithWhereUniqueWithoutRewardInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutRewardInput | AchievementUpdateManyWithWhereWithoutRewardInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type TeenRewardsCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<TeenRewardsCreateWithoutAchievementsInput, TeenRewardsUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: TeenRewardsCreateOrConnectWithoutAchievementsInput
    connect?: TeenRewardsWhereUniqueInput
  }

  export type TeenRewardsUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<TeenRewardsCreateWithoutAchievementsInput, TeenRewardsUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: TeenRewardsCreateOrConnectWithoutAchievementsInput
    upsert?: TeenRewardsUpsertWithoutAchievementsInput
    connect?: TeenRewardsWhereUniqueInput
    update?: XOR<XOR<TeenRewardsUpdateToOneWithWhereWithoutAchievementsInput, TeenRewardsUpdateWithoutAchievementsInput>, TeenRewardsUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type RouteCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<RouteCreateWithoutFeaturesInput, RouteUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: RouteCreateOrConnectWithoutFeaturesInput
    connect?: RouteWhereUniqueInput
  }

  export type RouteUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<RouteCreateWithoutFeaturesInput, RouteUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: RouteCreateOrConnectWithoutFeaturesInput
    upsert?: RouteUpsertWithoutFeaturesInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutFeaturesInput, RouteUpdateWithoutFeaturesInput>, RouteUncheckedUpdateWithoutFeaturesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocationType[] | ListEnumLocationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRouteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteType | EnumRouteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RouteType[] | ListEnumRouteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteType[] | ListEnumRouteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteTypeFilter<$PrismaModel> | $Enums.RouteType
  }

  export type NestedEnumRouteFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteFrequency | EnumRouteFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RouteFrequency[] | ListEnumRouteFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteFrequency[] | ListEnumRouteFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteFrequencyFilter<$PrismaModel> | $Enums.RouteFrequency
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPricingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeFilter<$PrismaModel> | $Enums.PricingType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRouteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteStatus | EnumRouteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RouteStatus[] | ListEnumRouteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteStatus[] | ListEnumRouteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteStatusFilter<$PrismaModel> | $Enums.RouteStatus
  }

  export type NestedEnumRouteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteType | EnumRouteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RouteType[] | ListEnumRouteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteType[] | ListEnumRouteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteTypeWithAggregatesFilter<$PrismaModel> | $Enums.RouteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRouteTypeFilter<$PrismaModel>
    _max?: NestedEnumRouteTypeFilter<$PrismaModel>
  }

  export type NestedEnumRouteFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteFrequency | EnumRouteFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.RouteFrequency[] | ListEnumRouteFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteFrequency[] | ListEnumRouteFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.RouteFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRouteFrequencyFilter<$PrismaModel>
    _max?: NestedEnumRouteFrequencyFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PricingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingTypeFilter<$PrismaModel>
    _max?: NestedEnumPricingTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumRouteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RouteStatus | EnumRouteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RouteStatus[] | ListEnumRouteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RouteStatus[] | ListEnumRouteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRouteStatusWithAggregatesFilter<$PrismaModel> | $Enums.RouteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRouteStatusFilter<$PrismaModel>
    _max?: NestedEnumRouteStatusFilter<$PrismaModel>
  }

  export type NestedEnumTripStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TripStatus | EnumTripStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTripStatusFilter<$PrismaModel> | $Enums.TripStatus
  }

  export type NestedEnumTripStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TripStatus | EnumTripStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TripStatus[] | ListEnumTripStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTripStatusWithAggregatesFilter<$PrismaModel> | $Enums.TripStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTripStatusFilter<$PrismaModel>
    _max?: NestedEnumTripStatusFilter<$PrismaModel>
  }

  export type NestedEnumRideStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RideStatus | EnumRideStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRideStatusFilter<$PrismaModel> | $Enums.RideStatus
  }

  export type NestedEnumRideStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RideStatus | EnumRideStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RideStatus[] | ListEnumRideStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRideStatusWithAggregatesFilter<$PrismaModel> | $Enums.RideStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRideStatusFilter<$PrismaModel>
    _max?: NestedEnumRideStatusFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationStatusNullableFilter<$PrismaModel> | $Enums.VerificationStatus | null
  }

  export type NestedEnumVerificationStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVerificationStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type NestedEnumInviteTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteType | EnumInviteTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.InviteType[] | ListEnumInviteTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InviteType[] | ListEnumInviteTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInviteTypeNullableFilter<$PrismaModel> | $Enums.InviteType | null
  }

  export type NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type NestedEnumInviteTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteType | EnumInviteTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.InviteType[] | ListEnumInviteTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.InviteType[] | ListEnumInviteTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumInviteTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.InviteType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumInviteTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumInviteTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeFilter<$PrismaModel> | $Enums.RequestType
  }

  export type NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestType | EnumRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestType[] | ListEnumRequestTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.RequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumRequestTypeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumBuddyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BuddyStatus | EnumBuddyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BuddyStatus[] | ListEnumBuddyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BuddyStatus[] | ListEnumBuddyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBuddyStatusFilter<$PrismaModel> | $Enums.BuddyStatus
  }

  export type NestedEnumBuddyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BuddyStatus | EnumBuddyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BuddyStatus[] | ListEnumBuddyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BuddyStatus[] | ListEnumBuddyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBuddyStatusWithAggregatesFilter<$PrismaModel> | $Enums.BuddyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBuddyStatusFilter<$PrismaModel>
    _max?: NestedEnumBuddyStatusFilter<$PrismaModel>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type DriverCreateWithoutUserInput = {
    id?: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verification?: DriverVerificationCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverCreateNestedManyWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
    vehicle?: VehicleCreateNestedOneWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutUserInput = {
    id?: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verification?: DriverVerificationUncheckedCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
    vehicle?: VehicleUncheckedCreateNestedOneWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutUserInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
  }

  export type ParentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rideRequests?: RideRequestCreateNestedManyWithoutParentInput
    teens?: TeenCreateNestedManyWithoutParentInput
    wallet?: WalletCreateNestedOneWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutParentInput
    teens?: TeenUncheckedCreateNestedManyWithoutParentInput
    wallet?: WalletUncheckedCreateNestedOneWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutUserInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
  }

  export type TeenCreateWithoutUserInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestCreateNestedManyWithoutTeenInput
    parent: ParentCreateNestedOneWithoutTeensInput
    school?: LocationCreateNestedOneWithoutTeensInput
    buddyOf?: TeenBuddyCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsCreateNestedOneWithoutTeenInput
  }

  export type TeenUncheckedCreateWithoutUserInput = {
    id?: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutTeenInput
    buddyOf?: TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyUncheckedCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsUncheckedCreateNestedOneWithoutTeenInput
  }

  export type TeenCreateOrConnectWithoutUserInput = {
    where: TeenWhereUniqueInput
    create: XOR<TeenCreateWithoutUserInput, TeenUncheckedCreateWithoutUserInput>
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUpsertWithoutUserInput = {
    update: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutUserInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
  }

  export type DriverUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verification?: DriverVerificationUpdateOneWithoutDriverNestedInput
    routeAssignments?: RouteDriverUpdateManyWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUpdateOneWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verification?: DriverVerificationUncheckedUpdateOneWithoutDriverNestedInput
    routeAssignments?: RouteDriverUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type ParentUpsertWithoutUserInput = {
    update: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutUserInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideRequests?: RideRequestUpdateManyWithoutParentNestedInput
    teens?: TeenUpdateManyWithoutParentNestedInput
    wallet?: WalletUpdateOneWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideRequests?: RideRequestUncheckedUpdateManyWithoutParentNestedInput
    teens?: TeenUncheckedUpdateManyWithoutParentNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutParentNestedInput
  }

  export type TeenUpsertWithoutUserInput = {
    update: XOR<TeenUpdateWithoutUserInput, TeenUncheckedUpdateWithoutUserInput>
    create: XOR<TeenCreateWithoutUserInput, TeenUncheckedCreateWithoutUserInput>
    where?: TeenWhereInput
  }

  export type TeenUpdateToOneWithWhereWithoutUserInput = {
    where?: TeenWhereInput
    data: XOR<TeenUpdateWithoutUserInput, TeenUncheckedUpdateWithoutUserInput>
  }

  export type TeenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUpdateManyWithoutTeenNestedInput
    parent?: ParentUpdateOneRequiredWithoutTeensNestedInput
    school?: LocationUpdateOneWithoutTeensNestedInput
    buddyOf?: TeenBuddyUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUncheckedUpdateManyWithoutTeenNestedInput
    buddyOf?: TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput
  }

  export type RouteStopCreateWithoutLocationInput = {
    id?: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideCreateNestedManyWithoutDropStopInput
    pickupRides?: RideCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestCreateNestedManyWithoutPickupStopInput
    route: RouteCreateNestedOneWithoutStopsInput
  }

  export type RouteStopUncheckedCreateWithoutLocationInput = {
    id?: string
    routeId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideUncheckedCreateNestedManyWithoutDropStopInput
    pickupRides?: RideUncheckedCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestUncheckedCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestUncheckedCreateNestedManyWithoutPickupStopInput
  }

  export type RouteStopCreateOrConnectWithoutLocationInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutLocationInput, RouteStopUncheckedCreateWithoutLocationInput>
  }

  export type RouteStopCreateManyLocationInputEnvelope = {
    data: RouteStopCreateManyLocationInput | RouteStopCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type TeenCreateWithoutSchoolInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestCreateNestedManyWithoutTeenInput
    parent: ParentCreateNestedOneWithoutTeensInput
    user: UserCreateNestedOneWithoutTeenInput
    buddyOf?: TeenBuddyCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsCreateNestedOneWithoutTeenInput
  }

  export type TeenUncheckedCreateWithoutSchoolInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutTeenInput
    buddyOf?: TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyUncheckedCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsUncheckedCreateNestedOneWithoutTeenInput
  }

  export type TeenCreateOrConnectWithoutSchoolInput = {
    where: TeenWhereUniqueInput
    create: XOR<TeenCreateWithoutSchoolInput, TeenUncheckedCreateWithoutSchoolInput>
  }

  export type TeenCreateManySchoolInputEnvelope = {
    data: TeenCreateManySchoolInput | TeenCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type RouteStopUpsertWithWhereUniqueWithoutLocationInput = {
    where: RouteStopWhereUniqueInput
    update: XOR<RouteStopUpdateWithoutLocationInput, RouteStopUncheckedUpdateWithoutLocationInput>
    create: XOR<RouteStopCreateWithoutLocationInput, RouteStopUncheckedCreateWithoutLocationInput>
  }

  export type RouteStopUpdateWithWhereUniqueWithoutLocationInput = {
    where: RouteStopWhereUniqueInput
    data: XOR<RouteStopUpdateWithoutLocationInput, RouteStopUncheckedUpdateWithoutLocationInput>
  }

  export type RouteStopUpdateManyWithWhereWithoutLocationInput = {
    where: RouteStopScalarWhereInput
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyWithoutLocationInput>
  }

  export type RouteStopScalarWhereInput = {
    AND?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
    OR?: RouteStopScalarWhereInput[]
    NOT?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
    id?: StringFilter<"RouteStop"> | string
    routeId?: StringFilter<"RouteStop"> | string
    locationId?: StringFilter<"RouteStop"> | string
    sequence?: IntFilter<"RouteStop"> | number
    arrivalTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
    createdAt?: DateTimeFilter<"RouteStop"> | Date | string
    updatedAt?: DateTimeFilter<"RouteStop"> | Date | string
  }

  export type TeenUpsertWithWhereUniqueWithoutSchoolInput = {
    where: TeenWhereUniqueInput
    update: XOR<TeenUpdateWithoutSchoolInput, TeenUncheckedUpdateWithoutSchoolInput>
    create: XOR<TeenCreateWithoutSchoolInput, TeenUncheckedCreateWithoutSchoolInput>
  }

  export type TeenUpdateWithWhereUniqueWithoutSchoolInput = {
    where: TeenWhereUniqueInput
    data: XOR<TeenUpdateWithoutSchoolInput, TeenUncheckedUpdateWithoutSchoolInput>
  }

  export type TeenUpdateManyWithWhereWithoutSchoolInput = {
    where: TeenScalarWhereInput
    data: XOR<TeenUpdateManyMutationInput, TeenUncheckedUpdateManyWithoutSchoolInput>
  }

  export type TeenScalarWhereInput = {
    AND?: TeenScalarWhereInput | TeenScalarWhereInput[]
    OR?: TeenScalarWhereInput[]
    NOT?: TeenScalarWhereInput | TeenScalarWhereInput[]
    id?: StringFilter<"Teen"> | string
    userId?: StringFilter<"Teen"> | string
    parentId?: StringFilter<"Teen"> | string
    inviteCode?: StringNullableFilter<"Teen"> | string | null
    inviteExpiry?: DateTimeNullableFilter<"Teen"> | Date | string | null
    inviteStatus?: EnumInviteStatusFilter<"Teen"> | $Enums.InviteStatus
    inviteType?: EnumInviteTypeNullableFilter<"Teen"> | $Enums.InviteType | null
    name?: StringFilter<"Teen"> | string
    age?: IntFilter<"Teen"> | number
    grade?: StringNullableFilter<"Teen"> | string | null
    avatar?: StringNullableFilter<"Teen"> | string | null
    schoolId?: StringNullableFilter<"Teen"> | string | null
    emergencyContact?: StringNullableFilter<"Teen"> | string | null
    medicalInfo?: StringNullableFilter<"Teen"> | string | null
    createdAt?: DateTimeFilter<"Teen"> | Date | string
    updatedAt?: DateTimeFilter<"Teen"> | Date | string
  }

  export type RouteFeaturesCreateWithoutRouteInput = {
    id?: string
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFeaturesUncheckedCreateWithoutRouteInput = {
    id?: string
    liveTracking?: boolean
    videoSurveillance?: boolean
    childLocks?: boolean
    speedMonitoring?: boolean
    ac?: boolean
    parentAlerts?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFeaturesCreateOrConnectWithoutRouteInput = {
    where: RouteFeaturesWhereUniqueInput
    create: XOR<RouteFeaturesCreateWithoutRouteInput, RouteFeaturesUncheckedCreateWithoutRouteInput>
  }

  export type RideRequestCreateWithoutRouteInput = {
    id?: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRequestsInput
    parent: ParentCreateNestedOneWithoutRideRequestsInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRequestsInput
    teen: TeenCreateNestedOneWithoutRideRequestsInput
  }

  export type RideRequestUncheckedCreateWithoutRouteInput = {
    id?: string
    parentId: string
    teenId: string
    pickupStopId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestCreateOrConnectWithoutRouteInput = {
    where: RideRequestWhereUniqueInput
    create: XOR<RideRequestCreateWithoutRouteInput, RideRequestUncheckedCreateWithoutRouteInput>
  }

  export type RideRequestCreateManyRouteInputEnvelope = {
    data: RideRequestCreateManyRouteInput | RideRequestCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type RouteDriverCreateWithoutRouteInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    driver: DriverCreateNestedOneWithoutRouteAssignmentsInput
  }

  export type RouteDriverUncheckedCreateWithoutRouteInput = {
    id?: string
    driverId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteDriverCreateOrConnectWithoutRouteInput = {
    where: RouteDriverWhereUniqueInput
    create: XOR<RouteDriverCreateWithoutRouteInput, RouteDriverUncheckedCreateWithoutRouteInput>
  }

  export type RouteDriverCreateManyRouteInputEnvelope = {
    data: RouteDriverCreateManyRouteInput | RouteDriverCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type RouteStopCreateWithoutRouteInput = {
    id?: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideCreateNestedManyWithoutDropStopInput
    pickupRides?: RideCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestCreateNestedManyWithoutPickupStopInput
    location: LocationCreateNestedOneWithoutRouteStopsInput
  }

  export type RouteStopUncheckedCreateWithoutRouteInput = {
    id?: string
    locationId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideUncheckedCreateNestedManyWithoutDropStopInput
    pickupRides?: RideUncheckedCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestUncheckedCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestUncheckedCreateNestedManyWithoutPickupStopInput
  }

  export type RouteStopCreateOrConnectWithoutRouteInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput>
  }

  export type RouteStopCreateManyRouteInputEnvelope = {
    data: RouteStopCreateManyRouteInput | RouteStopCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type TripCreateWithoutRouteInput = {
    id?: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTripInput
    driver: DriverCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutRouteInput = {
    id?: string
    driverId: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutRouteInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput>
  }

  export type TripCreateManyRouteInputEnvelope = {
    data: TripCreateManyRouteInput | TripCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type RouteFeaturesUpsertWithoutRouteInput = {
    update: XOR<RouteFeaturesUpdateWithoutRouteInput, RouteFeaturesUncheckedUpdateWithoutRouteInput>
    create: XOR<RouteFeaturesCreateWithoutRouteInput, RouteFeaturesUncheckedCreateWithoutRouteInput>
    where?: RouteFeaturesWhereInput
  }

  export type RouteFeaturesUpdateToOneWithWhereWithoutRouteInput = {
    where?: RouteFeaturesWhereInput
    data: XOR<RouteFeaturesUpdateWithoutRouteInput, RouteFeaturesUncheckedUpdateWithoutRouteInput>
  }

  export type RouteFeaturesUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    liveTracking?: BoolFieldUpdateOperationsInput | boolean
    videoSurveillance?: BoolFieldUpdateOperationsInput | boolean
    childLocks?: BoolFieldUpdateOperationsInput | boolean
    speedMonitoring?: BoolFieldUpdateOperationsInput | boolean
    ac?: BoolFieldUpdateOperationsInput | boolean
    parentAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFeaturesUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    liveTracking?: BoolFieldUpdateOperationsInput | boolean
    videoSurveillance?: BoolFieldUpdateOperationsInput | boolean
    childLocks?: BoolFieldUpdateOperationsInput | boolean
    speedMonitoring?: BoolFieldUpdateOperationsInput | boolean
    ac?: BoolFieldUpdateOperationsInput | boolean
    parentAlerts?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUpsertWithWhereUniqueWithoutRouteInput = {
    where: RideRequestWhereUniqueInput
    update: XOR<RideRequestUpdateWithoutRouteInput, RideRequestUncheckedUpdateWithoutRouteInput>
    create: XOR<RideRequestCreateWithoutRouteInput, RideRequestUncheckedCreateWithoutRouteInput>
  }

  export type RideRequestUpdateWithWhereUniqueWithoutRouteInput = {
    where: RideRequestWhereUniqueInput
    data: XOR<RideRequestUpdateWithoutRouteInput, RideRequestUncheckedUpdateWithoutRouteInput>
  }

  export type RideRequestUpdateManyWithWhereWithoutRouteInput = {
    where: RideRequestScalarWhereInput
    data: XOR<RideRequestUpdateManyMutationInput, RideRequestUncheckedUpdateManyWithoutRouteInput>
  }

  export type RideRequestScalarWhereInput = {
    AND?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
    OR?: RideRequestScalarWhereInput[]
    NOT?: RideRequestScalarWhereInput | RideRequestScalarWhereInput[]
    id?: StringFilter<"RideRequest"> | string
    parentId?: StringFilter<"RideRequest"> | string
    teenId?: StringFilter<"RideRequest"> | string
    routeId?: StringFilter<"RideRequest"> | string
    pickupStopId?: StringFilter<"RideRequest"> | string
    dropStopId?: StringFilter<"RideRequest"> | string
    requestType?: EnumRequestTypeFilter<"RideRequest"> | $Enums.RequestType
    seatsRequired?: IntFilter<"RideRequest"> | number
    expectedPickupTime?: DateTimeFilter<"RideRequest"> | Date | string
    expectedDropTime?: DateTimeFilter<"RideRequest"> | Date | string
    status?: EnumRouteStatusFilter<"RideRequest"> | $Enums.RouteStatus
    createdAt?: DateTimeFilter<"RideRequest"> | Date | string
    updatedAt?: DateTimeFilter<"RideRequest"> | Date | string
  }

  export type RouteDriverUpsertWithWhereUniqueWithoutRouteInput = {
    where: RouteDriverWhereUniqueInput
    update: XOR<RouteDriverUpdateWithoutRouteInput, RouteDriverUncheckedUpdateWithoutRouteInput>
    create: XOR<RouteDriverCreateWithoutRouteInput, RouteDriverUncheckedCreateWithoutRouteInput>
  }

  export type RouteDriverUpdateWithWhereUniqueWithoutRouteInput = {
    where: RouteDriverWhereUniqueInput
    data: XOR<RouteDriverUpdateWithoutRouteInput, RouteDriverUncheckedUpdateWithoutRouteInput>
  }

  export type RouteDriverUpdateManyWithWhereWithoutRouteInput = {
    where: RouteDriverScalarWhereInput
    data: XOR<RouteDriverUpdateManyMutationInput, RouteDriverUncheckedUpdateManyWithoutRouteInput>
  }

  export type RouteDriverScalarWhereInput = {
    AND?: RouteDriverScalarWhereInput | RouteDriverScalarWhereInput[]
    OR?: RouteDriverScalarWhereInput[]
    NOT?: RouteDriverScalarWhereInput | RouteDriverScalarWhereInput[]
    id?: StringFilter<"RouteDriver"> | string
    routeId?: StringFilter<"RouteDriver"> | string
    driverId?: StringFilter<"RouteDriver"> | string
    startDate?: DateTimeFilter<"RouteDriver"> | Date | string
    endDate?: DateTimeNullableFilter<"RouteDriver"> | Date | string | null
    isActive?: BoolFilter<"RouteDriver"> | boolean
    createdAt?: DateTimeFilter<"RouteDriver"> | Date | string
    updatedAt?: DateTimeFilter<"RouteDriver"> | Date | string
  }

  export type RouteStopUpsertWithWhereUniqueWithoutRouteInput = {
    where: RouteStopWhereUniqueInput
    update: XOR<RouteStopUpdateWithoutRouteInput, RouteStopUncheckedUpdateWithoutRouteInput>
    create: XOR<RouteStopCreateWithoutRouteInput, RouteStopUncheckedCreateWithoutRouteInput>
  }

  export type RouteStopUpdateWithWhereUniqueWithoutRouteInput = {
    where: RouteStopWhereUniqueInput
    data: XOR<RouteStopUpdateWithoutRouteInput, RouteStopUncheckedUpdateWithoutRouteInput>
  }

  export type RouteStopUpdateManyWithWhereWithoutRouteInput = {
    where: RouteStopScalarWhereInput
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyWithoutRouteInput>
  }

  export type TripUpsertWithWhereUniqueWithoutRouteInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutRouteInput, TripUncheckedUpdateWithoutRouteInput>
    create: XOR<TripCreateWithoutRouteInput, TripUncheckedCreateWithoutRouteInput>
  }

  export type TripUpdateWithWhereUniqueWithoutRouteInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutRouteInput, TripUncheckedUpdateWithoutRouteInput>
  }

  export type TripUpdateManyWithWhereWithoutRouteInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutRouteInput>
  }

  export type TripScalarWhereInput = {
    AND?: TripScalarWhereInput | TripScalarWhereInput[]
    OR?: TripScalarWhereInput[]
    NOT?: TripScalarWhereInput | TripScalarWhereInput[]
    id?: StringFilter<"Trip"> | string
    routeId?: StringFilter<"Trip"> | string
    driverId?: StringFilter<"Trip"> | string
    date?: DateTimeFilter<"Trip"> | Date | string
    status?: EnumTripStatusFilter<"Trip"> | $Enums.TripStatus
    startTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Trip"> | Date | string | null
    createdAt?: DateTimeFilter<"Trip"> | Date | string
    updatedAt?: DateTimeFilter<"Trip"> | Date | string
  }

  export type RideCreateWithoutDropStopInput = {
    id?: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupStop: RouteStopCreateNestedOneWithoutPickupRidesInput
    teen: TeenCreateNestedOneWithoutRidesInput
    trip: TripCreateNestedOneWithoutRidesInput
    transactions?: TransactionCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutDropStopInput = {
    id?: string
    tripId: string
    teenId: string
    pickupStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutDropStopInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutDropStopInput, RideUncheckedCreateWithoutDropStopInput>
  }

  export type RideCreateManyDropStopInputEnvelope = {
    data: RideCreateManyDropStopInput | RideCreateManyDropStopInput[]
    skipDuplicates?: boolean
  }

  export type RideCreateWithoutPickupStopInput = {
    id?: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRidesInput
    teen: TeenCreateNestedOneWithoutRidesInput
    trip: TripCreateNestedOneWithoutRidesInput
    transactions?: TransactionCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutPickupStopInput = {
    id?: string
    tripId: string
    teenId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutPickupStopInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutPickupStopInput, RideUncheckedCreateWithoutPickupStopInput>
  }

  export type RideCreateManyPickupStopInputEnvelope = {
    data: RideCreateManyPickupStopInput | RideCreateManyPickupStopInput[]
    skipDuplicates?: boolean
  }

  export type RideRequestCreateWithoutDropStopInput = {
    id?: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    parent: ParentCreateNestedOneWithoutRideRequestsInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRequestsInput
    route: RouteCreateNestedOneWithoutRequestsInput
    teen: TeenCreateNestedOneWithoutRideRequestsInput
  }

  export type RideRequestUncheckedCreateWithoutDropStopInput = {
    id?: string
    parentId: string
    teenId: string
    routeId: string
    pickupStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestCreateOrConnectWithoutDropStopInput = {
    where: RideRequestWhereUniqueInput
    create: XOR<RideRequestCreateWithoutDropStopInput, RideRequestUncheckedCreateWithoutDropStopInput>
  }

  export type RideRequestCreateManyDropStopInputEnvelope = {
    data: RideRequestCreateManyDropStopInput | RideRequestCreateManyDropStopInput[]
    skipDuplicates?: boolean
  }

  export type RideRequestCreateWithoutPickupStopInput = {
    id?: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRequestsInput
    parent: ParentCreateNestedOneWithoutRideRequestsInput
    route: RouteCreateNestedOneWithoutRequestsInput
    teen: TeenCreateNestedOneWithoutRideRequestsInput
  }

  export type RideRequestUncheckedCreateWithoutPickupStopInput = {
    id?: string
    parentId: string
    teenId: string
    routeId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestCreateOrConnectWithoutPickupStopInput = {
    where: RideRequestWhereUniqueInput
    create: XOR<RideRequestCreateWithoutPickupStopInput, RideRequestUncheckedCreateWithoutPickupStopInput>
  }

  export type RideRequestCreateManyPickupStopInputEnvelope = {
    data: RideRequestCreateManyPickupStopInput | RideRequestCreateManyPickupStopInput[]
    skipDuplicates?: boolean
  }

  export type LocationCreateWithoutRouteStopsInput = {
    id?: string
    name: string
    address: string
    latitude: number
    longitude: number
    type: $Enums.LocationType
    isVerified?: boolean
    contactNumber?: string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teens?: TeenCreateNestedManyWithoutSchoolInput
  }

  export type LocationUncheckedCreateWithoutRouteStopsInput = {
    id?: string
    name: string
    address: string
    latitude: number
    longitude: number
    type: $Enums.LocationType
    isVerified?: boolean
    contactNumber?: string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teens?: TeenUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type LocationCreateOrConnectWithoutRouteStopsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRouteStopsInput, LocationUncheckedCreateWithoutRouteStopsInput>
  }

  export type RouteCreateWithoutStopsInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesCreateNestedOneWithoutRouteInput
    requests?: RideRequestCreateNestedManyWithoutRouteInput
    drivers?: RouteDriverCreateNestedManyWithoutRouteInput
    trips?: TripCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutStopsInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesUncheckedCreateNestedOneWithoutRouteInput
    requests?: RideRequestUncheckedCreateNestedManyWithoutRouteInput
    drivers?: RouteDriverUncheckedCreateNestedManyWithoutRouteInput
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutStopsInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutStopsInput, RouteUncheckedCreateWithoutStopsInput>
  }

  export type RideUpsertWithWhereUniqueWithoutDropStopInput = {
    where: RideWhereUniqueInput
    update: XOR<RideUpdateWithoutDropStopInput, RideUncheckedUpdateWithoutDropStopInput>
    create: XOR<RideCreateWithoutDropStopInput, RideUncheckedCreateWithoutDropStopInput>
  }

  export type RideUpdateWithWhereUniqueWithoutDropStopInput = {
    where: RideWhereUniqueInput
    data: XOR<RideUpdateWithoutDropStopInput, RideUncheckedUpdateWithoutDropStopInput>
  }

  export type RideUpdateManyWithWhereWithoutDropStopInput = {
    where: RideScalarWhereInput
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyWithoutDropStopInput>
  }

  export type RideScalarWhereInput = {
    AND?: RideScalarWhereInput | RideScalarWhereInput[]
    OR?: RideScalarWhereInput[]
    NOT?: RideScalarWhereInput | RideScalarWhereInput[]
    id?: StringFilter<"Ride"> | string
    tripId?: StringFilter<"Ride"> | string
    teenId?: StringFilter<"Ride"> | string
    pickupStopId?: StringFilter<"Ride"> | string
    dropStopId?: StringFilter<"Ride"> | string
    status?: EnumRideStatusFilter<"Ride"> | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFilter<"Ride"> | Date | string
    actualPickupTime?: DateTimeNullableFilter<"Ride"> | Date | string | null
    scheduledDropTime?: DateTimeFilter<"Ride"> | Date | string
    actualDropTime?: DateTimeNullableFilter<"Ride"> | Date | string | null
    createdAt?: DateTimeFilter<"Ride"> | Date | string
    updatedAt?: DateTimeFilter<"Ride"> | Date | string
  }

  export type RideUpsertWithWhereUniqueWithoutPickupStopInput = {
    where: RideWhereUniqueInput
    update: XOR<RideUpdateWithoutPickupStopInput, RideUncheckedUpdateWithoutPickupStopInput>
    create: XOR<RideCreateWithoutPickupStopInput, RideUncheckedCreateWithoutPickupStopInput>
  }

  export type RideUpdateWithWhereUniqueWithoutPickupStopInput = {
    where: RideWhereUniqueInput
    data: XOR<RideUpdateWithoutPickupStopInput, RideUncheckedUpdateWithoutPickupStopInput>
  }

  export type RideUpdateManyWithWhereWithoutPickupStopInput = {
    where: RideScalarWhereInput
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyWithoutPickupStopInput>
  }

  export type RideRequestUpsertWithWhereUniqueWithoutDropStopInput = {
    where: RideRequestWhereUniqueInput
    update: XOR<RideRequestUpdateWithoutDropStopInput, RideRequestUncheckedUpdateWithoutDropStopInput>
    create: XOR<RideRequestCreateWithoutDropStopInput, RideRequestUncheckedCreateWithoutDropStopInput>
  }

  export type RideRequestUpdateWithWhereUniqueWithoutDropStopInput = {
    where: RideRequestWhereUniqueInput
    data: XOR<RideRequestUpdateWithoutDropStopInput, RideRequestUncheckedUpdateWithoutDropStopInput>
  }

  export type RideRequestUpdateManyWithWhereWithoutDropStopInput = {
    where: RideRequestScalarWhereInput
    data: XOR<RideRequestUpdateManyMutationInput, RideRequestUncheckedUpdateManyWithoutDropStopInput>
  }

  export type RideRequestUpsertWithWhereUniqueWithoutPickupStopInput = {
    where: RideRequestWhereUniqueInput
    update: XOR<RideRequestUpdateWithoutPickupStopInput, RideRequestUncheckedUpdateWithoutPickupStopInput>
    create: XOR<RideRequestCreateWithoutPickupStopInput, RideRequestUncheckedCreateWithoutPickupStopInput>
  }

  export type RideRequestUpdateWithWhereUniqueWithoutPickupStopInput = {
    where: RideRequestWhereUniqueInput
    data: XOR<RideRequestUpdateWithoutPickupStopInput, RideRequestUncheckedUpdateWithoutPickupStopInput>
  }

  export type RideRequestUpdateManyWithWhereWithoutPickupStopInput = {
    where: RideRequestScalarWhereInput
    data: XOR<RideRequestUpdateManyMutationInput, RideRequestUncheckedUpdateManyWithoutPickupStopInput>
  }

  export type LocationUpsertWithoutRouteStopsInput = {
    update: XOR<LocationUpdateWithoutRouteStopsInput, LocationUncheckedUpdateWithoutRouteStopsInput>
    create: XOR<LocationCreateWithoutRouteStopsInput, LocationUncheckedCreateWithoutRouteStopsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutRouteStopsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutRouteStopsInput, LocationUncheckedUpdateWithoutRouteStopsInput>
  }

  export type LocationUpdateWithoutRouteStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teens?: TeenUpdateManyWithoutSchoolNestedInput
  }

  export type LocationUncheckedUpdateWithoutRouteStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teens?: TeenUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type RouteUpsertWithoutStopsInput = {
    update: XOR<RouteUpdateWithoutStopsInput, RouteUncheckedUpdateWithoutStopsInput>
    create: XOR<RouteCreateWithoutStopsInput, RouteUncheckedCreateWithoutStopsInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutStopsInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutStopsInput, RouteUncheckedUpdateWithoutStopsInput>
  }

  export type RouteUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUpdateOneWithoutRouteNestedInput
    requests?: RideRequestUpdateManyWithoutRouteNestedInput
    drivers?: RouteDriverUpdateManyWithoutRouteNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUncheckedUpdateOneWithoutRouteNestedInput
    requests?: RideRequestUncheckedUpdateManyWithoutRouteNestedInput
    drivers?: RouteDriverUncheckedUpdateManyWithoutRouteNestedInput
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type DriverCreateWithoutRouteAssignmentsInput = {
    id?: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverInput
    verification?: DriverVerificationCreateNestedOneWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
    vehicle?: VehicleCreateNestedOneWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutRouteAssignmentsInput = {
    id?: string
    userId: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verification?: DriverVerificationUncheckedCreateNestedOneWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
    vehicle?: VehicleUncheckedCreateNestedOneWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutRouteAssignmentsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutRouteAssignmentsInput, DriverUncheckedCreateWithoutRouteAssignmentsInput>
  }

  export type RouteCreateWithoutDriversInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesCreateNestedOneWithoutRouteInput
    requests?: RideRequestCreateNestedManyWithoutRouteInput
    stops?: RouteStopCreateNestedManyWithoutRouteInput
    trips?: TripCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutDriversInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesUncheckedCreateNestedOneWithoutRouteInput
    requests?: RideRequestUncheckedCreateNestedManyWithoutRouteInput
    stops?: RouteStopUncheckedCreateNestedManyWithoutRouteInput
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutDriversInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutDriversInput, RouteUncheckedCreateWithoutDriversInput>
  }

  export type DriverUpsertWithoutRouteAssignmentsInput = {
    update: XOR<DriverUpdateWithoutRouteAssignmentsInput, DriverUncheckedUpdateWithoutRouteAssignmentsInput>
    create: XOR<DriverCreateWithoutRouteAssignmentsInput, DriverUncheckedCreateWithoutRouteAssignmentsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutRouteAssignmentsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutRouteAssignmentsInput, DriverUncheckedUpdateWithoutRouteAssignmentsInput>
  }

  export type DriverUpdateWithoutRouteAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    verification?: DriverVerificationUpdateOneWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUpdateOneWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutRouteAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verification?: DriverVerificationUncheckedUpdateOneWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type RouteUpsertWithoutDriversInput = {
    update: XOR<RouteUpdateWithoutDriversInput, RouteUncheckedUpdateWithoutDriversInput>
    create: XOR<RouteCreateWithoutDriversInput, RouteUncheckedCreateWithoutDriversInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutDriversInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutDriversInput, RouteUncheckedUpdateWithoutDriversInput>
  }

  export type RouteUpdateWithoutDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUpdateOneWithoutRouteNestedInput
    requests?: RideRequestUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUpdateManyWithoutRouteNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUncheckedUpdateOneWithoutRouteNestedInput
    requests?: RideRequestUncheckedUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUncheckedUpdateManyWithoutRouteNestedInput
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RideCreateWithoutTripInput = {
    id?: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRidesInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRidesInput
    teen: TeenCreateNestedOneWithoutRidesInput
    transactions?: TransactionCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutTripInput = {
    id?: string
    teenId: string
    pickupStopId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutTripInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutTripInput, RideUncheckedCreateWithoutTripInput>
  }

  export type RideCreateManyTripInputEnvelope = {
    data: RideCreateManyTripInput | RideCreateManyTripInput[]
    skipDuplicates?: boolean
  }

  export type DriverCreateWithoutTripsInput = {
    id?: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverInput
    verification?: DriverVerificationCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverCreateNestedManyWithoutDriverInput
    vehicle?: VehicleCreateNestedOneWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutTripsInput = {
    id?: string
    userId: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verification?: DriverVerificationUncheckedCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverUncheckedCreateNestedManyWithoutDriverInput
    vehicle?: VehicleUncheckedCreateNestedOneWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutTripsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
  }

  export type RouteCreateWithoutTripsInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesCreateNestedOneWithoutRouteInput
    requests?: RideRequestCreateNestedManyWithoutRouteInput
    drivers?: RouteDriverCreateNestedManyWithoutRouteInput
    stops?: RouteStopCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutTripsInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesUncheckedCreateNestedOneWithoutRouteInput
    requests?: RideRequestUncheckedCreateNestedManyWithoutRouteInput
    drivers?: RouteDriverUncheckedCreateNestedManyWithoutRouteInput
    stops?: RouteStopUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutTripsInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
  }

  export type RideUpsertWithWhereUniqueWithoutTripInput = {
    where: RideWhereUniqueInput
    update: XOR<RideUpdateWithoutTripInput, RideUncheckedUpdateWithoutTripInput>
    create: XOR<RideCreateWithoutTripInput, RideUncheckedCreateWithoutTripInput>
  }

  export type RideUpdateWithWhereUniqueWithoutTripInput = {
    where: RideWhereUniqueInput
    data: XOR<RideUpdateWithoutTripInput, RideUncheckedUpdateWithoutTripInput>
  }

  export type RideUpdateManyWithWhereWithoutTripInput = {
    where: RideScalarWhereInput
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyWithoutTripInput>
  }

  export type DriverUpsertWithoutTripsInput = {
    update: XOR<DriverUpdateWithoutTripsInput, DriverUncheckedUpdateWithoutTripsInput>
    create: XOR<DriverCreateWithoutTripsInput, DriverUncheckedCreateWithoutTripsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutTripsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutTripsInput, DriverUncheckedUpdateWithoutTripsInput>
  }

  export type DriverUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    verification?: DriverVerificationUpdateOneWithoutDriverNestedInput
    routeAssignments?: RouteDriverUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUpdateOneWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verification?: DriverVerificationUncheckedUpdateOneWithoutDriverNestedInput
    routeAssignments?: RouteDriverUncheckedUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type RouteUpsertWithoutTripsInput = {
    update: XOR<RouteUpdateWithoutTripsInput, RouteUncheckedUpdateWithoutTripsInput>
    create: XOR<RouteCreateWithoutTripsInput, RouteUncheckedCreateWithoutTripsInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutTripsInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutTripsInput, RouteUncheckedUpdateWithoutTripsInput>
  }

  export type RouteUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUpdateOneWithoutRouteNestedInput
    requests?: RideRequestUpdateManyWithoutRouteNestedInput
    drivers?: RouteDriverUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutTripsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUncheckedUpdateOneWithoutRouteNestedInput
    requests?: RideRequestUncheckedUpdateManyWithoutRouteNestedInput
    drivers?: RouteDriverUncheckedUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteStopCreateWithoutDropRidesInput = {
    id?: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupRides?: RideCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestCreateNestedManyWithoutPickupStopInput
    location: LocationCreateNestedOneWithoutRouteStopsInput
    route: RouteCreateNestedOneWithoutStopsInput
  }

  export type RouteStopUncheckedCreateWithoutDropRidesInput = {
    id?: string
    routeId: string
    locationId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pickupRides?: RideUncheckedCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestUncheckedCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestUncheckedCreateNestedManyWithoutPickupStopInput
  }

  export type RouteStopCreateOrConnectWithoutDropRidesInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutDropRidesInput, RouteStopUncheckedCreateWithoutDropRidesInput>
  }

  export type RouteStopCreateWithoutPickupRidesInput = {
    id?: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideCreateNestedManyWithoutDropStopInput
    dropRequests?: RideRequestCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestCreateNestedManyWithoutPickupStopInput
    location: LocationCreateNestedOneWithoutRouteStopsInput
    route: RouteCreateNestedOneWithoutStopsInput
  }

  export type RouteStopUncheckedCreateWithoutPickupRidesInput = {
    id?: string
    routeId: string
    locationId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideUncheckedCreateNestedManyWithoutDropStopInput
    dropRequests?: RideRequestUncheckedCreateNestedManyWithoutDropStopInput
    pickupRequests?: RideRequestUncheckedCreateNestedManyWithoutPickupStopInput
  }

  export type RouteStopCreateOrConnectWithoutPickupRidesInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutPickupRidesInput, RouteStopUncheckedCreateWithoutPickupRidesInput>
  }

  export type TeenCreateWithoutRidesInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rideRequests?: RideRequestCreateNestedManyWithoutTeenInput
    parent: ParentCreateNestedOneWithoutTeensInput
    school?: LocationCreateNestedOneWithoutTeensInput
    user: UserCreateNestedOneWithoutTeenInput
    buddyOf?: TeenBuddyCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsCreateNestedOneWithoutTeenInput
  }

  export type TeenUncheckedCreateWithoutRidesInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutTeenInput
    buddyOf?: TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyUncheckedCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsUncheckedCreateNestedOneWithoutTeenInput
  }

  export type TeenCreateOrConnectWithoutRidesInput = {
    where: TeenWhereUniqueInput
    create: XOR<TeenCreateWithoutRidesInput, TeenUncheckedCreateWithoutRidesInput>
  }

  export type TripCreateWithoutRidesInput = {
    id?: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    driver: DriverCreateNestedOneWithoutTripsInput
    route: RouteCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutRidesInput = {
    id?: string
    routeId: string
    driverId: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCreateOrConnectWithoutRidesInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutRidesInput, TripUncheckedCreateWithoutRidesInput>
  }

  export type TransactionCreateWithoutRideInput = {
    id?: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    wallet: WalletCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutRideInput = {
    id?: string
    walletId: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutRideInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutRideInput, TransactionUncheckedCreateWithoutRideInput>
  }

  export type TransactionCreateManyRideInputEnvelope = {
    data: TransactionCreateManyRideInput | TransactionCreateManyRideInput[]
    skipDuplicates?: boolean
  }

  export type RouteStopUpsertWithoutDropRidesInput = {
    update: XOR<RouteStopUpdateWithoutDropRidesInput, RouteStopUncheckedUpdateWithoutDropRidesInput>
    create: XOR<RouteStopCreateWithoutDropRidesInput, RouteStopUncheckedCreateWithoutDropRidesInput>
    where?: RouteStopWhereInput
  }

  export type RouteStopUpdateToOneWithWhereWithoutDropRidesInput = {
    where?: RouteStopWhereInput
    data: XOR<RouteStopUpdateWithoutDropRidesInput, RouteStopUncheckedUpdateWithoutDropRidesInput>
  }

  export type RouteStopUpdateWithoutDropRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupRides?: RideUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUpdateManyWithoutPickupStopNestedInput
    location?: LocationUpdateOneRequiredWithoutRouteStopsNestedInput
    route?: RouteUpdateOneRequiredWithoutStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutDropRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupRides?: RideUncheckedUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUncheckedUpdateManyWithoutPickupStopNestedInput
  }

  export type RouteStopUpsertWithoutPickupRidesInput = {
    update: XOR<RouteStopUpdateWithoutPickupRidesInput, RouteStopUncheckedUpdateWithoutPickupRidesInput>
    create: XOR<RouteStopCreateWithoutPickupRidesInput, RouteStopUncheckedCreateWithoutPickupRidesInput>
    where?: RouteStopWhereInput
  }

  export type RouteStopUpdateToOneWithWhereWithoutPickupRidesInput = {
    where?: RouteStopWhereInput
    data: XOR<RouteStopUpdateWithoutPickupRidesInput, RouteStopUncheckedUpdateWithoutPickupRidesInput>
  }

  export type RouteStopUpdateWithoutPickupRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUpdateManyWithoutDropStopNestedInput
    dropRequests?: RideRequestUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUpdateManyWithoutPickupStopNestedInput
    location?: LocationUpdateOneRequiredWithoutRouteStopsNestedInput
    route?: RouteUpdateOneRequiredWithoutStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutPickupRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUncheckedUpdateManyWithoutDropStopNestedInput
    dropRequests?: RideRequestUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUncheckedUpdateManyWithoutPickupStopNestedInput
  }

  export type TeenUpsertWithoutRidesInput = {
    update: XOR<TeenUpdateWithoutRidesInput, TeenUncheckedUpdateWithoutRidesInput>
    create: XOR<TeenCreateWithoutRidesInput, TeenUncheckedCreateWithoutRidesInput>
    where?: TeenWhereInput
  }

  export type TeenUpdateToOneWithWhereWithoutRidesInput = {
    where?: TeenWhereInput
    data: XOR<TeenUpdateWithoutRidesInput, TeenUncheckedUpdateWithoutRidesInput>
  }

  export type TeenUpdateWithoutRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideRequests?: RideRequestUpdateManyWithoutTeenNestedInput
    parent?: ParentUpdateOneRequiredWithoutTeensNestedInput
    school?: LocationUpdateOneWithoutTeensNestedInput
    user?: UserUpdateOneRequiredWithoutTeenNestedInput
    buddyOf?: TeenBuddyUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateWithoutRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideRequests?: RideRequestUncheckedUpdateManyWithoutTeenNestedInput
    buddyOf?: TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput
  }

  export type TripUpsertWithoutRidesInput = {
    update: XOR<TripUpdateWithoutRidesInput, TripUncheckedUpdateWithoutRidesInput>
    create: XOR<TripCreateWithoutRidesInput, TripUncheckedCreateWithoutRidesInput>
    where?: TripWhereInput
  }

  export type TripUpdateToOneWithWhereWithoutRidesInput = {
    where?: TripWhereInput
    data: XOR<TripUpdateWithoutRidesInput, TripUncheckedUpdateWithoutRidesInput>
  }

  export type TripUpdateWithoutRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutRidesInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutRideInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutRideInput, TransactionUncheckedUpdateWithoutRideInput>
    create: XOR<TransactionCreateWithoutRideInput, TransactionUncheckedCreateWithoutRideInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutRideInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutRideInput, TransactionUncheckedUpdateWithoutRideInput>
  }

  export type TransactionUpdateManyWithWhereWithoutRideInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutRideInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    walletId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumPaymentStatusFilter<"Transaction"> | $Enums.PaymentStatus
    description?: StringNullableFilter<"Transaction"> | string | null
    rideId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type UserCreateWithoutParentInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    driver?: DriverCreateNestedOneWithoutUserInput
    teen?: TeenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParentInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    teen?: TeenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
  }

  export type RideRequestCreateWithoutParentInput = {
    id?: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRequestsInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRequestsInput
    route: RouteCreateNestedOneWithoutRequestsInput
    teen: TeenCreateNestedOneWithoutRideRequestsInput
  }

  export type RideRequestUncheckedCreateWithoutParentInput = {
    id?: string
    teenId: string
    routeId: string
    pickupStopId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestCreateOrConnectWithoutParentInput = {
    where: RideRequestWhereUniqueInput
    create: XOR<RideRequestCreateWithoutParentInput, RideRequestUncheckedCreateWithoutParentInput>
  }

  export type RideRequestCreateManyParentInputEnvelope = {
    data: RideRequestCreateManyParentInput | RideRequestCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TeenCreateWithoutParentInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestCreateNestedManyWithoutTeenInput
    school?: LocationCreateNestedOneWithoutTeensInput
    user: UserCreateNestedOneWithoutTeenInput
    buddyOf?: TeenBuddyCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsCreateNestedOneWithoutTeenInput
  }

  export type TeenUncheckedCreateWithoutParentInput = {
    id?: string
    userId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutTeenInput
    buddyOf?: TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyUncheckedCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsUncheckedCreateNestedOneWithoutTeenInput
  }

  export type TeenCreateOrConnectWithoutParentInput = {
    where: TeenWhereUniqueInput
    create: XOR<TeenCreateWithoutParentInput, TeenUncheckedCreateWithoutParentInput>
  }

  export type TeenCreateManyParentInputEnvelope = {
    data: TeenCreateManyParentInput | TeenCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type WalletCreateWithoutParentInput = {
    id?: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutParentInput = {
    id?: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutParentInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutParentInput, WalletUncheckedCreateWithoutParentInput>
  }

  export type UserUpsertWithoutParentInput = {
    update: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
  }

  export type UserUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    teen?: TeenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    teen?: TeenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RideRequestUpsertWithWhereUniqueWithoutParentInput = {
    where: RideRequestWhereUniqueInput
    update: XOR<RideRequestUpdateWithoutParentInput, RideRequestUncheckedUpdateWithoutParentInput>
    create: XOR<RideRequestCreateWithoutParentInput, RideRequestUncheckedCreateWithoutParentInput>
  }

  export type RideRequestUpdateWithWhereUniqueWithoutParentInput = {
    where: RideRequestWhereUniqueInput
    data: XOR<RideRequestUpdateWithoutParentInput, RideRequestUncheckedUpdateWithoutParentInput>
  }

  export type RideRequestUpdateManyWithWhereWithoutParentInput = {
    where: RideRequestScalarWhereInput
    data: XOR<RideRequestUpdateManyMutationInput, RideRequestUncheckedUpdateManyWithoutParentInput>
  }

  export type TeenUpsertWithWhereUniqueWithoutParentInput = {
    where: TeenWhereUniqueInput
    update: XOR<TeenUpdateWithoutParentInput, TeenUncheckedUpdateWithoutParentInput>
    create: XOR<TeenCreateWithoutParentInput, TeenUncheckedCreateWithoutParentInput>
  }

  export type TeenUpdateWithWhereUniqueWithoutParentInput = {
    where: TeenWhereUniqueInput
    data: XOR<TeenUpdateWithoutParentInput, TeenUncheckedUpdateWithoutParentInput>
  }

  export type TeenUpdateManyWithWhereWithoutParentInput = {
    where: TeenScalarWhereInput
    data: XOR<TeenUpdateManyMutationInput, TeenUncheckedUpdateManyWithoutParentInput>
  }

  export type WalletUpsertWithoutParentInput = {
    update: XOR<WalletUpdateWithoutParentInput, WalletUncheckedUpdateWithoutParentInput>
    create: XOR<WalletCreateWithoutParentInput, WalletUncheckedCreateWithoutParentInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutParentInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutParentInput, WalletUncheckedUpdateWithoutParentInput>
  }

  export type WalletUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type UserCreateWithoutDriverInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    teen?: TeenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDriverInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    teen?: TeenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDriverInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
  }

  export type DriverVerificationCreateWithoutDriverInput = {
    id?: string
    status?: $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationCreatevehiclePhotosInput | string[]
    policeVerification?: string | null
    backgroundCheck?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentCreateNestedManyWithoutVerificationInput
  }

  export type DriverVerificationUncheckedCreateWithoutDriverInput = {
    id?: string
    status?: $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationCreatevehiclePhotosInput | string[]
    policeVerification?: string | null
    backgroundCheck?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutVerificationInput
  }

  export type DriverVerificationCreateOrConnectWithoutDriverInput = {
    where: DriverVerificationWhereUniqueInput
    create: XOR<DriverVerificationCreateWithoutDriverInput, DriverVerificationUncheckedCreateWithoutDriverInput>
  }

  export type RouteDriverCreateWithoutDriverInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    route: RouteCreateNestedOneWithoutDriversInput
  }

  export type RouteDriverUncheckedCreateWithoutDriverInput = {
    id?: string
    routeId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteDriverCreateOrConnectWithoutDriverInput = {
    where: RouteDriverWhereUniqueInput
    create: XOR<RouteDriverCreateWithoutDriverInput, RouteDriverUncheckedCreateWithoutDriverInput>
  }

  export type RouteDriverCreateManyDriverInputEnvelope = {
    data: RouteDriverCreateManyDriverInput | RouteDriverCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type TripCreateWithoutDriverInput = {
    id?: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTripInput
    route: RouteCreateNestedOneWithoutTripsInput
  }

  export type TripUncheckedCreateWithoutDriverInput = {
    id?: string
    routeId: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTripInput
  }

  export type TripCreateOrConnectWithoutDriverInput = {
    where: TripWhereUniqueInput
    create: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput>
  }

  export type TripCreateManyDriverInputEnvelope = {
    data: TripCreateManyDriverInput | TripCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type VehicleCreateWithoutDriverInput = {
    id?: string
    make: string
    model: string
    year: number
    plateNumber: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUncheckedCreateWithoutDriverInput = {
    id?: string
    make: string
    model: string
    year: number
    plateNumber: string
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleCreateOrConnectWithoutDriverInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput>
  }

  export type UserUpsertWithoutDriverInput = {
    update: XOR<UserUpdateWithoutDriverInput, UserUncheckedUpdateWithoutDriverInput>
    create: XOR<UserCreateWithoutDriverInput, UserUncheckedCreateWithoutDriverInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDriverInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDriverInput, UserUncheckedUpdateWithoutDriverInput>
  }

  export type UserUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    teen?: TeenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    teen?: TeenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DriverVerificationUpsertWithoutDriverInput = {
    update: XOR<DriverVerificationUpdateWithoutDriverInput, DriverVerificationUncheckedUpdateWithoutDriverInput>
    create: XOR<DriverVerificationCreateWithoutDriverInput, DriverVerificationUncheckedCreateWithoutDriverInput>
    where?: DriverVerificationWhereInput
  }

  export type DriverVerificationUpdateToOneWithWhereWithoutDriverInput = {
    where?: DriverVerificationWhereInput
    data: XOR<DriverVerificationUpdateWithoutDriverInput, DriverVerificationUncheckedUpdateWithoutDriverInput>
  }

  export type DriverVerificationUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationUpdatevehiclePhotosInput | string[]
    policeVerification?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUpdateManyWithoutVerificationNestedInput
  }

  export type DriverVerificationUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationUpdatevehiclePhotosInput | string[]
    policeVerification?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutVerificationNestedInput
  }

  export type RouteDriverUpsertWithWhereUniqueWithoutDriverInput = {
    where: RouteDriverWhereUniqueInput
    update: XOR<RouteDriverUpdateWithoutDriverInput, RouteDriverUncheckedUpdateWithoutDriverInput>
    create: XOR<RouteDriverCreateWithoutDriverInput, RouteDriverUncheckedCreateWithoutDriverInput>
  }

  export type RouteDriverUpdateWithWhereUniqueWithoutDriverInput = {
    where: RouteDriverWhereUniqueInput
    data: XOR<RouteDriverUpdateWithoutDriverInput, RouteDriverUncheckedUpdateWithoutDriverInput>
  }

  export type RouteDriverUpdateManyWithWhereWithoutDriverInput = {
    where: RouteDriverScalarWhereInput
    data: XOR<RouteDriverUpdateManyMutationInput, RouteDriverUncheckedUpdateManyWithoutDriverInput>
  }

  export type TripUpsertWithWhereUniqueWithoutDriverInput = {
    where: TripWhereUniqueInput
    update: XOR<TripUpdateWithoutDriverInput, TripUncheckedUpdateWithoutDriverInput>
    create: XOR<TripCreateWithoutDriverInput, TripUncheckedCreateWithoutDriverInput>
  }

  export type TripUpdateWithWhereUniqueWithoutDriverInput = {
    where: TripWhereUniqueInput
    data: XOR<TripUpdateWithoutDriverInput, TripUncheckedUpdateWithoutDriverInput>
  }

  export type TripUpdateManyWithWhereWithoutDriverInput = {
    where: TripScalarWhereInput
    data: XOR<TripUpdateManyMutationInput, TripUncheckedUpdateManyWithoutDriverInput>
  }

  export type VehicleUpsertWithoutDriverInput = {
    update: XOR<VehicleUpdateWithoutDriverInput, VehicleUncheckedUpdateWithoutDriverInput>
    create: XOR<VehicleCreateWithoutDriverInput, VehicleUncheckedCreateWithoutDriverInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutDriverInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutDriverInput, VehicleUncheckedUpdateWithoutDriverInput>
  }

  export type VehicleUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    make?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    plateNumber?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideCreateWithoutTeenInput = {
    id?: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRidesInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRidesInput
    trip: TripCreateNestedOneWithoutRidesInput
    transactions?: TransactionCreateNestedManyWithoutRideInput
  }

  export type RideUncheckedCreateWithoutTeenInput = {
    id?: string
    tripId: string
    pickupStopId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutRideInput
  }

  export type RideCreateOrConnectWithoutTeenInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutTeenInput, RideUncheckedCreateWithoutTeenInput>
  }

  export type RideCreateManyTeenInputEnvelope = {
    data: RideCreateManyTeenInput | RideCreateManyTeenInput[]
    skipDuplicates?: boolean
  }

  export type RideRequestCreateWithoutTeenInput = {
    id?: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRequestsInput
    parent: ParentCreateNestedOneWithoutRideRequestsInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRequestsInput
    route: RouteCreateNestedOneWithoutRequestsInput
  }

  export type RideRequestUncheckedCreateWithoutTeenInput = {
    id?: string
    parentId: string
    routeId: string
    pickupStopId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestCreateOrConnectWithoutTeenInput = {
    where: RideRequestWhereUniqueInput
    create: XOR<RideRequestCreateWithoutTeenInput, RideRequestUncheckedCreateWithoutTeenInput>
  }

  export type RideRequestCreateManyTeenInputEnvelope = {
    data: RideRequestCreateManyTeenInput | RideRequestCreateManyTeenInput[]
    skipDuplicates?: boolean
  }

  export type ParentCreateWithoutTeensInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
    rideRequests?: RideRequestCreateNestedManyWithoutParentInput
    wallet?: WalletCreateNestedOneWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutTeensInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutParentInput
    wallet?: WalletUncheckedCreateNestedOneWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutTeensInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutTeensInput, ParentUncheckedCreateWithoutTeensInput>
  }

  export type LocationCreateWithoutTeensInput = {
    id?: string
    name: string
    address: string
    latitude: number
    longitude: number
    type: $Enums.LocationType
    isVerified?: boolean
    contactNumber?: string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routeStops?: RouteStopCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutTeensInput = {
    id?: string
    name: string
    address: string
    latitude: number
    longitude: number
    type: $Enums.LocationType
    isVerified?: boolean
    contactNumber?: string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutTeensInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutTeensInput, LocationUncheckedCreateWithoutTeensInput>
  }

  export type UserCreateWithoutTeenInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutUserInput
    driver?: DriverCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeenInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeenInput, UserUncheckedCreateWithoutTeenInput>
  }

  export type TeenBuddyCreateWithoutBuddyInput = {
    id?: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teen: TeenCreateNestedOneWithoutBuddiesInput
  }

  export type TeenBuddyUncheckedCreateWithoutBuddyInput = {
    id?: string
    teenId: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenBuddyCreateOrConnectWithoutBuddyInput = {
    where: TeenBuddyWhereUniqueInput
    create: XOR<TeenBuddyCreateWithoutBuddyInput, TeenBuddyUncheckedCreateWithoutBuddyInput>
  }

  export type TeenBuddyCreateManyBuddyInputEnvelope = {
    data: TeenBuddyCreateManyBuddyInput | TeenBuddyCreateManyBuddyInput[]
    skipDuplicates?: boolean
  }

  export type TeenBuddyCreateWithoutTeenInput = {
    id?: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    buddy: TeenCreateNestedOneWithoutBuddyOfInput
  }

  export type TeenBuddyUncheckedCreateWithoutTeenInput = {
    id?: string
    buddyId: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenBuddyCreateOrConnectWithoutTeenInput = {
    where: TeenBuddyWhereUniqueInput
    create: XOR<TeenBuddyCreateWithoutTeenInput, TeenBuddyUncheckedCreateWithoutTeenInput>
  }

  export type TeenBuddyCreateManyTeenInputEnvelope = {
    data: TeenBuddyCreateManyTeenInput | TeenBuddyCreateManyTeenInput[]
    skipDuplicates?: boolean
  }

  export type TeenRewardsCreateWithoutTeenInput = {
    id?: string
    points?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementCreateNestedManyWithoutRewardInput
  }

  export type TeenRewardsUncheckedCreateWithoutTeenInput = {
    id?: string
    points?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achievements?: AchievementUncheckedCreateNestedManyWithoutRewardInput
  }

  export type TeenRewardsCreateOrConnectWithoutTeenInput = {
    where: TeenRewardsWhereUniqueInput
    create: XOR<TeenRewardsCreateWithoutTeenInput, TeenRewardsUncheckedCreateWithoutTeenInput>
  }

  export type RideUpsertWithWhereUniqueWithoutTeenInput = {
    where: RideWhereUniqueInput
    update: XOR<RideUpdateWithoutTeenInput, RideUncheckedUpdateWithoutTeenInput>
    create: XOR<RideCreateWithoutTeenInput, RideUncheckedCreateWithoutTeenInput>
  }

  export type RideUpdateWithWhereUniqueWithoutTeenInput = {
    where: RideWhereUniqueInput
    data: XOR<RideUpdateWithoutTeenInput, RideUncheckedUpdateWithoutTeenInput>
  }

  export type RideUpdateManyWithWhereWithoutTeenInput = {
    where: RideScalarWhereInput
    data: XOR<RideUpdateManyMutationInput, RideUncheckedUpdateManyWithoutTeenInput>
  }

  export type RideRequestUpsertWithWhereUniqueWithoutTeenInput = {
    where: RideRequestWhereUniqueInput
    update: XOR<RideRequestUpdateWithoutTeenInput, RideRequestUncheckedUpdateWithoutTeenInput>
    create: XOR<RideRequestCreateWithoutTeenInput, RideRequestUncheckedCreateWithoutTeenInput>
  }

  export type RideRequestUpdateWithWhereUniqueWithoutTeenInput = {
    where: RideRequestWhereUniqueInput
    data: XOR<RideRequestUpdateWithoutTeenInput, RideRequestUncheckedUpdateWithoutTeenInput>
  }

  export type RideRequestUpdateManyWithWhereWithoutTeenInput = {
    where: RideRequestScalarWhereInput
    data: XOR<RideRequestUpdateManyMutationInput, RideRequestUncheckedUpdateManyWithoutTeenInput>
  }

  export type ParentUpsertWithoutTeensInput = {
    update: XOR<ParentUpdateWithoutTeensInput, ParentUncheckedUpdateWithoutTeensInput>
    create: XOR<ParentCreateWithoutTeensInput, ParentUncheckedCreateWithoutTeensInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutTeensInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutTeensInput, ParentUncheckedUpdateWithoutTeensInput>
  }

  export type ParentUpdateWithoutTeensInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    rideRequests?: RideRequestUpdateManyWithoutParentNestedInput
    wallet?: WalletUpdateOneWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutTeensInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideRequests?: RideRequestUncheckedUpdateManyWithoutParentNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutParentNestedInput
  }

  export type LocationUpsertWithoutTeensInput = {
    update: XOR<LocationUpdateWithoutTeensInput, LocationUncheckedUpdateWithoutTeensInput>
    create: XOR<LocationCreateWithoutTeensInput, LocationUncheckedCreateWithoutTeensInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutTeensInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutTeensInput, LocationUncheckedUpdateWithoutTeensInput>
  }

  export type LocationUpdateWithoutTeensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routeStops?: RouteStopUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutTeensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    operatingHours?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routeStops?: RouteStopUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type UserUpsertWithoutTeenInput = {
    update: XOR<UserUpdateWithoutTeenInput, UserUncheckedUpdateWithoutTeenInput>
    create: XOR<UserCreateWithoutTeenInput, UserUncheckedCreateWithoutTeenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeenInput, UserUncheckedUpdateWithoutTeenInput>
  }

  export type UserUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutUserNestedInput
    driver?: DriverUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
  }

  export type TeenBuddyUpsertWithWhereUniqueWithoutBuddyInput = {
    where: TeenBuddyWhereUniqueInput
    update: XOR<TeenBuddyUpdateWithoutBuddyInput, TeenBuddyUncheckedUpdateWithoutBuddyInput>
    create: XOR<TeenBuddyCreateWithoutBuddyInput, TeenBuddyUncheckedCreateWithoutBuddyInput>
  }

  export type TeenBuddyUpdateWithWhereUniqueWithoutBuddyInput = {
    where: TeenBuddyWhereUniqueInput
    data: XOR<TeenBuddyUpdateWithoutBuddyInput, TeenBuddyUncheckedUpdateWithoutBuddyInput>
  }

  export type TeenBuddyUpdateManyWithWhereWithoutBuddyInput = {
    where: TeenBuddyScalarWhereInput
    data: XOR<TeenBuddyUpdateManyMutationInput, TeenBuddyUncheckedUpdateManyWithoutBuddyInput>
  }

  export type TeenBuddyScalarWhereInput = {
    AND?: TeenBuddyScalarWhereInput | TeenBuddyScalarWhereInput[]
    OR?: TeenBuddyScalarWhereInput[]
    NOT?: TeenBuddyScalarWhereInput | TeenBuddyScalarWhereInput[]
    id?: StringFilter<"TeenBuddy"> | string
    teenId?: StringFilter<"TeenBuddy"> | string
    buddyId?: StringFilter<"TeenBuddy"> | string
    status?: EnumBuddyStatusFilter<"TeenBuddy"> | $Enums.BuddyStatus
    createdAt?: DateTimeFilter<"TeenBuddy"> | Date | string
    updatedAt?: DateTimeFilter<"TeenBuddy"> | Date | string
  }

  export type TeenBuddyUpsertWithWhereUniqueWithoutTeenInput = {
    where: TeenBuddyWhereUniqueInput
    update: XOR<TeenBuddyUpdateWithoutTeenInput, TeenBuddyUncheckedUpdateWithoutTeenInput>
    create: XOR<TeenBuddyCreateWithoutTeenInput, TeenBuddyUncheckedCreateWithoutTeenInput>
  }

  export type TeenBuddyUpdateWithWhereUniqueWithoutTeenInput = {
    where: TeenBuddyWhereUniqueInput
    data: XOR<TeenBuddyUpdateWithoutTeenInput, TeenBuddyUncheckedUpdateWithoutTeenInput>
  }

  export type TeenBuddyUpdateManyWithWhereWithoutTeenInput = {
    where: TeenBuddyScalarWhereInput
    data: XOR<TeenBuddyUpdateManyMutationInput, TeenBuddyUncheckedUpdateManyWithoutTeenInput>
  }

  export type TeenRewardsUpsertWithoutTeenInput = {
    update: XOR<TeenRewardsUpdateWithoutTeenInput, TeenRewardsUncheckedUpdateWithoutTeenInput>
    create: XOR<TeenRewardsCreateWithoutTeenInput, TeenRewardsUncheckedCreateWithoutTeenInput>
    where?: TeenRewardsWhereInput
  }

  export type TeenRewardsUpdateToOneWithWhereWithoutTeenInput = {
    where?: TeenRewardsWhereInput
    data: XOR<TeenRewardsUpdateWithoutTeenInput, TeenRewardsUncheckedUpdateWithoutTeenInput>
  }

  export type TeenRewardsUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUpdateManyWithoutRewardNestedInput
  }

  export type TeenRewardsUncheckedUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievements?: AchievementUncheckedUpdateManyWithoutRewardNestedInput
  }

  export type RouteStopCreateWithoutDropRequestsInput = {
    id?: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideCreateNestedManyWithoutDropStopInput
    pickupRides?: RideCreateNestedManyWithoutPickupStopInput
    pickupRequests?: RideRequestCreateNestedManyWithoutPickupStopInput
    location: LocationCreateNestedOneWithoutRouteStopsInput
    route: RouteCreateNestedOneWithoutStopsInput
  }

  export type RouteStopUncheckedCreateWithoutDropRequestsInput = {
    id?: string
    routeId: string
    locationId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideUncheckedCreateNestedManyWithoutDropStopInput
    pickupRides?: RideUncheckedCreateNestedManyWithoutPickupStopInput
    pickupRequests?: RideRequestUncheckedCreateNestedManyWithoutPickupStopInput
  }

  export type RouteStopCreateOrConnectWithoutDropRequestsInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutDropRequestsInput, RouteStopUncheckedCreateWithoutDropRequestsInput>
  }

  export type ParentCreateWithoutRideRequestsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
    teens?: TeenCreateNestedManyWithoutParentInput
    wallet?: WalletCreateNestedOneWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutRideRequestsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teens?: TeenUncheckedCreateNestedManyWithoutParentInput
    wallet?: WalletUncheckedCreateNestedOneWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutRideRequestsInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutRideRequestsInput, ParentUncheckedCreateWithoutRideRequestsInput>
  }

  export type RouteStopCreateWithoutPickupRequestsInput = {
    id?: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideCreateNestedManyWithoutDropStopInput
    pickupRides?: RideCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestCreateNestedManyWithoutDropStopInput
    location: LocationCreateNestedOneWithoutRouteStopsInput
    route: RouteCreateNestedOneWithoutStopsInput
  }

  export type RouteStopUncheckedCreateWithoutPickupRequestsInput = {
    id?: string
    routeId: string
    locationId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropRides?: RideUncheckedCreateNestedManyWithoutDropStopInput
    pickupRides?: RideUncheckedCreateNestedManyWithoutPickupStopInput
    dropRequests?: RideRequestUncheckedCreateNestedManyWithoutDropStopInput
  }

  export type RouteStopCreateOrConnectWithoutPickupRequestsInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutPickupRequestsInput, RouteStopUncheckedCreateWithoutPickupRequestsInput>
  }

  export type RouteCreateWithoutRequestsInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesCreateNestedOneWithoutRouteInput
    drivers?: RouteDriverCreateNestedManyWithoutRouteInput
    stops?: RouteStopCreateNestedManyWithoutRouteInput
    trips?: TripCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutRequestsInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: RouteFeaturesUncheckedCreateNestedOneWithoutRouteInput
    drivers?: RouteDriverUncheckedCreateNestedManyWithoutRouteInput
    stops?: RouteStopUncheckedCreateNestedManyWithoutRouteInput
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutRequestsInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutRequestsInput, RouteUncheckedCreateWithoutRequestsInput>
  }

  export type TeenCreateWithoutRideRequestsInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTeenInput
    parent: ParentCreateNestedOneWithoutTeensInput
    school?: LocationCreateNestedOneWithoutTeensInput
    user: UserCreateNestedOneWithoutTeenInput
    buddyOf?: TeenBuddyCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsCreateNestedOneWithoutTeenInput
  }

  export type TeenUncheckedCreateWithoutRideRequestsInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTeenInput
    buddyOf?: TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyUncheckedCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsUncheckedCreateNestedOneWithoutTeenInput
  }

  export type TeenCreateOrConnectWithoutRideRequestsInput = {
    where: TeenWhereUniqueInput
    create: XOR<TeenCreateWithoutRideRequestsInput, TeenUncheckedCreateWithoutRideRequestsInput>
  }

  export type RouteStopUpsertWithoutDropRequestsInput = {
    update: XOR<RouteStopUpdateWithoutDropRequestsInput, RouteStopUncheckedUpdateWithoutDropRequestsInput>
    create: XOR<RouteStopCreateWithoutDropRequestsInput, RouteStopUncheckedCreateWithoutDropRequestsInput>
    where?: RouteStopWhereInput
  }

  export type RouteStopUpdateToOneWithWhereWithoutDropRequestsInput = {
    where?: RouteStopWhereInput
    data: XOR<RouteStopUpdateWithoutDropRequestsInput, RouteStopUncheckedUpdateWithoutDropRequestsInput>
  }

  export type RouteStopUpdateWithoutDropRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUpdateManyWithoutPickupStopNestedInput
    pickupRequests?: RideRequestUpdateManyWithoutPickupStopNestedInput
    location?: LocationUpdateOneRequiredWithoutRouteStopsNestedInput
    route?: RouteUpdateOneRequiredWithoutStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutDropRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUncheckedUpdateManyWithoutPickupStopNestedInput
    pickupRequests?: RideRequestUncheckedUpdateManyWithoutPickupStopNestedInput
  }

  export type ParentUpsertWithoutRideRequestsInput = {
    update: XOR<ParentUpdateWithoutRideRequestsInput, ParentUncheckedUpdateWithoutRideRequestsInput>
    create: XOR<ParentCreateWithoutRideRequestsInput, ParentUncheckedCreateWithoutRideRequestsInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutRideRequestsInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutRideRequestsInput, ParentUncheckedUpdateWithoutRideRequestsInput>
  }

  export type ParentUpdateWithoutRideRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    teens?: TeenUpdateManyWithoutParentNestedInput
    wallet?: WalletUpdateOneWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutRideRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teens?: TeenUncheckedUpdateManyWithoutParentNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutParentNestedInput
  }

  export type RouteStopUpsertWithoutPickupRequestsInput = {
    update: XOR<RouteStopUpdateWithoutPickupRequestsInput, RouteStopUncheckedUpdateWithoutPickupRequestsInput>
    create: XOR<RouteStopCreateWithoutPickupRequestsInput, RouteStopUncheckedCreateWithoutPickupRequestsInput>
    where?: RouteStopWhereInput
  }

  export type RouteStopUpdateToOneWithWhereWithoutPickupRequestsInput = {
    where?: RouteStopWhereInput
    data: XOR<RouteStopUpdateWithoutPickupRequestsInput, RouteStopUncheckedUpdateWithoutPickupRequestsInput>
  }

  export type RouteStopUpdateWithoutPickupRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUpdateManyWithoutDropStopNestedInput
    location?: LocationUpdateOneRequiredWithoutRouteStopsNestedInput
    route?: RouteUpdateOneRequiredWithoutStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutPickupRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUncheckedUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUncheckedUpdateManyWithoutDropStopNestedInput
  }

  export type RouteUpsertWithoutRequestsInput = {
    update: XOR<RouteUpdateWithoutRequestsInput, RouteUncheckedUpdateWithoutRequestsInput>
    create: XOR<RouteCreateWithoutRequestsInput, RouteUncheckedCreateWithoutRequestsInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutRequestsInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutRequestsInput, RouteUncheckedUpdateWithoutRequestsInput>
  }

  export type RouteUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUpdateOneWithoutRouteNestedInput
    drivers?: RouteDriverUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUpdateManyWithoutRouteNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: RouteFeaturesUncheckedUpdateOneWithoutRouteNestedInput
    drivers?: RouteDriverUncheckedUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUncheckedUpdateManyWithoutRouteNestedInput
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type TeenUpsertWithoutRideRequestsInput = {
    update: XOR<TeenUpdateWithoutRideRequestsInput, TeenUncheckedUpdateWithoutRideRequestsInput>
    create: XOR<TeenCreateWithoutRideRequestsInput, TeenUncheckedCreateWithoutRideRequestsInput>
    where?: TeenWhereInput
  }

  export type TeenUpdateToOneWithWhereWithoutRideRequestsInput = {
    where?: TeenWhereInput
    data: XOR<TeenUpdateWithoutRideRequestsInput, TeenUncheckedUpdateWithoutRideRequestsInput>
  }

  export type TeenUpdateWithoutRideRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTeenNestedInput
    parent?: ParentUpdateOneRequiredWithoutTeensNestedInput
    school?: LocationUpdateOneWithoutTeensNestedInput
    user?: UserUpdateOneRequiredWithoutTeenNestedInput
    buddyOf?: TeenBuddyUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateWithoutRideRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTeenNestedInput
    buddyOf?: TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput
  }

  export type DriverCreateWithoutVehicleInput = {
    id?: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverInput
    verification?: DriverVerificationCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverCreateNestedManyWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutVehicleInput = {
    id?: string
    userId: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    verification?: DriverVerificationUncheckedCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutVehicleInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput>
  }

  export type DriverUpsertWithoutVehicleInput = {
    update: XOR<DriverUpdateWithoutVehicleInput, DriverUncheckedUpdateWithoutVehicleInput>
    create: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutVehicleInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutVehicleInput, DriverUncheckedUpdateWithoutVehicleInput>
  }

  export type DriverUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    verification?: DriverVerificationUpdateOneWithoutDriverNestedInput
    routeAssignments?: RouteDriverUpdateManyWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verification?: DriverVerificationUncheckedUpdateOneWithoutDriverNestedInput
    routeAssignments?: RouteDriverUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DocumentCreateWithoutVerificationInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    expiryDate?: Date | string | null
    fileUrl: string
    status?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutVerificationInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    expiryDate?: Date | string | null
    fileUrl: string
    status?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutVerificationInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput>
  }

  export type DocumentCreateManyVerificationInputEnvelope = {
    data: DocumentCreateManyVerificationInput | DocumentCreateManyVerificationInput[]
    skipDuplicates?: boolean
  }

  export type DriverCreateWithoutVerificationInput = {
    id?: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverInput
    routeAssignments?: RouteDriverCreateNestedManyWithoutDriverInput
    trips?: TripCreateNestedManyWithoutDriverInput
    vehicle?: VehicleCreateNestedOneWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutVerificationInput = {
    id?: string
    userId: string
    licenseNumber: string
    aadharNumber: string
    verificationStatus?: $Enums.VerificationStatus | null
    rating?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    routeAssignments?: RouteDriverUncheckedCreateNestedManyWithoutDriverInput
    trips?: TripUncheckedCreateNestedManyWithoutDriverInput
    vehicle?: VehicleUncheckedCreateNestedOneWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutVerificationInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutVerificationInput, DriverUncheckedCreateWithoutVerificationInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutVerificationInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutVerificationInput, DocumentUncheckedUpdateWithoutVerificationInput>
    create: XOR<DocumentCreateWithoutVerificationInput, DocumentUncheckedCreateWithoutVerificationInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutVerificationInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutVerificationInput, DocumentUncheckedUpdateWithoutVerificationInput>
  }

  export type DocumentUpdateManyWithWhereWithoutVerificationInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutVerificationInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    number?: StringFilter<"Document"> | string
    expiryDate?: DateTimeNullableFilter<"Document"> | Date | string | null
    fileUrl?: StringFilter<"Document"> | string
    verificationId?: StringFilter<"Document"> | string
    status?: EnumVerificationStatusFilter<"Document"> | $Enums.VerificationStatus
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type DriverUpsertWithoutVerificationInput = {
    update: XOR<DriverUpdateWithoutVerificationInput, DriverUncheckedUpdateWithoutVerificationInput>
    create: XOR<DriverCreateWithoutVerificationInput, DriverUncheckedCreateWithoutVerificationInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutVerificationInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutVerificationInput, DriverUncheckedUpdateWithoutVerificationInput>
  }

  export type DriverUpdateWithoutVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverNestedInput
    routeAssignments?: RouteDriverUpdateManyWithoutDriverNestedInput
    trips?: TripUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUpdateOneWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    aadharNumber?: StringFieldUpdateOperationsInput | string
    verificationStatus?: NullableEnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus | null
    rating?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routeAssignments?: RouteDriverUncheckedUpdateManyWithoutDriverNestedInput
    trips?: TripUncheckedUpdateManyWithoutDriverNestedInput
    vehicle?: VehicleUncheckedUpdateOneWithoutDriverNestedInput
  }

  export type DriverVerificationCreateWithoutDocumentsInput = {
    id?: string
    status?: $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationCreatevehiclePhotosInput | string[]
    policeVerification?: string | null
    backgroundCheck?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    driver: DriverCreateNestedOneWithoutVerificationInput
  }

  export type DriverVerificationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    driverId: string
    status?: $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationCreatevehiclePhotosInput | string[]
    policeVerification?: string | null
    backgroundCheck?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverVerificationCreateOrConnectWithoutDocumentsInput = {
    where: DriverVerificationWhereUniqueInput
    create: XOR<DriverVerificationCreateWithoutDocumentsInput, DriverVerificationUncheckedCreateWithoutDocumentsInput>
  }

  export type DriverVerificationUpsertWithoutDocumentsInput = {
    update: XOR<DriverVerificationUpdateWithoutDocumentsInput, DriverVerificationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DriverVerificationCreateWithoutDocumentsInput, DriverVerificationUncheckedCreateWithoutDocumentsInput>
    where?: DriverVerificationWhereInput
  }

  export type DriverVerificationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: DriverVerificationWhereInput
    data: XOR<DriverVerificationUpdateWithoutDocumentsInput, DriverVerificationUncheckedUpdateWithoutDocumentsInput>
  }

  export type DriverVerificationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationUpdatevehiclePhotosInput | string[]
    policeVerification?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutVerificationNestedInput
  }

  export type DriverVerificationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    vehiclePhotos?: DriverVerificationUpdatevehiclePhotosInput | string[]
    policeVerification?: NullableStringFieldUpdateOperationsInput | string | null
    backgroundCheck?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateWithoutWalletInput = {
    id?: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ride?: RideCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutWalletInput = {
    id?: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    rideId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput>
  }

  export type TransactionCreateManyWalletInputEnvelope = {
    data: TransactionCreateManyWalletInput | TransactionCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type ParentCreateWithoutWalletInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
    rideRequests?: RideRequestCreateNestedManyWithoutParentInput
    teens?: TeenCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutWalletInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutParentInput
    teens?: TeenUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutWalletInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutWalletInput, ParentUncheckedCreateWithoutWalletInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutWalletInput, TransactionUncheckedUpdateWithoutWalletInput>
    create: XOR<TransactionCreateWithoutWalletInput, TransactionUncheckedCreateWithoutWalletInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutWalletInput, TransactionUncheckedUpdateWithoutWalletInput>
  }

  export type TransactionUpdateManyWithWhereWithoutWalletInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutWalletInput>
  }

  export type ParentUpsertWithoutWalletInput = {
    update: XOR<ParentUpdateWithoutWalletInput, ParentUncheckedUpdateWithoutWalletInput>
    create: XOR<ParentCreateWithoutWalletInput, ParentUncheckedCreateWithoutWalletInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutWalletInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutWalletInput, ParentUncheckedUpdateWithoutWalletInput>
  }

  export type ParentUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    rideRequests?: RideRequestUpdateManyWithoutParentNestedInput
    teens?: TeenUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rideRequests?: RideRequestUncheckedUpdateManyWithoutParentNestedInput
    teens?: TeenUncheckedUpdateManyWithoutParentNestedInput
  }

  export type RideCreateWithoutTransactionsInput = {
    id?: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropStop: RouteStopCreateNestedOneWithoutDropRidesInput
    pickupStop: RouteStopCreateNestedOneWithoutPickupRidesInput
    teen: TeenCreateNestedOneWithoutRidesInput
    trip: TripCreateNestedOneWithoutRidesInput
  }

  export type RideUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tripId: string
    teenId: string
    pickupStopId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideCreateOrConnectWithoutTransactionsInput = {
    where: RideWhereUniqueInput
    create: XOR<RideCreateWithoutTransactionsInput, RideUncheckedCreateWithoutTransactionsInput>
  }

  export type WalletCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent: ParentCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    parentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutTransactionsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
  }

  export type RideUpsertWithoutTransactionsInput = {
    update: XOR<RideUpdateWithoutTransactionsInput, RideUncheckedUpdateWithoutTransactionsInput>
    create: XOR<RideCreateWithoutTransactionsInput, RideUncheckedCreateWithoutTransactionsInput>
    where?: RideWhereInput
  }

  export type RideUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: RideWhereInput
    data: XOR<RideUpdateWithoutTransactionsInput, RideUncheckedUpdateWithoutTransactionsInput>
  }

  export type RideUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRidesNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRidesNestedInput
    teen?: TeenUpdateOneRequiredWithoutRidesNestedInput
    trip?: TripUpdateOneRequiredWithoutRidesNestedInput
  }

  export type RideUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUpsertWithoutTransactionsInput = {
    update: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type WalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    parentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenCreateWithoutBuddyOfInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestCreateNestedManyWithoutTeenInput
    parent: ParentCreateNestedOneWithoutTeensInput
    school?: LocationCreateNestedOneWithoutTeensInput
    user: UserCreateNestedOneWithoutTeenInput
    buddies?: TeenBuddyCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsCreateNestedOneWithoutTeenInput
  }

  export type TeenUncheckedCreateWithoutBuddyOfInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutTeenInput
    buddies?: TeenBuddyUncheckedCreateNestedManyWithoutTeenInput
    rewards?: TeenRewardsUncheckedCreateNestedOneWithoutTeenInput
  }

  export type TeenCreateOrConnectWithoutBuddyOfInput = {
    where: TeenWhereUniqueInput
    create: XOR<TeenCreateWithoutBuddyOfInput, TeenUncheckedCreateWithoutBuddyOfInput>
  }

  export type TeenCreateWithoutBuddiesInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestCreateNestedManyWithoutTeenInput
    parent: ParentCreateNestedOneWithoutTeensInput
    school?: LocationCreateNestedOneWithoutTeensInput
    user: UserCreateNestedOneWithoutTeenInput
    buddyOf?: TeenBuddyCreateNestedManyWithoutBuddyInput
    rewards?: TeenRewardsCreateNestedOneWithoutTeenInput
  }

  export type TeenUncheckedCreateWithoutBuddiesInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutTeenInput
    buddyOf?: TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput
    rewards?: TeenRewardsUncheckedCreateNestedOneWithoutTeenInput
  }

  export type TeenCreateOrConnectWithoutBuddiesInput = {
    where: TeenWhereUniqueInput
    create: XOR<TeenCreateWithoutBuddiesInput, TeenUncheckedCreateWithoutBuddiesInput>
  }

  export type TeenUpsertWithoutBuddyOfInput = {
    update: XOR<TeenUpdateWithoutBuddyOfInput, TeenUncheckedUpdateWithoutBuddyOfInput>
    create: XOR<TeenCreateWithoutBuddyOfInput, TeenUncheckedCreateWithoutBuddyOfInput>
    where?: TeenWhereInput
  }

  export type TeenUpdateToOneWithWhereWithoutBuddyOfInput = {
    where?: TeenWhereInput
    data: XOR<TeenUpdateWithoutBuddyOfInput, TeenUncheckedUpdateWithoutBuddyOfInput>
  }

  export type TeenUpdateWithoutBuddyOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUpdateManyWithoutTeenNestedInput
    parent?: ParentUpdateOneRequiredWithoutTeensNestedInput
    school?: LocationUpdateOneWithoutTeensNestedInput
    user?: UserUpdateOneRequiredWithoutTeenNestedInput
    buddies?: TeenBuddyUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateWithoutBuddyOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUncheckedUpdateManyWithoutTeenNestedInput
    buddies?: TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput
  }

  export type TeenUpsertWithoutBuddiesInput = {
    update: XOR<TeenUpdateWithoutBuddiesInput, TeenUncheckedUpdateWithoutBuddiesInput>
    create: XOR<TeenCreateWithoutBuddiesInput, TeenUncheckedCreateWithoutBuddiesInput>
    where?: TeenWhereInput
  }

  export type TeenUpdateToOneWithWhereWithoutBuddiesInput = {
    where?: TeenWhereInput
    data: XOR<TeenUpdateWithoutBuddiesInput, TeenUncheckedUpdateWithoutBuddiesInput>
  }

  export type TeenUpdateWithoutBuddiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUpdateManyWithoutTeenNestedInput
    parent?: ParentUpdateOneRequiredWithoutTeensNestedInput
    school?: LocationUpdateOneWithoutTeensNestedInput
    user?: UserUpdateOneRequiredWithoutTeenNestedInput
    buddyOf?: TeenBuddyUpdateManyWithoutBuddyNestedInput
    rewards?: TeenRewardsUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateWithoutBuddiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUncheckedUpdateManyWithoutTeenNestedInput
    buddyOf?: TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput
    rewards?: TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput
  }

  export type AchievementCreateWithoutRewardInput = {
    id?: string
    name: string
    description: string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutRewardInput = {
    id?: string
    name: string
    description: string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutRewardInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutRewardInput, AchievementUncheckedCreateWithoutRewardInput>
  }

  export type AchievementCreateManyRewardInputEnvelope = {
    data: AchievementCreateManyRewardInput | AchievementCreateManyRewardInput[]
    skipDuplicates?: boolean
  }

  export type TeenCreateWithoutRewardsInput = {
    id?: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestCreateNestedManyWithoutTeenInput
    parent: ParentCreateNestedOneWithoutTeensInput
    school?: LocationCreateNestedOneWithoutTeensInput
    user: UserCreateNestedOneWithoutTeenInput
    buddyOf?: TeenBuddyCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyCreateNestedManyWithoutTeenInput
  }

  export type TeenUncheckedCreateWithoutRewardsInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rides?: RideUncheckedCreateNestedManyWithoutTeenInput
    rideRequests?: RideRequestUncheckedCreateNestedManyWithoutTeenInput
    buddyOf?: TeenBuddyUncheckedCreateNestedManyWithoutBuddyInput
    buddies?: TeenBuddyUncheckedCreateNestedManyWithoutTeenInput
  }

  export type TeenCreateOrConnectWithoutRewardsInput = {
    where: TeenWhereUniqueInput
    create: XOR<TeenCreateWithoutRewardsInput, TeenUncheckedCreateWithoutRewardsInput>
  }

  export type AchievementUpsertWithWhereUniqueWithoutRewardInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutRewardInput, AchievementUncheckedUpdateWithoutRewardInput>
    create: XOR<AchievementCreateWithoutRewardInput, AchievementUncheckedCreateWithoutRewardInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutRewardInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutRewardInput, AchievementUncheckedUpdateWithoutRewardInput>
  }

  export type AchievementUpdateManyWithWhereWithoutRewardInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutRewardInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    points?: IntFilter<"Achievement"> | number
    rewardId?: StringFilter<"Achievement"> | string
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
  }

  export type TeenUpsertWithoutRewardsInput = {
    update: XOR<TeenUpdateWithoutRewardsInput, TeenUncheckedUpdateWithoutRewardsInput>
    create: XOR<TeenCreateWithoutRewardsInput, TeenUncheckedCreateWithoutRewardsInput>
    where?: TeenWhereInput
  }

  export type TeenUpdateToOneWithWhereWithoutRewardsInput = {
    where?: TeenWhereInput
    data: XOR<TeenUpdateWithoutRewardsInput, TeenUncheckedUpdateWithoutRewardsInput>
  }

  export type TeenUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUpdateManyWithoutTeenNestedInput
    parent?: ParentUpdateOneRequiredWithoutTeensNestedInput
    school?: LocationUpdateOneWithoutTeensNestedInput
    user?: UserUpdateOneRequiredWithoutTeenNestedInput
    buddyOf?: TeenBuddyUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUpdateManyWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateWithoutRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUncheckedUpdateManyWithoutTeenNestedInput
    buddyOf?: TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput
  }

  export type TeenRewardsCreateWithoutAchievementsInput = {
    id?: string
    points?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teen: TeenCreateNestedOneWithoutRewardsInput
  }

  export type TeenRewardsUncheckedCreateWithoutAchievementsInput = {
    id?: string
    teenId: string
    points?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenRewardsCreateOrConnectWithoutAchievementsInput = {
    where: TeenRewardsWhereUniqueInput
    create: XOR<TeenRewardsCreateWithoutAchievementsInput, TeenRewardsUncheckedCreateWithoutAchievementsInput>
  }

  export type TeenRewardsUpsertWithoutAchievementsInput = {
    update: XOR<TeenRewardsUpdateWithoutAchievementsInput, TeenRewardsUncheckedUpdateWithoutAchievementsInput>
    create: XOR<TeenRewardsCreateWithoutAchievementsInput, TeenRewardsUncheckedCreateWithoutAchievementsInput>
    where?: TeenRewardsWhereInput
  }

  export type TeenRewardsUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: TeenRewardsWhereInput
    data: XOR<TeenRewardsUpdateWithoutAchievementsInput, TeenRewardsUncheckedUpdateWithoutAchievementsInput>
  }

  export type TeenRewardsUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teen?: TeenUpdateOneRequiredWithoutRewardsNestedInput
  }

  export type TeenRewardsUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    driver?: DriverCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    teen?: TeenCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    name: string
    phone: string
    role: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    driver?: DriverUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    teen?: TeenUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    teen?: TeenUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    teen?: TeenUncheckedUpdateOneWithoutUserNestedInput
  }

  export type RouteCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: RideRequestCreateNestedManyWithoutRouteInput
    drivers?: RouteDriverCreateNestedManyWithoutRouteInput
    stops?: RouteStopCreateNestedManyWithoutRouteInput
    trips?: TripCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description?: string | null
    routeType: $Enums.RouteType
    frequency: $Enums.RouteFrequency
    daysOfWeek?: RouteCreatedaysOfWeekInput | number[]
    startDate: Date | string
    endDate?: Date | string | null
    isRecurring?: boolean
    baseFare: number
    pricingType: $Enums.PricingType
    perKmRate?: number | null
    roundTripDiscount?: number | null
    totalSeats: number
    availableSeats: number
    farePerSeat: number
    status?: $Enums.RouteStatus
    isActive?: boolean
    isListedPublicly?: boolean
    allowDriverBidding?: boolean
    autoApproveRequests?: boolean
    minOccupancyRatio?: number
    maxOccupancyRatio?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    requests?: RideRequestUncheckedCreateNestedManyWithoutRouteInput
    drivers?: RouteDriverUncheckedCreateNestedManyWithoutRouteInput
    stops?: RouteStopUncheckedCreateNestedManyWithoutRouteInput
    trips?: TripUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutFeaturesInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutFeaturesInput, RouteUncheckedCreateWithoutFeaturesInput>
  }

  export type RouteUpsertWithoutFeaturesInput = {
    update: XOR<RouteUpdateWithoutFeaturesInput, RouteUncheckedUpdateWithoutFeaturesInput>
    create: XOR<RouteCreateWithoutFeaturesInput, RouteUncheckedCreateWithoutFeaturesInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutFeaturesInput, RouteUncheckedUpdateWithoutFeaturesInput>
  }

  export type RouteUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: RideRequestUpdateManyWithoutRouteNestedInput
    drivers?: RouteDriverUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUpdateManyWithoutRouteNestedInput
    trips?: TripUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    routeType?: EnumRouteTypeFieldUpdateOperationsInput | $Enums.RouteType
    frequency?: EnumRouteFrequencyFieldUpdateOperationsInput | $Enums.RouteFrequency
    daysOfWeek?: RouteUpdatedaysOfWeekInput | number[]
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    baseFare?: FloatFieldUpdateOperationsInput | number
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    roundTripDiscount?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSeats?: IntFieldUpdateOperationsInput | number
    availableSeats?: IntFieldUpdateOperationsInput | number
    farePerSeat?: FloatFieldUpdateOperationsInput | number
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isListedPublicly?: BoolFieldUpdateOperationsInput | boolean
    allowDriverBidding?: BoolFieldUpdateOperationsInput | boolean
    autoApproveRequests?: BoolFieldUpdateOperationsInput | boolean
    minOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    maxOccupancyRatio?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requests?: RideRequestUncheckedUpdateManyWithoutRouteNestedInput
    drivers?: RouteDriverUncheckedUpdateManyWithoutRouteNestedInput
    stops?: RouteStopUncheckedUpdateManyWithoutRouteNestedInput
    trips?: TripUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteStopCreateManyLocationInput = {
    id?: string
    routeId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenCreateManySchoolInput = {
    id?: string
    userId: string
    parentId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteStopUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUpdateManyWithoutPickupStopNestedInput
    route?: RouteUpdateOneRequiredWithoutStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUncheckedUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUncheckedUpdateManyWithoutPickupStopNestedInput
  }

  export type RouteStopUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUpdateManyWithoutTeenNestedInput
    parent?: ParentUpdateOneRequiredWithoutTeensNestedInput
    user?: UserUpdateOneRequiredWithoutTeenNestedInput
    buddyOf?: TeenBuddyUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUncheckedUpdateManyWithoutTeenNestedInput
    buddyOf?: TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateManyWithoutSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestCreateManyRouteInput = {
    id?: string
    parentId: string
    teenId: string
    pickupStopId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteDriverCreateManyRouteInput = {
    id?: string
    driverId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteStopCreateManyRouteInput = {
    id?: string
    locationId: string
    sequence: number
    arrivalTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCreateManyRouteInput = {
    id?: string
    driverId: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRequestsNestedInput
    parent?: ParentUpdateOneRequiredWithoutRideRequestsNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRequestsNestedInput
    teen?: TeenUpdateOneRequiredWithoutRideRequestsNestedInput
  }

  export type RideRequestUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteDriverUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutRouteAssignmentsNestedInput
  }

  export type RouteDriverUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteDriverUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteStopUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUpdateManyWithoutPickupStopNestedInput
    location?: LocationUpdateOneRequiredWithoutRouteStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropRides?: RideUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRides?: RideUncheckedUpdateManyWithoutPickupStopNestedInput
    dropRequests?: RideRequestUncheckedUpdateManyWithoutDropStopNestedInput
    pickupRequests?: RideRequestUncheckedUpdateManyWithoutPickupStopNestedInput
  }

  export type RouteStopUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    sequence?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTripNestedInput
    driver?: DriverUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideCreateManyDropStopInput = {
    id?: string
    tripId: string
    teenId: string
    pickupStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideCreateManyPickupStopInput = {
    id?: string
    tripId: string
    teenId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestCreateManyDropStopInput = {
    id?: string
    parentId: string
    teenId: string
    routeId: string
    pickupStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestCreateManyPickupStopInput = {
    id?: string
    parentId: string
    teenId: string
    routeId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideUpdateWithoutDropStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRidesNestedInput
    teen?: TeenUpdateOneRequiredWithoutRidesNestedInput
    trip?: TripUpdateOneRequiredWithoutRidesNestedInput
    transactions?: TransactionUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutDropStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateManyWithoutDropStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideUpdateWithoutPickupStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRidesNestedInput
    teen?: TeenUpdateOneRequiredWithoutRidesNestedInput
    trip?: TripUpdateOneRequiredWithoutRidesNestedInput
    transactions?: TransactionUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutPickupStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateManyWithoutPickupStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUpdateWithoutDropStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneRequiredWithoutRideRequestsNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRequestsNestedInput
    route?: RouteUpdateOneRequiredWithoutRequestsNestedInput
    teen?: TeenUpdateOneRequiredWithoutRideRequestsNestedInput
  }

  export type RideRequestUncheckedUpdateWithoutDropStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUncheckedUpdateManyWithoutDropStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUpdateWithoutPickupStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRequestsNestedInput
    parent?: ParentUpdateOneRequiredWithoutRideRequestsNestedInput
    route?: RouteUpdateOneRequiredWithoutRequestsNestedInput
    teen?: TeenUpdateOneRequiredWithoutRideRequestsNestedInput
  }

  export type RideRequestUncheckedUpdateWithoutPickupStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUncheckedUpdateManyWithoutPickupStopInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideCreateManyTripInput = {
    id?: string
    teenId: string
    pickupStopId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRidesNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRidesNestedInput
    teen?: TeenUpdateOneRequiredWithoutRidesNestedInput
    transactions?: TransactionUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateManyWithoutTripInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyRideInput = {
    id?: string
    walletId: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutRideInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestCreateManyParentInput = {
    id?: string
    teenId: string
    routeId: string
    pickupStopId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenCreateManyParentInput = {
    id?: string
    userId: string
    inviteCode?: string | null
    inviteExpiry?: Date | string | null
    inviteStatus?: $Enums.InviteStatus
    inviteType?: $Enums.InviteType | null
    name: string
    age: number
    grade?: string | null
    avatar?: string | null
    schoolId?: string | null
    emergencyContact?: string | null
    medicalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRequestsNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRequestsNestedInput
    route?: RouteUpdateOneRequiredWithoutRequestsNestedInput
    teen?: TeenUpdateOneRequiredWithoutRideRequestsNestedInput
  }

  export type RideRequestUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUpdateManyWithoutTeenNestedInput
    school?: LocationUpdateOneWithoutTeensNestedInput
    user?: UserUpdateOneRequiredWithoutTeenNestedInput
    buddyOf?: TeenBuddyUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTeenNestedInput
    rideRequests?: RideRequestUncheckedUpdateManyWithoutTeenNestedInput
    buddyOf?: TeenBuddyUncheckedUpdateManyWithoutBuddyNestedInput
    buddies?: TeenBuddyUncheckedUpdateManyWithoutTeenNestedInput
    rewards?: TeenRewardsUncheckedUpdateOneWithoutTeenNestedInput
  }

  export type TeenUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    inviteCode?: NullableStringFieldUpdateOperationsInput | string | null
    inviteExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteType?: NullableEnumInviteTypeFieldUpdateOperationsInput | $Enums.InviteType | null
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    schoolId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    medicalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteDriverCreateManyDriverInput = {
    id?: string
    routeId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripCreateManyDriverInput = {
    id?: string
    routeId: string
    date: Date | string
    status?: $Enums.TripStatus
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteDriverUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: RouteUpdateOneRequiredWithoutDriversNestedInput
  }

  export type RouteDriverUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteDriverUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUpdateManyWithoutTripNestedInput
    route?: RouteUpdateOneRequiredWithoutTripsNestedInput
  }

  export type TripUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rides?: RideUncheckedUpdateManyWithoutTripNestedInput
  }

  export type TripUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTripStatusFieldUpdateOperationsInput | $Enums.TripStatus
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideCreateManyTeenInput = {
    id?: string
    tripId: string
    pickupStopId: string
    dropStopId: string
    status: $Enums.RideStatus
    scheduledPickupTime: Date | string
    actualPickupTime?: Date | string | null
    scheduledDropTime: Date | string
    actualDropTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideRequestCreateManyTeenInput = {
    id?: string
    parentId: string
    routeId: string
    pickupStopId: string
    dropStopId: string
    requestType?: $Enums.RequestType
    seatsRequired?: number
    expectedPickupTime: Date | string
    expectedDropTime: Date | string
    status?: $Enums.RouteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenBuddyCreateManyBuddyInput = {
    id?: string
    teenId: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeenBuddyCreateManyTeenInput = {
    id?: string
    buddyId: string
    status?: $Enums.BuddyStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RideUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRidesNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRidesNestedInput
    trip?: TripUpdateOneRequiredWithoutRidesNestedInput
    transactions?: TransactionUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutRideNestedInput
  }

  export type RideUncheckedUpdateManyWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    status?: EnumRideStatusFieldUpdateOperationsInput | $Enums.RideStatus
    scheduledPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualPickupTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualDropTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropStop?: RouteStopUpdateOneRequiredWithoutDropRequestsNestedInput
    parent?: ParentUpdateOneRequiredWithoutRideRequestsNestedInput
    pickupStop?: RouteStopUpdateOneRequiredWithoutPickupRequestsNestedInput
    route?: RouteUpdateOneRequiredWithoutRequestsNestedInput
  }

  export type RideRequestUncheckedUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RideRequestUncheckedUpdateManyWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    pickupStopId?: StringFieldUpdateOperationsInput | string
    dropStopId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumRequestTypeFieldUpdateOperationsInput | $Enums.RequestType
    seatsRequired?: IntFieldUpdateOperationsInput | number
    expectedPickupTime?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDropTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumRouteStatusFieldUpdateOperationsInput | $Enums.RouteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenBuddyUpdateWithoutBuddyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teen?: TeenUpdateOneRequiredWithoutBuddiesNestedInput
  }

  export type TeenBuddyUncheckedUpdateWithoutBuddyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenBuddyUncheckedUpdateManyWithoutBuddyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teenId?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenBuddyUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    buddy?: TeenUpdateOneRequiredWithoutBuddyOfNestedInput
  }

  export type TeenBuddyUncheckedUpdateWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    buddyId?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeenBuddyUncheckedUpdateManyWithoutTeenInput = {
    id?: StringFieldUpdateOperationsInput | string
    buddyId?: StringFieldUpdateOperationsInput | string
    status?: EnumBuddyStatusFieldUpdateOperationsInput | $Enums.BuddyStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyVerificationInput = {
    id?: string
    type: $Enums.DocumentType
    number: string
    expiryDate?: Date | string | null
    fileUrl: string
    status?: $Enums.VerificationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateWithoutVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutVerificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    number?: StringFieldUpdateOperationsInput | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyWalletInput = {
    id?: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.PaymentStatus
    description?: string | null
    rideId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ride?: RideUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rideId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyRewardInput = {
    id?: string
    name: string
    description: string
    points: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}